# Tip Selection Algorithm 

## Introduction

The tip selection algorithm is the method by which messages are selected for approval by other issued messages joining the network.  This approval mechanism represents “belief” in the Tangle: If message y approves message x, this implies that y believes that x is valid and that its entire history is also valid. 

Although formelly the algorithm played a role in consensus during IOTA 1.0, this does not holds anymore. In IOTA 2.0 the tip selection plays the following role: to allow the Tangle to grow in a stable and secure way, with quick approval and finality times. 


We call the new Tip-Section algorithm "R-URTS", which means "Restricted Uniform Random Tip Selection". There are three main differences that the new algorithm has from the old one:

1. **Number of Parents:** The new algorithm has a non-fixed number of messages that needs to be approved, which ranged from two to eight.
2. **Uniform Selection:** A change from the old Random Walk tip selection, we will use a much faster and simpler solution that will select uniformly among a subset of eligible tips. 
3. **Approval Switch Mechanism:** A new mechanism that will allow us to keep a clear tangle while avoid splittings due to disliked branches. 

In the following subsections we will explain the details about the number of parents and the uniform selection, while the approval switch mechanism is introduced in Section 4.1 - The Tangle. 

We conclude this section by presenting the formal R-URTS algorithm. 


## Tip Pools 

We start this section with the proper definition of the Tip:

- **Tip**: A message is considered a tip (by a node) if its selectable by the Tip Selection Algorithm, i.e. it is an element of any _Tip Pool_ (of that node).

Although this definition is somewhat vague, it fills its purpose in saying that the classification of a message as a tip is a product of the construction of the Tip Pools. Here we will define the filters and classifications that are used to make the Tip Pools. 

 Differently from the legacy implementation, we will not have a single pool, but instead two, divided accoding to the new concenpt of the _Approval Switch_. 

We now present the theory of the approval switch, then define the many sets that are filtered in order to build the tip pools.

### Approval Switch 

One of the main improvements of the new Tip Selection Algorithm comes from its ability to keep both a clean non-conflicting subtangle, as well as to ignore the existence of conflicts in its selection, hence emulating the ability that Chrysalis' White Flag approach has of being unsplittable.Those properties comes from the approval switch. In order to explain its functionality, we will define some terms:

- **Strong approval**: We say message $x$ strongly approves message $y$ if the issuer node from $x$ asserts that both $y$ and its entirely past cone are valid and liked.  
- **Weak approval**: We say message $x$ weakly approves message $y$ if the issuer node from $x$ asserts that only $y$ is valid and liked, without any assertment about its past cone.

This leads to the classification for tips:

- **Strong Tip**: We say a tip $x$ is strong (for a node) if both that tip and its entire past cone are liked, valid and linked only through strong approvals (in the node's perception). 


- **Weak Tip**: We say a tip $x$ is weak (for a node) if in its past cone there is at last one strong approval of a message that is either not valid, not liked or also a weak Tip. 

Observe that the two definitions are complementary, so a tip is either strong or weak. 

We vaguely use the term "valid", which means that the message has passed all the basic sintactical and semantical filters, as well as being eligible (e.g. having a good timestamp). All afirmations about validity and liked are accepted with level of knowledge 2. 

### Construction of the Tip Pools 

## Parental Number
To attach a new transaction to the Tangle, the algorithm needs to select and approve  between two and eight previous messages among a list of tips.

This defined a new variable, represented by $k$, that we will call the *Parental Number*.

The variation on the number of approvals (two to eight)  is there to counteract tip spam during low-congestion periods: A higher number of approvals can merge easier the spammer eligible messages with the tangle, keeping it growing in a healthy way. The standard parental number, $k_0$, is defined as two approvals and used on periods without tips spams. 

The detection and increase in parental number is individual per node, so the whole network does not need to achieve any kind of consensus on this and even if one attacker artificially changes the perception of nodes about spam, it does not creates any harm to the node itself (aside from a low impact on performance), and hence, in the network as a whole. 

### Tip Spam Detection

As part of its standard routines, a node needs to run periodically a spam detection routine `TipSpamDetection`, that will with certain confidence detects if a tip spam is happening and give the appropriate boolean response.  

A positive response from `TipSpamDetection` updates the associated counter metadata `TipSpamAge`, that checks for how many consecutive tests the spam has persisted, while a null answer from it will set  `TipSpamAge`.  Finally, `TipSpamDetection` will update the parental number according to the current value of `TipSpamAge`.



[PLACEHOLDER FOR ROUTINE PSEUDO-ALGORITHM]



## R-URTS
The selection algorithm to be used will be the RURTS (Restricted Uniform Random Tip Selection), which selects with uniform probability among the list of tips (restricted to the eligible ones).  

Although its a simple mechanism, its important to clarify some concepts:
 -  _Eligible Message

### Game Theory 
