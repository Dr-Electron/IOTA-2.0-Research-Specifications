# Tip Selection Algorithm 

## Introduction

The tip selection algorithm is the method by which messages are selected for approval by other issued messages joining the network.  This approval mechanism represents “belief” in the Tangle: If message y approves message x, this implies that y believes that x is valid and that its entire history is also valid. 

Although formelly the algorithm played a role in consensus during IOTA 1.0, this does not holds anymore. In IOTA 2.0 the tip selection plays the following role: to allow the Tangle to grow in a stable and secure way, with quick approval and finality times. 


We call the new Tip-Section algorithm "R-URTS", which means "Restricted Uniform Random Tip Selection". Here we summarize the main diffeerences that the new Tip Selection Algorithm has, compared to the legacy version:

1. **Uniform Selection:** A change from the old Random Walk tip selection, we will use a much faster and simpler solution that will select uniformly among a subset of eligible tips. 
2. **Approval Switch Mechanism:** A new mechanism that will allow us to keep a clear tangle while avoid splittings due to disliked branches. 

In the following subsections we will explain the details about the number of parents and the uniform selection, while the approval switch mechanism is introduced in Section 4.1 - The Tangle. 

Although we will not be using here, the new message layout (more information in Section 2.2 - Message Layout) has the capabilities for a message to have a non-fixed number of messages that needs to be approved, which ranged from two to eight (compared to the fixed two approvals from the legacy implementation). This can be used to develop Tip Spam protection mechanisms and other purposes. 

## Definitions

Here we will define some terminology that will be used through this section. 

- **Validity:** A Message is considered _valid_ if it passed throught all the semantical and sintactical filters in the Message Parser (see Section 2.4 - Data Flow). 


## Tip Pools 

We start this section with the proper definition of the Tip:

- **Tip**: A message is considered a tip (by a node) if its selectable by the Tip Selection Algorithm, i.e. it is an element of any _Tip Pool_ (of that node).

Although this definition is somewhat vague, it fills its purpose in saying that the classification of a message as a tip is a product of the construction of the Tip Pools. Here we will define the filters and classifications that are used to make the Tip Pools. 

Differently from the legacy implementation, we will not have a single pool, but instead two, divided accoding to the new concenpt of the _Approval Switch_. 

We now present the theory of the approval switch, then define the many sets that are filtered in order to build the tip pools.

### Approval Switch 

One of the main improvements of the new Tip Selection Algorithm comes from its ability to keep both a clean non-conflicting subtangle, as well as to ignore the existence of conflicts in its selection, hence emulating the ability that Chrysalis' White Flag approach has of being unsplittable.Those properties comes from the approval switch. In order to explain its functionality, we will define some terms:

- **Strong approval**: We say message $x$ strongly approves message $y$ if the issuer node from $x$ asserts that both $y$ and its entirely past cone are valid and liked.  
- **Weak approval**: We say message $x$ weakly approves message $y$ if the issuer node from $x$ asserts that only $y$ is valid and liked, without any assertment about its past cone.

This leads to the classification for tips:

- **Strong Tip**: We say a tip $x$ is strong (for a node) if both that tip and its entire past cone are liked, valid and linked only through strong approvals (in the node's perception). 


- **Weak Tip**: We say a tip $x$ is weak (for a node) if in its past cone there is at last one strong approval of a message that is either not valid, not liked or also a weak Tip. 

Observe that the two definitions are complementary, so a tip or approval is either strong or weak. 

We vaguely use the term "valid", which means that the message has passed all the basic sintactical and semantical filters (Section 2.2 - Message Layout), as well as being eligible (e.g. having a good timestamp). All afirmations about validity and liked are accepted with level of knowledge 2. 

### Construction of the Tip Pools 

We will define a sequence of pools, each one selected by filtering the previous one regarding one condition, until we conclude with the two elements used in the Tip Selection Algorithm: the _Strong Tips Pool_ and the _Weak Tip Pool_. 

1. **Valid Messages Pool:** The pool consisted of all messages that were approved by the _Message Parser_. 

2. **Eligible Messages Pool:** This pool consists of all valid messages that were also approved by the _Eligibility Check_ (see Section 2.4 - Data Flow and Section X.X).

3. **Liked Payload Pool:** This pool consists of all eligible messages that had its payload tagged as "liked". 

4. **


<!--
## Parental Number
To attach a new transaction to the Tangle, the algorithm needs to select and approve  between two and eight previous messages among a list of tips.

This defined a new variable, represented by $k$, that we will call the *Parental Number*.

The variation on the number of approvals (two to eight)  is there to counteract tip spam during low-congestion periods: A higher number of approvals can merge easier the spammer eligible messages with the tangle, keeping it growing in a healthy way. The standard parental number, $k_0$, is defined as two approvals and used on periods without tips spams. 

The detection and increase in parental number is individual per node, so the whole network does not need to achieve any kind of consensus on this and even if one attacker artificially changes the perception of nodes about spam, it does not creates any harm to the node itself (aside from a low impact on performance), and hence, in the network as a whole. 

### Tip Spam Detection

As part of its standard routines, a node needs to run periodically a spam detection routine `TipSpamDetection`, that will with certain confidence detects if a tip spam is happening and give the appropriate boolean response.  

A positive response from `TipSpamDetection` updates the associated counter metadata `TipSpamAge`, that checks for how many consecutive tests the spam has persisted, while a null answer from it will set  `TipSpamAge`.  Finally, `TipSpamDetection` will update the parental number according to the current value of `TipSpamAge`.



[PLACEHOLDER FOR ROUTINE PSEUDO-ALGORITHM]

-->

## R-URTS

We want to reiterate here that, ultimately, the tip selection is a free procedure not enforced by the protocol. Hence each node may, if it sees worth, to select it approves in a manual or following another algorithm of its preference. What we will present here is the standard algorithm, that works both as a suggestion but also as something that the nodes will have implemented and will use by default. Since there is no consensus role being played by the Tip Selection Algorithm, differently from the legacy implementation, we strongly believe that such algorithm will also be used by the majority of the network. Another discussion about this may be found in [Game Theory](#Game-Theory).

The selection algorithm to be used will be the RURTS (Restricted Uniform Random Tip Selection), which selects with uniform probability among the list of tips restricted by some condition.  

Indepedently of the number of approvals being used by the application, the first approval is ALWAYS selected from the _Strong Tip Pool_, while the others will use both tip pools.  

### Game Theory 

