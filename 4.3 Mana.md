# 4.3.1 Introduction

This section introduces  **Access Mana** and **Consensus Mana** and determines which modules will use each of the two types of Mana.

Any permissionless system needs a Sybil protection mechanism. In Coordicide, this is done by forcing every node to create a node identity (see also **Peer Discovery** LINK?????). Two *Difficult-to-obtain* resources are linked to each node identity; we call them **aMana** (**Access Mana**) and **cMana** (**Consensus Mana**). 

Both Manas are, perhaps, best visualized as tools with multiple roles in the network. They are related to the IOTA token, but are not tokens by themselves (????? add a good explanation here) and do not interfere with the token balance in any way. When a value transaction is processed, a certain amount of aMana and cMana&mdash;dependent on the amount of IOTAs moved by the transaction&mdash;will be "pledged" to specified node IDs. The Mana pledged to each node ID must be stored as an extension of the ledger state. The only way a node can obtain Mana (either aMana or cMana) is to convince some token holders to pledge Mana to it. In this sense, Mana can be thought as Delegated Proof of Token Ownership. Mana provides adequate Sybil protection because is difficult to be acquired in arbitrary amounts.  

Mana is used as Sybil protection in different modules, namely congestion control, neighbor selection, consensus protocol, dRNG, and approval weights. Due to the different nature and requirements of each module, it is natural to use different formulas to calculate the Mana used by them.

Consensus Mana should be seen as the Mana that is responsible for the security of the system. In particular, it must be used for the consensus protocol, the dRNG module, and the approval weight. Moreover, it serves as an eclipse protection mechanism in the autopeering by guaranteeing that nodes of similar Mana peer with each other. Access Mana is used to grant access to the network through the congestion control; the amount of data a node may add to the Tangle is dependent on its Access Mana.

We give a short overview on how each module uses Mana:

* **Rate control**: The throughput of each node is dependent on the Access Mana owned.
* **Neighbor Selection**: Only nodes with similar Consensus Mana can peer.
* **Voting**: The voting power of a node is proportional to the Consensus Mana.
* **dRNG**: The dRNG committee consists on the top Consensus Mana nodes.

# 4.3.2. Detailed Design - General

Each transaction must have an `AccessManaNodeID` and a `ConsensusManaNodeID` field to determine which node to pledge these two types of Mana to. Both of these fields consist of a node ID from the node that will receive the Mana. Access Mana and Consensus Mana do not have to be pledged to the same node. In addition to the Mana fields, a `Timestamp` field is also part of the transactions (see ???? INSERT LINK). 

Both Manas are **exponential moving averages** (EMA) of the **Base Manas** (specifically, cMana is the EMA of Base cMana, and aMana is the EMA of Base aMana). An EMA is a type of moving average that places a greater weight and significance on the most recent data points. More precisely, the weighting for older datum decreases exponentially in time, however, never reaching zero. For more information on this subject, see ?????LINK.

We define the following parameters:

* $\gamma$- decay factor for Base aMana 
* $\alpha$- moving average factor for the cMana 
* $\beta$- moving average factor for the aMana 

It is important to note that aMana pledging happens when a transaction is confirmed on the node and booked on the Ledger State. At the same time, entries of the nodes whose aMana is not being modified during the pledging are updated only with respect to the (possibly) newer time reference. In general, updates only due to time (without aMana pledging) could happen whenever a node's aMana is being accessed by an external module (as the Congestion Control, for instance). 

On the other hand, cMana is&mdash;in general&mdash;updated only relatively to the end of each epoch (see ?????LINK). The reason behind this is that *epochs are objective*; i.e., all nodes agree on which epoch a certain message (or transaction) belongs to. Thus, since nodes agree with high probability about transactions older than `DELTA` (see ?????LINK), they will consequently agree&mdash;with high probability&mdash;about the cMana vector relative to these transactions. 

Therefore, one can assume that the nodes in sync will always use the same values for cMana, relative to a set of transactions that happened until a point (not so far) in the past. On the other hand, aMana will capture recent fluctuations, but nodes are expected to have slightly different perceptions of this quantity.

# 4.3.3 Detailed Design - Consensus Mana

The base cMana of a node `nodeID` at time `time` is defined as the sum over all unspent outputs at time `time` of transactions  with  `ConsensusManaNodeID = nodeID`. This means that, when an output is spent, its cMana pledge is revoked and pledged to a (possibly) different node. If a transaction $T_i$ with timestamp $t_i$ pledges $M_i$ cMana to a node $Z$, then the cMana evolution over time relative to this transaction will be given by:

$$
\text{cMana}_Z^{T_i}(t) = \begin{cases}
        0, \text{ if } t< t_i \\
        M_i\left(1-e^{-\alpha (t-t_i)}\right), \text{ if } t\geq t_i  \\
\end{cases}
$$

The total cMana of a node $Z$ will be, then, given by the sum of $\text{cMana}_Z^{T_i}(t)$ among all the transactions $T_i$ that pledge cMana to node $Z$. Nevertheless, computing the mana using this equation may be excessively demanding in the case where a node has multiples pledges at different times. For that reason, the cMana shall be computed recursively, updating it based on its last value. This update is suited for three different situations (here, $t_0$ is the reference time of the outdated cMana value):

1. pledging of the cMana relative to one transaction with timestamp smaller than $t_0$.  
2. pledging of the cMana relative to one transaction with timestamp larger than $t_0$.  
3. updating the cMana to a time $t_1>t_0$ without any new cMana pledging.

In the first case, the reference time of the cMana must not be changed, whereas in the second case, the reference time of the cMana must be changed to the timestamp of the transaction. This means that a node must never update the cMana to a point in the past (relatively to the last cMana calculated). The update must be done in three steps, always in the order specified below:

* _a_) **Base cMana update**. This step is done only when the cMana relative to a new transaction is being accounted. Just before updating the Base cMana vector we must stored it, since the last Base cMana state (that we call $\text{Old\_Base\_cMana}$) and the time relative to the last update are used later for the cMana calculations. This temporary vector can be deleted right after the cMana vector update.

    The update of the Base cMana state goes as follows: if a new transaction with $n$ inputs of value $x_j$ pledges cMana to a node $N$, then
    1. we add $\sum_{j=1}^{n}x_j$ to the Base cMana vector of the node $N$.
    2. Each input $I_j$ corresponds to some UTXO (and, consequently, to some transaction) stored in the Ledger State. Then, we locate the node Id (let us say, $\text{Node}_j$) to whom the cMana relative to this output was pledged to in the past. Then, we subtract $x_j$ from the Base cMana state of the node $\text{Node}_j$, for each $I_j$, $j=1,\dots,n$.

* _b_) **Updating the cMana with respect to time**. This step is done only when the reference time of the cMana must be updated. Suppose that the outdated cMana $\text{Old\_cMana}$ is relative to time $t-n$ and we want to update it to time $t$. In this case, we update the cMana entries as follows:

    $$
    \text{cMana}(\text{Node}_i)=e^{-\alpha n} \text{Old\_cMana}(\text{Node}_i)+(1-e^{-\alpha n})\text{Old\_Base\_cMana}(\text{Node}_i)
    $$
    where $\alpha$ is the moving average parameter for the cMana. 
    
* _c_) **Pledging and revoking cMana**. This step is done only when the cMana relative to a new transaction is being accounted. Suppose that the cMana is (after last step) relative to time $t$ and the transaction being added has a timestamp $t-\delta$. 
    
    If the Base cMana balance of a node $i$ instantly before we added this transaction was $\text{Old\_Base\_cMana}(\text{Node}_i)$ and the new Base cMana balance, after the addition of this transaction is $\text{Base\_cMana}(\text{Node}_i)$, then we update the cMana vector adding to each $\text{cMana(Node\_i)}$ entry the term:

    $$
    (1-e^{-\alpha \delta})[\text{Base\_cMana}(\text{Node}_i)-\text{Old\_Base\_cMana}(\text{Node}_i)]
    $$

    The term above can be negative&mdash;since some nodes have their Base cMana revoked&mdash;but the resulting cMana must not be.

<!--**Example 1:**

Suppose transaction $z$ was booked and we want to update the Base cMana vector accordingly. Additionally, suppose transaction $z$ pledges cMana to node $N_z$, transaction $x$ pledged cMana to node $N_x$, and transaction $y$ pledged cMana to node $N_y$.

<p style="text-align: center;">
<img src="https://github.com/iotaledger/Coordicide-Specifications/blob/section/mana/images/cmana.png" />
</p>

The update of the Base cMana would proceed as follows: 

1. Add 300 to the Base cMana vector of the node $N_z$.
2. Subtract 100 from the Base cMana state of the node $N_x$.
3. Subtract 200 from the Base cMana state of the node $N_y$.-->

## 4.3.3.1 Active Consensus Mana and Epochs

In general, the Consensus Mana of a node is only calculated and stored relatively to the end of each epoch. Only the values of the last `max_stored_epochs` epochs are stored. Thus, if $t_x$ is the time of the end of epoch $x$, to update the cMana vector from epoch $x-1$ to $x$, a node must perform the following algorithm:

1. Update the cMana with respect to time, as described in the step _b_ from last section, from time $t_{x-1}$ to $t_{x}$

2. For each transaction with timestamp in the interval $[t_{x-1},t_{x})$, perform (as described in the steps _a_ and _c_ from last section) the Base cMana update and the pledge and revoking of cMana, while the reference time $t_{x}$ remains constant.

Additionally, we define the Active Consensus Mana of a Node A in Epoch X as

$$
\text{Active\_cMana}(\text{Node A})=\begin{cases}
\text{cMana}(\text{Node A}), \text{ if there is at least one message from Node A with timestamp in }[t_{x-1},t_{x}) \\
0, \text{ otherwise}
\end{cases}
$$

Therefore, even if Node A has Consensus Mana greater than zero at at certain epoch, it can be considered dormant in case it did not issue any message during the same epoch. All nodes that have Active Consensus Mana in a certain epoch will form the Active Consensus Mana Set `ACMS(epoch)`.

Both calculations defined above (cMana and Active cMana on an epoch $x$) can only be carried out when epoch $x$ is finalized&mdash;that is, at least `TIMESTAMP_CUTOFF` (see timestamp spec) units of time after $t_x$&mdash;to make sure that no more valid messages belonging to the epoch will appear in the network.

The following data structures and functions must be defined:

* ActivecManaRank: mapping between Active cMana values and the list of nodes' identities with that mana; manaRank[mana] will return the node ID of the nodes with Active cMana equal to `mana`

* GetActiveConsensusMana(time): returns a mapping `ActivecManaList` between all known nodes and their Active cMana, calculated at the end of the epoch that contains `time`; ActivecManaList[node] must return the Active cMana of node `node`.

* UpdatecMana(epoch): updates the vectors `cMana`, from the end of `epoch-1` to `epoch`, pledging and revoking the Base cMana and cMana relative to all the relevant transactions. 


# 4.3.4 Detailed Design - Access Mana

When an output is spent and funds are consequently transferred, a certain amount of Base aMana&mdash;dependent on the amount of funds and the age of the output&mdash;will be pledged to a node. This pledge is never revoked, as opposed to Base cMana. Nevertheless, the Base aMana of a node will *decay* over time, which means that all the calculations for aMana will be slightly different than for cMana. The Base aMana at time $t$, relative to an output $T_i$ (of amount $M_i$) spent by a transaction with timestamp $t-n$ and generated by a transaction with timestamp $t-n-\delta$ is, for $n,\delta>0$

$$
  \text{Base\_aMana}^{T_i}(t)= M (1-e^{-\gamma \delta}) e^{-\gamma n}, \text{ if } t\geq t-n
$$ 

If this same output pledges aMana to a node $Z$, then the aMana evolution over time (again, for $n,\delta>0$) relative to it will be given by:

$$
\text{aMana}_Z^{T_i}(t) = \begin{cases}
        M_i(1-e^{-\gamma\delta})\dfrac{\beta e^{-\beta n}}{\beta-\gamma}\left(e^{(\beta-\gamma)n}-1\right), \text{ if }\beta\neq \gamma\\
        M_i(1-e^{-\gamma\delta})\gamma ne^{-\gamma n}, \text{ if } \beta= \gamma\\
\end{cases}
$$

The base aMana of a node `nodeID` at time `time` is defined as the sum over all spent outputs $T_i$ at time `time` of transactions  with  `AccessManaNodeID = nodeID`. Nevertheless, as in the cMana case, computing the mana using this equation can be excessively demanding. For that reason, the aMana shall computed recursively, updating it based on its last value. This update is suited for three different situations (here, $t_0$ is the reference time of the outdated aMana value):

1. pledging of the aMana relative to one transaction with timestamp smaller than $t_0$.  
2. pledging of the aMana relative to one transaction with timestamp larger than $t_0$.  
3. updating the aMana to a time $t_1>t_0$ without any new aMana pledging.

In the first case, the reference time of the aMana must not be changed, whereas in the second case, the reference time of the cMana must be changed to the timestamp of the transaction. This means that a node must never update the aMana to a point in the past (relatively to the last aMana calculated). The update must be done in four steps:

* **Base aMana update with respect to time**. This step is done only when the reference time of the aMana must be updated. Suppose that the outdated Base aMana $\text{Old\_Base\_aMana}$ is relative to time $t-n$ and we want to update it to time $t$. In this case, we update the aMana entries as follows:

    $$
    \text{Base\_aMana}(\text{Node}_i) = e^{-\gamma n}\text{Old\_Base\_aMana}(\text{Node}_i)
    $$

* **Base aMana pledging**. This step is done only when a new transaction is being added to the ledger state (and, consequently, new aMana is being pledged). Suppose that the new transaction consists of $m$ inputs $I_j$ (of value $x_j$), and pledges aMana to a node $N$. We update the Base aMana of node $N$ by adding to its Base aMana the value

    $$
    d=e^{-\gamma n} \sum_{j=1}^{m}x_j(1-e^{-\gamma \delta_{j}})
    $$ 
    where $\delta_{j}$ is the difference between the timestamps of the transaction that generated $I_j$ and the current transaction timestamp $t-n$, $t$ is the new reference time of the aMana, and $\gamma$ is the decay factor. This value $d$ has to be temporarily stored, since it will be used in the aMana update.

* **Updating the aMana with respect to time**. This step is done only when the reference time of the aMana must be updated. Suppose that the outdated aMana $\text{Old\_aMana}$ is relative to time $t-n$ and we want to update it to time $t$. In this case, we update the aMana entries as follows:

    $$
    \text{ aMana}(\text{Node}_i)=\begin{cases}  
    e^{-\beta n} \text{Old\_aMana}(\text{Node}_i)+\frac{e^{-\gamma n}-e^{-\beta n}}{(\beta-\gamma)e^{-\gamma n}}    \beta\text{Base\_aMana}(\text{Node}_i),\text{ if }\beta\neq\gamma\\
    e^{-\beta n} \text{Old\_aMana}(\text{Node}_i)+n\beta\text{Base\_aMana}(\text{Node}_i),\text{ if }\beta=\gamma\\
    \end{cases}
    $$

    where $\beta$ is the moving average parameter for the aMana and $\gamma$ is the Base aMana decay factor. Notice that, here, the value of $\text{Base\_aMana(Node}_i)$ used is the one already updated. 

* **Pledging aMana**. This step is done only when a new transaction is being added to the ledger state (and, consequently, new aMana is being pledged) and the new reference time of the aMana is larger than the timestamp of the transaction. Suppose that the aMana is (after last step) relative to time $t$ and the transaction being added has a timestamp $t-\delta$. Then, we update the aMana vector adding to each $\text{aMana(Node\_i)}$ entry the term:

    $$
    \begin{cases}  
    \frac{e^{-\gamma \delta}-e^{-\beta \delta}}{(\beta-\gamma)e^{-\gamma \delta}}    \beta d,\text{ if }\beta\neq\gamma\\
    \delta \beta d,\text{ if }\beta=\gamma\\
    \end{cases}
    $$
    where the term $d$ is the same it was added when updating the Base aMana vector. 

The following data structures and functions must be defined:

* GetAccessMana(): returns a mapping `AccessManaList` between all known nodes and their Access Mana, calculated at `currentTime` (which means that the aMana is updated to `currentTime` when this function is called); AccessManaList[node] must return the Access Mana of node `node`.

* UpdateaMana(transaction): whenever a transaction `transaction` is added to the Ledger State, it updates the aMana vector in order to add the aMana relative to `transaction` and to the (possibly) new reference time.

# 4.3.5. Initialization

The Mana is an extension of the ledger state, hence its calculation depends on the ledger state perception of the node. Snapshotting is the mechanism that saves the ledger states and prunes unnecessary transactions. Together with the ledger state, aMana and cMana vectors (and the reference time relative to them) are also saved, since a certain ledger state reflects a certain Mana distribution in the network. 

When a node joins the network, it will query other nodes to get their snapshot file, containing a `aMana Snapshot Vector`, a `cMana Snapshot Vector`, and two `ACMS` (one for each of the last two snapshotted epochs) that will be used as initialization data. In case of a large database, initial synching and solidification may a computationally heavy task due to the sheer amount of messages in the tangle. Mana calculation only adds to this burden. Then, some additional mechanism may be needed to be implemented, such as for example delaying Mana calculation until the initial synching is finished.

# 4.3.6. Algorithm

## 4.3.6.1. Parameter Values

The following parameters will be used by default, and all nodes must know them. We do not have explicit rules to punish nodes that clearly do not use these parameters, but we expect that they would be eventually ignored, due to other implicit mechanisms. For instance, even if the Mana vectors of a certain node are significantly different from the other nodes' view (causing a divergence from the majority's opinion in the voting protocol), with a very high probability its opinion will not affect the final outcome of the voting. For other modules (like rate control), a node with a significantly different perception of Mana will be blacklisted and will not harm the network. Thus, the nodes have plenty of incentives to follow the rules.

* `float DECAY`: decay factor for Base aMana (called $\gamma$ in the last sections). For a half life of ~6 hours we need $\gamma=0.00192541 \frac{1}{\text{min}}$
* `float C_MANA_EMA_COEFF`: moving average factor for the cMana (called $\alpha$ in the last sections). Set as the same value as $\gamma$.
* `float A_MANA_EMA_COEFF`: moving average factor for the aMana (called $\beta$ in the last sections). Set as the same value as $\gamma$.

## 4.3.6.2. Local Variables and Built-in Functions

* `object.cManaNode` stands for the node to which `object`'s cMana was pledged
* `object.amount` stands for the amount moved by `object`
* `object.aManaNode` stands for the node to which `object`'s aMana was pledged
* `transaction.inputs` stands for the list of inputs consumed by `transaction`
* `transaction.time` stands for the timestamp of `transaction`
* `nodes` stands for the list of known nodes.
* `epochTime` stands for the end of `epoch`
* `lastEpochTime` stands for the end of `epoch-1`
* `epoch.transactions` stands for the set of transactions with timestamps in the interval `[lastEpochTime,EpochTime)`
* `input.time` stands for the timestamp of the transaction that generated the output relative to `input`

## 4.3.6.3. Pseudocode - cMana Update

In this section, for the sake of clarification, we introduce an example of code of the functions defined above. 

### `UpdateBasecManaTr(transaction)`

The function `UpdateBasecManaTr(transaction)` updates the vector `basecMana`, pledging and revoking the Base cMana relative to a transaction `transaction`. 

```vbnet
FUNCTION UpdateBasecManaTr(transaction)
    basecMana[transaction.cManaNode] = basecMana[transaction.cManaNode]+transaction.amount 
    FOR input in transaction.inputs
        basecMana[input.cManaNode] = basecMana[input.cManaNode]-input.amount
```

### `UpdatecManaTime(epoch)`

The function `UpdatecManaTime(epoch)` updates the vector `cMana`, changing its reference time from the end of `epoch-1` to the end of `epoch`. 

```vbnet
FUNCTION UpdatecManaTime(epoch)
    n = epochTime-lastEpochTime
    FOR node in nodes
        cMana[node] = exp(-C_MANA_EMA_COEFF*n)*cMana[node]
                        +(1-exp(-C_MANA_EMA_COEFF*n))*basecMana[node]
```

### `UpdatecManaTr(epoch,transaction)`

The function `UpdatecManaTr(epoch,transaction)` updates the vector `cMana`, pledging and revoking the cMana relative to a transaction `transaction`. 

```vbnet
FUNCTION UpdatecManaTr(epoch,transaction)
    n = epochTime - transaction.time
    FOR node in nodes
        IF basecMana[node] != basecManaOld[node]
            cMana[node] = cMana[node]+(1-(1-C_MANA_EMA_COEFF)**n)*(basecMana[node]-basecManaOld[node])
```

### `UpdatecMana(epoch)`

The function `UpdatecMana(epoch)` updates the vectors `cMana` and `basecMana`, from the end of `epoch-1` to `epoch`, pledging and revoking the Base cMana and cMana relative to all the relevant transactions. 

```vbnet
FUNCTION UpdatecMana(epoch):
    UpdatecManaTime(epoch)
    IF epoch.transactions != NULL:
        FOR transaction in epoch.transactions:
            basecManaOld = basecMana
            UpdateBasecManaTr(transaction)
            UpdatecManaTr(epoch,transaction)
```
## 4.3.6.4. Pseudocode - aMana Update

In this section, for the sake of clarification, we introduce an example of code of the functions defined above. 

### `UpdateBaseaManaTime(t)`

The function `UpdateBaseaManaTime(t)` updates the vector `baseaMana`, changing its reference time from `lastUpdateTime` to `t`. 

```vbnet
FUNCTION UpdateBaseaManaTime(t)
    n = t-lastUpdateTime
    FOR each node i
        baseaMana[i] = baseaMana[i]*exp(-DECAY*n)  
```
### `UpdateaManaTime(t)`

The function `UpdateaManaTime(t)` updates the vector `aMana`, changing its reference time from `lastUpdateTime` to `t`. 

```vbnet
FUNCTION UpdateaManaTime(t)
    n = t-lastUpdateTime
    IF DECAY != A_MANA_EMA_COEFF
        FOR each node i
            aMana[i] = exp(-A_MANA_EMA_COEFF*n)*aMana[i]+(1-exp((DECAY-A_MANA_EMA_COEFF)*n))/(A_MANA_EMA_COEFF-DECAY))*A_MANA_EMA_COEFF*baseaMana[i]
    ELSE       
        FOR each node i
            aMana[i] = exp(-A_MANA_EMA_COEFF*n)*aMana[i]+ DECAY*A_MANA_EMA_COEFF*baseaMana[i]            
```

### `UpdateBaseaManaTr(transaction)`

The function `UpdateBaseaManaTr(t,transaction)` updates the vector `baseaMana`, pledging the Base aMana relative to a transaction `transaction`. 

```vbnet
FUNCTION UpdateBaseaManaTr(transaction)
    FOR input in transaction.inputs
        baseaMana[transaction.aManaNode] = baseaMana[transaction.aManaNode]+exp(-DECAY*(MAX(transaction.time,lastUpdateTime)-transaction.time))*input.amount*(1-exp(-DECAY*(transaction.time-input.time))) 
```

### `UpdateaManaTr(transaction)`

The function `UpdateaManaTr(transaction)` updates the vector `aMana`, pledging the aMana relative to a transaction `transaction`. 

```vbnet
FUNCTION UpdateaManaTr(transaction):
    n = lastUpdateTime-transaction.time
    IF DECAY != A_MANA_EMA_COEFF
        aMana[transaction.aManaNode] = aMana[transaction.aManaNode]+(exp(-DECAY*n)-exp(-A_MANA_EMA_COEFF*n))/(A_MANA_EMA_COEFF-DECAY))*A_MANA_EMA_COEFF*(baseaMana[transaction.aManaNode]-baseaManaOld[transaction.aManaNode])
    ELSE
        aMana[aManaNode(transaction)] = aMana[transaction.aManaNode]+exp(-DECAY*n)*DECAY*A_MANA_EMA_COEFF*(baseaMana[transaction.aManaNode]-baseaManaOld[transaction.aManaNode])

```

### `UpdateaMana(transaction)`

The function `UpdateaMana(transaction)` updates the vectors `aMana` and `baseaMana`, from `lastUpdateTime` to `MAX(lastUpdateTime, transaction.time)`, pledging the Base aMana and aMana relative to `transaction`. 

```vbnet
FUNCTION UpdateaMana(transaction):
    # if the tx is not old, add it and update the vector to t   
    IF transaction.time > lastUpdateTime:
        UpdateBaseaManaTime(transaction.time)
        UpdateaManaTime(transaction.time)
        UpdateBaseaManaTr(transaction)
        lastUpdateTime  = transaction.time        
    # add a transaction in the past    
    IF transaction.time < lastUpdateTime:
        baseaManaOld = baseaMana
        UpdateBaseaManaTr(transaction)
        UpdateaManaTr(transaction)
```
