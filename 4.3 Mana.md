+ Feature name: `Mana`
+ Start date: 2020-05-04

# Summary
This RFC defines two types of *Base Mana* calculations (*Base Mana 1* and *Base Mana 2*) and determine when the two types of *Mana* (Access Mana and Consensus Mana) will be calculated.

# Motivation

The Coordicide project introduces node identities. In order to discourage the creation of counterfeit identities (Sybils), we require a Sybil protection mechanism, which links a certain difficult-to-obtain resource to each node. In the Coordicide, we propose to use the stake as such a resource, and we refer generally to it as Mana. 

Due to the different nature of each module, it is natural to use different formulas to calculate the Mana used by them. Here, we discuss in details how to calculate each different type of Mana (Access and Consensus) of a state of the Tangle.

Mana is a crucial aspect in the following building blocks:

* Rate control: the throughput of each node is bounded by the Access Mana owned.
* Auto peering: nodes with similar Total Mana (i.e., Access + Consensus) will be neighbors with high probability.
* Voting: the weight of a vote should be proportional to the Consensus Mana owned at a certain Tangle State.
* DRNG: the DRNG committees will be constituted by the high Consensus Mana nodes, at a certain Tangle State.


We stress here that this process does not influence the actual balances in any way, but it is only used to give higher weight to “trusted” nodes.

# Detailed design

The formula to calculate both Access and Consensus Mana is still an open question, but they will be a function of a Base Mana Vector, that we explain below.

## The Base Mana Vector

### Introduction

We begin defining the *Base Mana Vector* relative to a certain Tangle State as a vector that assigns a *Base Mana 1*, *Base Mana 2*, *Effective Base Mana 1* and *Effective Base Mana 2* values to each known node. Here we call a Tangle State any triple `(Snapshot_State, Set_of_Transactions, time)`, where `Set_of_Transactions`must be compatible with the `Snapshot_State` and `time` must be larger or equal than the timestamps of all the transaction in`Set_of_Transactions` (notice that this might not be the canonical definition of a Tangle State).




  
| 					| Node 1 | Node 2 | Node 3 | ... | Node k
|  ----------------- | ---------------------------- | ------------------  | ------ | ------ | ---
| Base Mana 1 | |  |  |...|
| Effective Base Mana 1 | |  |  |...|
| Base Mana 2 |  | |  |...|
| Effective Base Mana 2 | |  ||...|  




We suppose that the Snapshot File comprehends two relevant databases: the `Ledger State` and the`Base Mana Snapshot State`. The Ledger State will be indexed by UTXO and -for each of them- contains:

* Its Value
* Its Timestamp
* Its Pledged Node ID 
* Its Address


The Base Mana Snapshot State is a database which, for each known Node ID, contains:

* Its Base Mana 1 Balance 
* Its Effective Base Mana 1 Balance
* Its Base Mana 2 Balance
* Its Effective Base Mana 2 Balance

All these balances should be floating-point variables. Additionally, the Base Mana Snapshot State database will contain the time these values refer to, that -by convention- is set as the largest timestamp among the snapshotted transactions.

The Base Mana balances reflect how much Base Mana was pledged to a certain node at the issuance time of a transaction. For that, when the node issues a transaction, it will add the Node ID of the node to whom the Base Mana is going to be pledged (that is not necessarily the same node who signed the transaction)- into the field `Mana Receiver` of the transaction. The other nodes will update their Base Mana perception accordingly to the choice of the issuing node. The two types of Base Mana (and their respective Effective Base Mana) have to be stored separately. 


The goal of this algorithm is to update the *Base Mana 1*, *Base Mana 2*, *Effective Base Mana 1* and the *Effective Base Mana 2* vectors. The *Effective Base Mana* will always be an exponential moving average applied to each Base Mana value. 


### Parameter Values
The following parameters will be hard-coded defaults. We do not have explicit rules to punish nodes that clearly do not use these parameters, but we expect that they would be eventually ignored, due to other implicit mechanisms. For instance, even if the Mana database of a certain node is significantly different from the other nodes' view (causing a divergence from the majority's opinion in the voting protocol), with a very high probability its opinion will not affect the final outcome of the voting. For other modules (like rate control), a node with a significantly different perception of Mana might be ignored and will not harm the network. Thus, we believe that the nodes have plenty incentives to follow the hard coded rules.


* $\gamma$ (`decay`)- decay factor on Base Mana 2 - (for a half life of ~6 hours we need $\gamma=0.00192541 \frac{1}{\text{min}}$)
* $\alpha$ (`EMA_coeff`)- moving averages factor - (the same as $\gamma$, for now)


### Initialization

When a node joins the network, it will query other nodes to get their snapshot file, containing a `Base Mana Snapshot State`, that will be used as initialization data. 


### Base Mana State update

The Base Mana Snapshot State will only be updated when transactions are snapshotted. Nevertheless, an updated vector of the Base Mana State can be provided whenever the function is called as a consequence of external events (like the DRNG or the rate control modules).


#### Example 1 (Snapshoting transactions): 
Suppose a node has a snapshot file that was relative to a certain point in time `T` in the past. If the node wants to update it at a certain time `t` in order to add the set of transaction `Set_of_Transactions` (note that here, `t` must be the largest timestamp among `Set_of_Transactions`, and `T` must be the largest timestamp among the snapshotted transactions), it will call the functions:

```
Update_Ledger_State(Set_of_Transactions)
Update_Mana(t,T,Set_of_Transactions)
```

In this case, in general, all the databases in the snapshot with will be modified (i.e. , the Ledger State, both Base Mana Balances, both Effective Base Mana vectors and the time it is relative to).


Next, we detail how each of the particular Base Mana vectors will be updated.

### Base Mana 1

When funds are spent from an address, an equal amount of Base Mana 1 will be pledged to a node. This pledge is revoked once the funds are spent again and pledged to a different node. 

Just before updating the Base Mana 1 vector, it has to be stored in a temporary vector: the last Base Mana 1 state and the time relative to last update are going to be used for the Effective Base Mana 1 calculations. This temporary vector can be deleted right after the Effective Base Mana 1 vector update.

The update of the Base Mana 1 state goes as follows; to each new transaction in `Set_of_Transactions`, with $n$ inputs $I_j$ (of value $x_j$) and $m$ outputs $O_j$ (of value $y_j$), pledging Base Mana to a node $N$:

* we add  $\sum_{j=1}^{m}y_j$  (or, equivalently, $\sum_{j=1}^{n}x_j$) to the Base Mana 1 vector of the node $N$.


![](https://i.imgur.com/bKMkUbK.png)


* Each input $I_j$ corresponds to some UTXO stored in the Ledger State. Then, we locate its corresponding Pledged Node ID ($\text{Node}(I_j)$) and subtract $x_j$ from the Mana state of the node $\text{Node}(I_j)$, for each $I_j$, $j=1,\dots,n$.


![](https://i.imgur.com/0X8pXAU.png)

### Effective Base Mana 1

Suppose that the largest timestamp among the transactions in `Set_of_Transactions` is $t$ and the outdated Effective Base Mana 1 vector is relative to the time $t-n$. In this case, we start the algorithm updating the Effective Base Mana 1 entries as follows:

$\begin{aligned}
\text{Effective\_Mana\_1(Node\_i)} =&  (1-\alpha)^n\text{Effective\_Mana\_1(Node\_i)}\\
+&(1-(1-\alpha)^n)\text{Mana\_1(Node\_i)}
\end{aligned}$

where $\alpha$ is a parameter set according to the desired properties of the moving averages. 

The algorithm is not finalized yet. Now, suppose that each transaction $j$ in `Set_of_Transactions`, has a timestamp $t-\delta_j$. If the Base Mana 1 balance of a node $i$ instantly before we added this transaction was $\text{Mana\_1}^{-}(\text{Node\_i})$ and the new Base Mana 1 balance, after the addition of this transaction is $\text{Mana\_1}^{+}(\text{Node\_i})$, then we update the Effective Base Mana 1 vector adding to each $\text{Effective\_Mana\_1(Node\_i)}$ entry the term:

$$
(1-(1-\alpha)^{\delta_j})[\text{Mana\_1}^{+}(\text{Node\_i})-\text{Mana\_1}^{-}(\text{Node\_i})]
$$

Obs: This term can be negative, but the resulting Effective Base Mana 1 will not be.
Obs 2: Here, we need to use an old value of $\text{Mana\_1}$. So whenever we are updating the Mana State, we need to temporarily store the $\text{Mana\_1}$ vector to update the $\text{Effective\_Mana\_1}$ state. After the $\text{Effective\_Mana\_1}$ was already updated, we can get rid of this temporary (and outdated) vector.

### Base Mana 2

When funds are transferred from an address, an amount of Base Mana 2 proportional to the funds and the time the funds spent in the address will be pledged to a node. This pledge is never revoked, as opposed to Base Mana 1. Nevertheless, the Base Mana 2 of a node will *decay* over time. The update of the Base Mana 2 state goes as follows:


Suppose that the largest timestamp among the transactions in `Set_of_Transactions` is $t$ and the outdated Base Mana 2 vector is relative to the time $t-n$. In this case, we start updating the Base Mana 2 vector as follows:

$$
  \text{Mana\_2}(\text{Node\_i})=\text{Mana\_2}(\text{Node\_i})e^{-\gamma n}
$$

where $\gamma$ is a parameter set accordingly to the desired properties of the decay (a half life). 

We continue with the algorithm as follows. Suppose that each transaction $z$ in `Set_of_Transactions`, with $n_z$ inputs $I_j$ (of value $x_j$), pledging Base Mana 2 to a node $N_z$ has its timestamp pointing to $t-\delta_z$. The node will calculate the total pending Mana that was generated until the time $t-\delta_z$ by the address relative to $I_j$, $j=1,\dots,n_z$, applying, for each $I_j$, the formula:

$$
  PM(I_j)=\frac{1}{\gamma}x_j(1-e^{-\gamma \Delta_{j}})
$$ 

where $\Delta_{j}$ is the difference between the timestamps of the output relative to $I_j$ and the current transaction timestamp $t-\delta_z$; $\gamma$ is the same parameter as above. Then, we update node $N_z$'s Base Mana 2 entry, adding the following term:

$$
 e^{-\gamma \delta_z}\sum_{j=1}^{n_z}PM(I_j)
$$

This value has to be temporarily stored to enable the Effective Base Mana 2 update.


### Effective Base Mana 2


Suppose that the largest timestamp among the transactions in `Set_of_Transactions` is $t$ and the outdated Effective Base Mana 2 vector is relative to the time $t-n$. In this case, we begin updating the Effective Base Mana 2 entries as follows:

$\begin{aligned}
\text{Effective\_Mana\_2(Node\_i)} =&  (1-\alpha)^n\text{Effective\_Mana\_2(Node\_i)}\\
+&\frac{1-(1-\alpha)^n\exp(n\gamma)}{1-(1-\alpha)\exp(\gamma)}\alpha\text{Mana\_2(Node\_i)}
\end{aligned}$

where $\alpha$ is the same parameter set for the Effective Base Mana 1 and $\gamma$ is the same parameter used to update the Base Mana 2 vector. Notice that here, the value of $\text{Mana\_2(Node\_i)}$ used is the one already updated. 


We continue as follows. Suppose that each transaction $z$ in `Set_of_Transactions` has a timestamp $t-\delta_z$. Then, if this transaction $z$ pledges Mana to node $N_z$, we update the Effective Base Mana 2 vector adding to the Effective Base Mana 2 of the node $N_z$ the term:

$$
 \frac{1-(1-\alpha)^{\delta_z}\exp(\delta_z\gamma)}{1-(1-\alpha)\exp(\gamma)}\alpha e^{-\gamma \delta_z}\sum_{j=1}^{n_z}PM(I_j)
$$


where the term $e^{-\gamma \delta_z}\sum_{j=1}^{n_z}PM(I_j)$ is the same it was added when updating the Base Mana 2 vector. Here, we need to use a value calculated by the function that updates the Base Mana 2 vector. So whenever we are updating the Base Mana 2 vector, we need to temporarily store this amount $e^{-\gamma \delta_z}\sum_{j=1}^{n_z}PM(I_j)$ to update the Effective Base Mana 2 vector. After the $\text{Effective\_Mana\_2}$ is already updated, we can get rid of this temporary variable.




### Code

In this section, for the sake of clarification, we introduce an example of code of the functions defined above. 

Obs: `Set_of_Transactions` can be an empty list, in the extreme case of not having transactions issued for a long time. In this case the variable `t` should be set to a point in time close to the node's local clock. The vectors calculated in this case cannot be used later as an old Base Mana Vector to update the database a second time.
Obs2: `time(transaction)` stands for the timestamp of a transaction. 
Obs 3: `node(transaction)` stands for the node to which the Mana of the transaction was pledged.
Obs 4: If a node wants to build the Mana database from scratch, i.e, without a already initialized Mana State, it suffices to set all Mana and Effective Mana States to zero and call the function `Get_Base_Mana(t,last_update_time,Set_of_Transactions)` setting `last_update_time` to any value of time.
Obs 5: When calling `Get_Base_Mana(t,last_update_time,Set_of_Transactions)` 

```
function Update_Base_Mana_2_time(t,last_update_time):
    n = t-last_update_time
    for each node i:
        Base_Mana_2(i) = Base_Mana_2(i)*exp(-decay*n)  
```
```
function Update_Eff_Base_Mana_1_time(t,last_update_time):
    n = t-last_update_time
    for each node i:
        Eff_Base_Mana_1(i) = (1-EMA_coeff)**n*Eff_Base_Mana_1(i)
                        +(1-(1-EMA_coeff)**n)*Base_Mana_1(i)
```
```
function Update_Eff_Base_Mana_2_time(t,last_update_time):
    n = t-last_update_time
    for each node i:
        Eff_Base_Mana_2(i) = (1-EMA_coeff)**n*Eff_Base_Mana_2(i)
                        +(1-(1-EMA_coeff)**n
                        *exp(n decay))/(1-(1-EMA_coeff)*exp(decay))
                        *EMA_coeff*Base_Mana_2(i)
```
```
function Update_Base_Mana_1_tr(transaction):
    Base_Mana_1(node(transaction)) = Base_Mana_1(node(transaction))
                                +sum_outputs(transaction) 
    for each inp in input(transaction):
        Base_Mana_1(node(inp)) = Base_Mana_1(node(inp))-amount(inp)   
```
```
function Update_Base_Mana_2_tr(t,transaction):
    for each inp in input(transaction):
        Base_Mana_2(node(transaction)) = Base_Mana_2(node(transaction))
                            +exp(-decay (t-time(transaction)))
                            *scale/decay*amount(inp)
                            *(1-exp(-decay*(time(transaction)-time(inp)))) 
```
```
function Update_Eff_Base_Mana_1_tr(t,transaction,Base_Mana_old_1):
    for each node i:
        if Base_Mana_1(i) != Base_Mana_old_1(i):
            Eff_Base_Mana_1(i) = Eff_Base_Mana_1(i)
                            +(1-(1-EMA_coeff)**(t-time(transaction)))
                            *[Base_Mana_1(i)-Base_Mana_old_1(i)]
```
```
function Update_Eff_Base_Mana_2_tr(t,transaction,Base_Mana_old_2):
    n = t-time(transaction)
    if Base_Mana_2(i) != Base_Mana_old_2(i):
        Eff_Base_Mana_2(node(transaction)) = Eff_Base_Mana_2(node(transaction))
                        +(1-(1-EMA_coeff)**n*exp(decay n))/(1-(1-EMA_coeff)*exp(decay))
                        *EMA_coeff*[Base_Mana_2(node(transaction))-Base_Mana_old_2(node(transaction))]
```
```
function Get_Base_Mana(t,last_update_time,Set_of_Transactions,Snapshot_State):
    (Base_Mana_1,Base_Mana_2,Effective_Base_Mana_1,Effective_Base_Mana_2) = Base Mana Vector from Snapshot_State
    if Set_of_Transactions != []:
        t = max(time(transactions)) among transactions in Set_of_Transactions
 
    Update_Base_Mana_2_time(t,last_update_time)
    Update_Eff_Base_Mana_1_time(t,last_update_time)
    Update_Eff_Base_Mana_2_time(t,last_update_time)
        
    for each transaction tr in Set_of_Transactions:  
        for each node i:
            Base_Mana_old_1(i) = Base_Mana_1(i)
            Base_Mana_old_2(i) = Base_Mana_2(i)
            Update_Base_Mana_1_tr(tr)
            Update_Eff_Base_Mana_1_tr(t,tr,Base_Mana_old_1)
            Update_Base_Mana_2_tr(t,tr)
            Update_Eff_Base_Mana_2_tr(t,tr,Base_Mana_old_2)        
    last_update_time  = t        
```

## Access Mana

As already mentioned, the Access Mana formulas were not finalized yet. Nevertheless, we know that the Access Mana should be updated whenever a new transaction (or a set of transactions) is booked into the main reality of a node. 

Since this Mana will be updated frequently, we do not recomend to update the Base Mana Vectors based on the Base Mana Snapshot State. Instead, a more recent Base Mana Vector should be locally stored by the components using the Access Mana and used as a outdated Base Mana Vector database.


## Consensus Mana

Here we define how the Consensus Mana will be used by two or our modules: the dRNG, and the FPC.

### dRNG

For the dRNG, the nodes need to calculate Mana values for a reference point $T_0 -\Delta_A$ (as defined [here](https://github.com/darcy-camargo/Coordicide-Specifications/blob/master/5.3%20Decentralised%20Random%20Number%20Generator.md#5351-application-messages)). To do that, the node will call the function `Get_Base_Mana(t,last_update_time,Set_of_Transactions,Snapshot_State)`, for  `Set_of_Transactions` being the set of all in the main reality with timestamp smaller than $T_0 -\Delta_A$, `t` being the largest timestamp among `Set_of_Transactions` and `last_update_time` being the time the `Snapshot_State` is relative to. Since these calculations will be done less frequently than the snapshots, no further optimisations are needed.


### FPC

For the FPC, the nodes need to calculate Mana values for a reference point $t -\Delta_B$ in the past. Like in the case of the Access Mana, this values will be updated frequently, and we do not recomend to update the Base Mana Vectors based on the Base Mana Snapshot State. Instead, a more recent Base Mana Vector should be locally stored by the components using the Access Mana and used as a outdated Base Mana Vector database.



### Autopeering

For the autopeering, the nodes should use a convex combination of the FPC Consensus Mana and the Access Mana.













<!--stackedit_data:
eyJoaXN0b3J5IjpbLTg0OTkwNTQ4MSwxNjEzNjE1Mzk0LC0zNj
gxMDM4MTYsLTE0MDE5OTkxNDcsMTM1OTQzMDAxNSwyNDkxMzE0
NjIsMjExMDI1MzA3NSwxOTAzODQ4MDk1LDIxNDcyMTU3MSwtMT
gzODQ3MzI2NCwtOTI0MDU4NDUyXX0=
-->