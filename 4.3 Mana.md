+ Feature name: `Mana`
+ Start date: 2021-04-01

# 4.3.1 Introduction

This section defines how the two types of ***Mana*** calculations (***Access Mana*** and ***Consensus Mana***) are calculated and determine when each of the two types of Mana will be used.

The Coordicide project introduces node identities. In order to discourage the creation of counterfeit identities (Sybils), we require a Sybil protection mechanism, which links a certain *difficult-to-obtain* resource to each node. We propose to use a resource related to the value transfers issued by the nodes, and we refer generally to the sybil protection mechanism as *Mana*. We denote the Mana relative to a certain set of transactions $\text{Set}$ and a certain reference point in time $\text{t}_\text{ref}$ by $\text{Mana State}(\text{Set},\text{t}_\text{ref})$.

Due to the different nature and needs of each module, it is natural to use different formulas to calculate the Mana used by them. Here, we discuss in detail how to calculate each different type of Mana (Access and Consensus, or ***aMana*** and ***cMana***, respectively) of a state of the Tangle.

Mana is a crucial aspect in the following building blocks:

* **Rate control**: The throughput of each node is bounded (from below) by the Access Mana owned.
* **Neighbor Selection**: Nodes with similar Consensus Mana will be neighbors with high probability.
* **Voting**: The voting power of a node should be proportional to the Consensus Mana owned at a certain Tangle State.
* **dRNG**: The dRNG committees will be constituted by the high Consensus Mana nodes, at a certain Tangle State.

We stress here that this process does not influence the actual token balances in any way, but it is only used to give higher weight to “trusted” nodes. 

# 4.3.2. Detailed Design

Access and Consensus Mana are the first iteration of a reputation score of a node in the IOTA network. Each transaction must have an `AccessManaNodeID` and `ConsensusManaNodeID` field to determine which node to pledge these two types of mana to. Both of these fields consist of a node ID from the receiver of mana. Access Mana and Consensus Mana do not have to be pledged to the same node. In addition to the mana fields, a `Timestamp` field is also part of the transactions (see INSERT LINK). 

The ***Access Mana Vectors*** consist of a ***Base aMana Vector*** and its respective ***Effective aMana Vector***, each of them assigning one real value to each known node in the network. Analogously, the ***Consensus Mana Vectors*** consist of a ***Base cMana Vector*** and its respective ***Effective cMana Vector***. They are both calculated locally in each node, using as input value transactions and a reference point in time (that has to be larger than the timestamps of all said value transactions). This reference time has to be stored together with the Mana values, since it will be used to update the Mana State.

|                   |   Node 1  |   Node 2  |   ...     |   Node k  |
|   :-:             |   :-:     |   :-:     |   :-:     |   :-:     |
|   Base aMana      |   $Ba_1$  |   $Ba_2$  |   ...     |   $Ba_k$  |
|   Effective aMana |   $Ea_1$  |   $Ea_2$  |   ...     |   $Ea_k$  |

<p style="text-align: center;">
Table 1: aMana Vectors
</p>

|                   |   Node 1  |   Node 2  |   ...     |   Node k  |
|   :-:             |   :-:     |   :-:     |   :-:     |   :-:     |
|   Base cMana      |   $Bc_1$  |   $Bc_2$  |   ...     |   $Bc_k$  |
|   Effective cMana |   $Ec_1$  |   $Ec_2$  |   ...     |   $Ec_k$  |

<p style="text-align: center;">
Table 2: cMana Vectors
</p>

It is important to note that both Mana pledging happens when the transaction is confirmed on the node and booked on the Ledger State. At the same time, entries of the nodes whose mana is not being modified during the pledging are updated only with respect to the (possibly) newer time reference. In general, updates only due to time (without Mana pledging) could happen whenever a node's mana is being accessed by an external module (FPC, Autopeering, DRNG, Rate Control, tools, etc.). To update the Mana State only due to time, one can use the same algorithm as the Mana pledging case, using zero as the value of the transaction being added. 

## 4.3.2.1. Initialization

The mana state machine is an extension of the ledger state, hence its calculation depends on the ledger state perception of the node. Snapshotting is the mechanism that saves the ledger states and prunes unnecessary transactions. Together with the ledger state, aMana and cMana vectors (and the reference time relative to them) are also saved, since a certain ledger state reflects a certain mana distribution in the network. 

When a node joins the network, it will query other nodes to get their snapshot file, containing a `aMana Snapshot Vector` and a `cMana Snapshot Vector`, that will be used as initialization data. In case of a large database, initial synching and solidification may a computationally heavy task due to the sheer amount of messages in the tangle. Mana calculation only adds to this burden. Then, some additional mechanism may be needed to be implemented, such as for example delaying mana calculation until the initial synching is finished.

## 4.3.2.2. Updating the Mana vectors: part 1 (Base Mana)

The `cMana Vectors` and the `aMana Vectors` are updated using different algorithms. We start by defining how each of the Base Mana Vectors will be updated when adding a new transaction to the Mana State.

### 4.3.2.2.1. Base cMana update

When funds are spent from an address, an equal amount of Base cMana will be pledged to a node. This pledge is revoked once the funds are spent again and pledged to a (possibly) different node. 

Just before updating the Base cMana vector, it has to be stored in a temporary vector; the last Base cMana state (that we call `Old_Base_cMana`) and the time relative to the last update are going to be used later for the Effective cMana calculations. This temporary vector can be deleted right after the Effective cMana vector update.

The update of the Base cMana state goes as follows: if a new transaction with $n$ inputs of value $x_j$ pledges cMana to a node $N$, then

1. we add $\sum_{j=1}^{n}x_j$ to the Base cMana vector of the node $N$.

2. Each input $I_j$ corresponds to some UTXO (and, consequently, to some transaction) stored in the Ledger State. Then, we locate the node Id (let us say, $\text{Node}_j$) to whom the cMana relative to this output was pledged to in the past. Then, we subtract $x_j$ from the Base cMana state of the node $\text{Node}_j$, for each $I_j$, $j=1,\dots,n$.

**Example 1:**

Suppose transaction $z$ was booked and we want to update the Base cMana vector accordingly. Additionally, suppose transaction $z$ pledges cMana to node $N_z$, transaction $x$ pledged cMana to node $N_x$, and transaction $y$ pledged cMana to node $N_y$.

<p style="text-align: center;">
<img src="https://github.com/iotaledger/Coordicide-Specifications/blob/section/mana/images/cmana.png" />
</p>

The update of the Base cMana would proceed as follows: 

1. Add 300 to the Base cMana vector of the node $N_z$.

2. Subtract 100 from the Base cMana state of the node $N_x$.

3. Subtract 200 from the Base cMana state of the node $N_y$.

### 4.3.2.2.2. Base aMana update

When funds are transferred from an address, a certain amount of Base aMana&mdash;dependent on the amount of funds and the time that the funds spent in this address&mdash;will be pledged to a node. This pledge is never revoked, as opposed to Base cMana. Nevertheless, the Base aMana of a node will *decay* over time, which means that (unlike in the Base cMana update) the Base aMana update will depend on the reference time $\text{t}_\text{ref}$ that the Mana State is defined. The update of the Base aMana state goes as follows:

First, suppose that the timestamp of the transaction being added to the Mana State is $t$ and the outdated Base aMana vector is relative to the time $t-n$. In this case, we start updating all the entries of the Base aMana vector to the new reference time using the formula

$$
  \text{aMana}(\text{Node}_i)=\text{aMana}(\text{Node}_i)e^{-\gamma n}
$$

where $\gamma$ is a parameter set accordingly to the desired properties of the decay (a half life). Suppose that the new transaction added to the Mana State consists of $n$ inputs $I_j$ (of value $x_j$), and pledges aMana to a node $N$. We calculate the total pending Mana that was generated until the time $t$ by $I_j$, $j=1,\dots,n$, applying the formula:

$$
  \text{PM}(I_j)=x_j(1-e^{-\gamma \Delta_{j}})
$$ 

where $\Delta_{j}$ is the difference between the timestamps of the transaction that generated $I_j$ and the current transaction timestamp $t$; $\gamma$ is the same parameter as above. Then, we update node $N$'s Base aMana entry, adding the term $\text{TPM}=\sum_{j=1}^{n}\text{PM}(I_j)$. This value has to be temporarily stored, since it will be used in the Effective aMana update.

Now, alternatively, suppose that the timestamp of the transaction being added to the Mana State is $t$ and the outdated Base aMana vector is relative to the time $t+n$, i.e., the node is trying to add to the Ledger and Mana States a transaction that occurred in the past. In this case, the node will calculate the pending Mana relative to each input $I_j$ using the same formula as above (i.e., $\text{PM}(I_j)=x_j(1-e^{-\gamma \Delta_{j}})$), but it will update node $N$'s Base aMana entry, adding the term $\text{TPM}= e^{-\gamma n}\sum_{j=1}^{n}\text{PM}(I_j)$. Analogously to the first case, this term must be temporarily stored, since it will be used in the Effective aMana update.

## 4.3.2.3. Updating the Mana vectors: part 2 (Effective Mana)

Since both Base Mana pledging processes result in discontinuous functions over time, an exponential moving average is applied, resulting in (smooth and continuous) Effective aMana and Effective cMana. 

### 4.3.2.3.1. Effective cMana update

Suppose that the timestamp of the transaction being added to the Mana State is $t$ and the outdated Effective cMana vector is relative to the time $t-n$. In this case, we start the algorithm updating the Effective cMana entries to the new, more recent, reference time as follows:

$$
\text{Effective cMana}(\text{Node}_i)=e^{-\alpha n} \text{Effective cMana}(\text{Node}_i)+(1-e^{-\alpha n})\text{Old\_Base\_cMana}(\text{Node}_i)
$$

where $\alpha$ is a parameter set according to the desired properties of the cMana moving averages. Since the new transaction timestamp matches the new Mana State time reference, the addition of this transaction will not affect the Effective cMana yet.

Now, suppose that the old reference point of the Mana State was $t$ and the transaction being added to the Mana State, has a timestamp $t-\delta$ (i.e., the node is trying to add a transaction that happened in the past). If the Base cMana balance of a node $i$ instantly before we added this transaction was $\text{cMana}^{-}(\text{Node}_i)$ and the new Base cMana balance, after the addition of this transaction is $\text{cMana}^{+}(\text{Node}_i)$, then we update the Effective cMana vector adding to each $\text{Effective\_cMana(Node\_i)}$ entry the term:

$$
(1-e^{-\alpha \delta})[\text{cMana}^{+}(\text{Node}_i)-\text{cMana}^{-}(\text{Node}_i)]
$$

Obs: This term can be negative&mdash;since some nodes have their Base cMana revoked&mdash;but the resulting Effective cMana will not be.

Obs 2: Here, we needed to use an old value of $\text{cMana}$. So whenever we are updating the Mana State, we need to temporarily store the $\text{cMana}$ vector to update the $\text{Effective\_cMana}$ state. After the $\text{Effective\_cMana}$ was already updated, we can get rid of this temporary (and outdated) vector.

### 4.3.2.3.2. Effective aMana update

Suppose that the timestamp of the transaction being added to the Mana State is $t$ and the outdated Effective aMana vector is relative to the time $t-n$. In this case, we begin updating the Effective aMana entries as follows:

$$
\text{Effective aMana}(\text{Node}_i)=e^{-\beta n} \text{Old Effective aMana}(\text{Node}_i)+\frac{e^{-\gamma \delta}-e^{-\beta \delta}}{(\beta-\gamma)e^{-\gamma \delta}}    \beta\text{Base\_aMana}(\text{Node}_i)
$$

where $\beta$ is a parameter set according to the desired properties of the aMana moving averages and $\gamma$ is the same parameter used to update the Base aMana vector. Notice that, here, the value of $\text{Base\_aMana(Node}_i)$ used is the one already updated. 

Alternatively, if the new reference time is $t$ and the transaction being added to the Mana State has a timestamp $t-\delta$ and pledges Mana to node $N$, we update the Effective aMana vector adding to the Effective aMana of the node $N$ the term:

$$
 \frac{e^{-\gamma \delta}-e^{-\beta \delta}}{(\beta-\gamma)e^{-\gamma \delta}}    \beta e^{-\gamma \delta}\sum_{j=1}^{n}\text{PM}(I_j)
$$

where the term $e^{-\gamma \delta}\sum_{j=1}^{n}\text{PM}(I_j)$ is the same it was added when updating the Base aMana vector. Here, we need to use a value calculated by the function that updates the Base aMana vector. So whenever we are updating the Base aMana vector, we need to temporarily store this amount $e^{-\gamma \delta}\sum_{j=1}^{n}\text{PM}(I_j)$ to update the Effective aMana vector. After the $\text{Effective\_aMana}$ is already updated, we can get rid of this temporary variable.

**A special case:** If $\beta=\gamma$ the formulas above are not well defined. Alternatively, in this case, we change the term $\frac{e^{-\gamma \delta}-e^{-\beta \delta}}{(\beta-\gamma)e^{-\gamma \delta}} \beta$ to $\beta \delta$ in the two Effective aMana formulas above.

# 4.3.3. Algorithm

## 4.3.3.1. Parameter Values

The following parameters will be used by default, and all nodes must know them. We do not have explicit rules to punish nodes that clearly do not use these parameters, but we expect that they would be eventually ignored, due to other implicit mechanisms. For instance, even if the Mana vectors of a certain node is significantly different from the other nodes' view (causing a divergence from the majority's opinion in the voting protocol), with a very high probability its opinion will not affect the final outcome of the voting. For other modules (like rate control), a node with a significantly different perception of Mana will be blacklisted and will not harm the network. Thus, the nodes have plenty incentives to follow the rules.


* `float decay` ($\gamma$)- decay factor for Base aMana - (for a half life of ~6 hours we need $\gamma=0.00192541 \frac{1}{\text{min}}$)
* `float EMA_coeff_c` ($\alpha$)- moving averages factor for the cMana - (the same as $\gamma$, for now)
* `float EMA_coeff_a` ($\beta$)- moving averages factor for the aMana - (the same as $\gamma$, for now)



## 4.3.3.2. Pseudocode


In this section, for the sake of clarification, we introduce an example of code of the functions defined above. 

```
function Update_Mana_Vector(transaction):
    if transaction != []:
        t = timestamp(transaction)         

        # if the tx is not old, add it and update the vector to timestamp(transaction)   
        if t > update_time:
            Update_Base_aMana_time(t,update_time)
            Update_Eff_cMana_time(t,update_time)
            Update_Eff_aMana_time(t,update_time)
            update_time  = t        
            for each node i:
                Base_cMana_old(i) = Base_cMana(i)
                Base_aMana_old(i) = Base_aMana(i)
                Update_Base_cMana_tr(transaction)
                Update_Base_aMana_tr(t,transaction)
            
        # add a transaction in the past    
        if t < update_time:
            for each node i:
                Base_cMana_old(i) = Base_cMana(i)
                Base_aMana_old(i) = Base_aMana(i)
                Update_Base_cMana_tr(transaction)
                Update_Eff_cMana_tr(t,transaction,Base_cMana_old)
                Update_Base_aMana_tr(t,transaction)
                Update_Eff_aMana_tr(t,transaction,Base_aMana_old)
```

```
function Update_Base_aMana_time(t,update_time):
    n = t-update_time
    for each node i:
        Base_aMana(i) = Base_aMana(i)*exp(-decay*n)  
```
```
function Update_Eff_cMana_time(t,update_time):
    n = t-update_time
    for each node i:
        Eff_cMana(i) = exp(-EMA_coeff_c*n)*Eff_cMana(i)
                        +(1-exp(-EMA_coeff_c*n))*Base_cMana(i)
```
```
function Update_Eff_aMana_time(t,update_time):
    n = t-update_time
    if decay != EMA_coeff_a:
        for each node i:
            Eff_aMana(i) = exp(-EMA_coeff_a*n)*Eff_aMana(i)
                        +(1-exp((decay-EMA_coeff_a)*n))/(EMA_coeff_a-decay))
                        *EMA_coeff_a*Base_aMana(i)
    else:       
        for each node i:
            Eff_aMana(i) = exp(-EMA_coeff_a*n)*Eff_aMana(i)
                         + decay*EMA_coeff_a*Base_aMana(i)              
```
```
function Update_Base_cMana_tr(transaction):
    Base_cMana(node(transaction)) = Base_cMana(node(transaction))
                                +sum_outputs(transaction) 
    for each inp in input(transaction):
        Base_cMana(node(inp)) = Base_cMana(node(inp))-amount(inp)   
```
```
function Update_Base_aMana_tr(t,transaction):
    for each inp in input(transaction):
        Base_aMana(node(transaction)) = Base_aMana(node(transaction))
                            +exp(-decay (max(t,update_time)-t))
                            *amount(inp)
                            *(1-exp(-decay*(t-time(inp)))) 
```

```
function Update_Eff_cMana_tr(t,transaction,Base_cMana_old):
    for each node i:
        if Base_cMana(i) != Base_cMana_old(i):
            Eff_cMana(i) = Eff_cMana(i)
                            +(1-(1-EMA_coeff_c)**(t-time(transaction)))
                            *[Base_cMana(i)-Base_cMana_old(i)]
```
```
function Update_Eff_aMana_tr(t,transaction,Base_aMana_old):
    n = t-time(transaction)
    if Base_aMana(i) != Base_aMana_old(i):
        if decay != EMA_coeff_a:
            Eff_aMana(node(transaction)) = Eff_aMana(node(transaction))
                        +(exp(-decay*n)-exp(-EMA_coeff_a*n))/(EMA_coeff_a-decay))
                        *EMA_coeff_a*[Base_aMana(node(transaction))-Base_aMana_old(node(transaction))]
        else:
            Eff_aMana(node(transaction)) = Eff_aMana(node(transaction))
                                +exp(-decay*n)*decay*EMA_coeff_a
                                *[Base_aMana(node(transaction))-Base_aMana_old(node(transaction))]

```
