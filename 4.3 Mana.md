+ Feature name: `Mana`
+ Start date: 2021-04-01

# Introduction

This section defines how the two types of ***Mana*** calculations (***Access Mana*** and ***Consensus Mana***) are calculated and determine when each of the two types of Mana will be used.

The Coordicide project introduces node identities. In order to discourage the creation of counterfeit identities (Sybils), we require a Sybil protection mechanism, which links a certain *difficult-to-obtain* resource to each node. We propose to use a resource related to the value transfers issued by the nodes, and we refer generally to the sybil protection mechanism as *Mana*. We denote the Mana relative to a certain set of transactions $\text{Set}$ and a certain reference point in time $\text{t}_\text{ref}$ by $\text{Mana State}(\text{Set},\text{t}_\text{ref})$.

Due to the different nature and needs of each module, it is natural to use different formulas to calculate the Mana used by them. Here, we discuss in details how to calculate each different type of Mana (Access and Consensus, or ***aMana*** and ***cMana***, respectively) of a state of the Tangle.

Mana is a crucial aspect in the following building blocks:

* **Rate control**: The throughput of each node is bounded (from below) by the Access Mana owned.
* **Neighbor Selection**: Nodes with similar Consensus Mana will be neighbors with high probability.
* **Voting**: The voting power of a node should be proportional to the Consensus Mana owned at a certain Tangle State.
* **dRNG**: The dRNG committees will be constituted by the high Consensus Mana nodes, at a certain Tangle State.

We stress here that this process does not influence the actual token balances in any way, but it is only used to give higher weight to “trusted” nodes. 

# Detailed Design

Access and Consensus Mana are the first iteration of a reputation score of a node in the IOTA network. Each transaction must have an `AccessManaNodeID` and `ConsensusManaNodeID` field to determine which node to pledge these two types of mana to. Both of these fields consist of a node ID from the receiver of mana. Access Mana and Consensus Mana do not have to be pledged to the same node. In addition to the mana fields, a `Timestamp` field is also part of the transactions (see INSERT LINK). 

The ***Access Mana Vectors*** consist of a ***Base aMana Vector*** and its respective ***Effective aMana Vector***, each of them assigning one real value to each known node in the network. Analogously, the ***Consensus Mana Vectors*** consist of a ***Base cMana Vector*** and its respective ***Effective cMana Vector***. They are both calculated locally in each node, using as input value transactions and a reference point in time (that has to be larger than the timestamps of all said value transactions). This reference time has to be stored together with the Mana values, since it will be used to update the Mana State.

|                   |   Node 1  |   Node 2  |   ...     |   Node k  |
|   :-:             |   :-:     |   :-:     |   :-:     |   :-:     |
|   Base aMana      |   $Ba_1$  |   $Ba_2$  |   ...     |   $Ba_k$  |
|   Effective aMana |   $Ea_1$  |   $Ea_2$  |   ...     |   $Ea_k$  |

<p style="text-align: center;">
Table 1: aMana Vectors
</p>

|                   |   Node 1  |   Node 2  |   ...     |   Node k  |
|   :-:             |   :-:     |   :-:     |   :-:     |   :-:     |
|   Base cMana      |   $Bc_1$  |   $Bc_2$  |   ...     |   $Bc_k$  |
|   Effective cMana |   $Ec_1$  |   $Ec_2$  |   ...     |   $Ec_k$  |

<p style="text-align: center;">
Table 2: cMana Vectors
</p>

It is important to note that both Mana pledging happens when the transaction is confirmed on the node and booked on the Ledger State. At the same time, entries of the nodes whose mana is not being modified during the pledging are updated only with respect to the (possibly) newer time reference. In general, updates only due to time (without Mana pledging) could happen whenever a node's mana is being accessed by an external module (FPC, Autopeering, DRNG, Rate Control, tools, etc.). To update the Mana State only due to time, one can use the same algorithm as the Mana pledging case, using zero as the value of the transaction being added. 

## Initialization

Mana state machine is an extension of the ledger state, hence its calculation depends on the ledger state perception of the node. Snapshotting is the mechanism that saves the ledger states and prunes unnecessary transactions. Together with the ledger state, aMana and cMana vectors (and the reference time relative to them) are also saved, since a certain ledger state reflects a certain mana distribution in the network. 

When a node joins the network, it will query other nodes to get their snapshot file, containing a `aMana Snapshot Vector` and a `cMana Snapshot Vector`, that will be used as initialization data. In case of a large database, initial synching and solidification may a computationally heavy task due to the sheer amount of messages in the tangle. Mana calculation only adds to this burden. Then, some additional mechanism may be needed to be implemented, such as for example delaying mana calculation until the initial synching is finished.

## Updating the Mana vectors: part 1 (Base Mana)

The `cMana Vectors` and the `aMana Vectors` are updated using different algorithms. We start by defining how each of the Base Mana Vectors will be updated when adding a new transaction to the Mana State:

### Base cMana update

When funds are spent from an address, an equal amount of Base cMana will be pledged to a node. This pledge is revoked once the funds are spent again and pledged to a (possibly) different node. 

Just before updating the Base cMana vector, it has to be stored in a temporary vector; the last Base cMana state (that we call `Old_Base_cMana`) and the time relative to the last update are going to be used later for the Effective cMana calculations. This temporary vector can be deleted right after the Effective cMana vector update.

The update of the Base cMana state goes as follows: if a new transaction with $n$ inputs of value $x_j$ pledges cMana to a node $N$, then

1. we add $\sum_{j=1}^{n}x_j$ to the Base cMana vector of the node $N$.

2. Each input $I_j$ corresponds to some UTXO (and, consequently, to some transaction) stored in the Ledger State. Then, we locate the node Id (let us say, $\text{Node}_j$) to whom the cMana relative to this output was pledged to in the past. Then, we subtract $x_j$ from the Base cMana state of the node $\text{Node}_j$, for each $I_j$, $j=1,\dots,n$.

**Example 1:**

Suppose transaction $z$ was booked and we want to update the Base cMana vector accordingly. Additionally, suppose transaction $z$ pledges cMana to node $N_z$, transaction $x$ pledged cMana to node $N_x$, and transaction $y$ pledged cMana to node $N_y$.

<p style="text-align: center;">
<img src="https://github.com/iotaledger/Coordicide-Specifications/blob/section/mana/images/cmana.png" />
</p>

The update of the Base cMana would proceed as follows: 

1. Add 300 to the Base cMana vector of the node $N_z$.

2. Subtract 100 from the Base cMana state of the node $N_x$.

3. Subtract 200 from the Base cMana state of the node $N_y$.

### Base aMana update

When funds are transferred from an address, an amount of Base aMana proportional to the funds and the time the funds spent in the address will be pledged to a node. This pledge is never revoked, as opposed to Base cMana. Nevertheless, the Base aMana of a node will *decay* over time, which means that (unlike in the Base cMana update) the Base aMana update will depend on the reference time $\text{t}_\text{ref}$ that the Mana State is defined. The update of the Base aMana state goes as follows:

First, suppose that the timestamp of the transaction being added to the Mana State is $t$ and the outdated Base aMana vector is relative to the time $t-n$. In this case, we start updating all the entries of the Base aMana vector to the new reference time using the formula

$$
  \text{aMana}(\text{Node}_i)=\text{aMana}(\text{Node}_i)e^{-\gamma n}
$$

where $\gamma$ is a parameter set accordingly to the desired properties of the decay (a half life). Suppose that the new transaction added to the Mana State consists of $n$ inputs $I_j$ (of value $x_j$), and pledges aMana to a node $N$. We calculate the total pending Mana that was generated until the time $t$ by $I_j$, $j=1,\dots,n$, applying the formula:

$$
  \text{PM}(I_j)=x_j(1-e^{-\gamma \Delta_{j}})
$$ 

where $\Delta_{j}$ is the difference between the timestamps of the transaction that generated $I_j$ and the current transaction timestamp $t$; $\gamma$ is the same parameter as above. Then, we update node $N$'s Base aMana entry, adding the term $\text{TPM}=\sum_{j=1}^{n}\text{PM}(I_j)$. This value has to be temporarily stored, since it will be used in the Effective aMana update.

Now, alternatively, suppose that the timestamp of the transaction being added to the Mana State is $t$ and the outdated Base aMana vector is relative to the time $t+n$, i.e., the node is trying to add to the Ledger and Mana States a transaction that occurred in the past. In this case, the node will calculate the pending Mana relative to each input $I_j$ using the same formula as above (i.e., $\text{PM}(I_j)=x_j(1-e^{-\gamma \Delta_{j}})$), but it will update node $N$'s Base aMana entry, adding the term $\text{TPM}= e^{-\gamma n}\sum_{j=1}^{n}\text{PM}(I_j)$. Analogously to the first case, this term must be temporarily stored, since it will be used in the Effective aMana update.

## Updating the Mana vectors: part 2 (Effective Mana)

Since both Base Mana pledging processes result in discontinuous functions over time, an exponential moving average is applied, resulting in (smooth and continuous) Effective aMana and Effective cMana. 

### Effective cMana update

Suppose that the timestamp of the transaction being added to the Mana State is $t$ and the outdated Effective cMana vector is relative to the time $t-n$. In this case, we start the algorithm updating the Effective cMana entries to the new, more recent, reference time as follows:

$$
\text{Effective cMana}(\text{Node}_i)=e^{-\alpha n} \text{Effective cMana}(\text{Node}_i)+(1-e^{-\alpha n})\text{Old\_Base\_cMana}(\text{Node}_i)
$$

where $\alpha$ is a parameter set according to the desired properties of the cMana moving averages. Since the new transaction timestamp matches the new Mana State time reference, the addition of this transaction will not affect the Effective cMana yet.

Now, suppose that the old reference point of the Mana State was $t$ and the transaction being added to the Mana State, has a timestamp $t-\delta$ (i.e., the node is trying to add a transaction that happened in the past). If the Base cMana balance of a node $i$ instantly before we added this transaction was $\text{cMana}^{-}(\text{Node}_i)$ and the new Base cMana balance, after the addition of this transaction is $\text{cMana}^{+}(\text{Node}_i)$, then we update the Effective cMana vector adding to each $\text{Effective\_cMana(Node\_i)}$ entry the term:

$$
(1-e^{-\alpha \delta})[\text{cMana}^{+}(\text{Node}_i)-\text{cMana}^{-}(\text{Node}_i)]
$$

Obs: This term can be negative -since some nodes have their Base cMana revoked- but the resulting Effective cMana will not be.

Obs 2: Here, we needed to use an old value of $\text{cMana}$. So whenever we are updating the Mana State, we need to temporarily store the $\text{cMana}$ vector to update the $\text{Effective\_cMana}$ state. After the $\text{Effective\_cMana}$ was already updated, we can get rid of this temporary (and outdated) vector.

### Effective aMana update

Suppose that the timestamp of the transaction being added to the Mana State is $t$ and the outdated Effective aMana vector is relative to the time $t-n$. In this case, we begin updating the Effective aMana entries as follows:

$$
\text{Effective aMana}(\text{Node}_i)=e^{-\beta n} \text{Effective aMana}(\text{Node}_i)+\frac{e^{-\gamma \delta}-e^{-\beta \delta}}{(\beta-\gamma)e^{-\gamma \delta}}    \beta\text{Base\_aMana}(\text{Node}_i)
$$

where $\beta$ is a parameter set according to the desired properties of the aMana moving averages and $\gamma$ is the same parameter used to update the Base aMana vector. Notice that, here, the value of $\text{Base\_aMana(Node}_i)$ used is the one already updated. 

Alternatively, if the new reference time is $t$ and the transaction being added to the Mana State has a timestamp $t-\delta$ and pledges Mana to node $N$, we update the Effective aMana vector adding to the Effective aMana of the node $N$ the term:

$$
 \frac{e^{-\gamma \delta}-e^{-\beta \delta}}{(\beta-\gamma)e^{-\gamma \delta}}    \beta e^{-\gamma \delta}\sum_{j=1}^{n}\text{PM}(I_j)
$$

where the term $e^{-\gamma \delta}\sum_{j=1}^{n}\text{PM}(I_j)$ is the same it was added when updating the Base aMana vector. Here, we need to use a value calculated by the function that updates the Base aMana vector. So whenever we are updating the Base aMana vector, we need to temporarily store this amount $e^{-\gamma \delta}\sum_{j=1}^{n}\text{PM}(I_j)$ to update the Effective aMana vector. After the $\text{Effective\_aMana}$ is already updated, we can get rid of this temporary variable.

**A special case:** If $\beta=\gamma$ the formulas above are not well defined. Alternatively, in this case, we change the term $\frac{e^{-\gamma \delta}-e^{-\beta \delta}}{(\beta-\gamma)e^{-\gamma \delta}} \beta$ to $\beta \delta$ in the two Effective aMana formulas above.

# Algorithm

## Parameter Values

The following parameters will be used by default, and all nodes must know them. We do not have explicit rules to punish nodes that clearly do not use these parameters, but we expect that they would be eventually ignored, due to other implicit mechanisms. For instance, even if the Mana vectors of a certain node is significantly different from the other nodes' view (causing a divergence from the majority's opinion in the voting protocol), with a very high probability its opinion will not affect the final outcome of the voting. For other modules (like rate control), a node with a significantly different perception of Mana will be blacklisted and will not harm the network. Thus, the nodes have plenty incentives to follow the rules.


* `float decay` ($\gamma$)- decay factor for Base aMana - (for a half life of ~6 hours we need $\gamma=0.00192541 \frac{1}{\text{min}}$)
* `float EMA_coeff_c` ($\alpha$)- moving averages factor for the cMana - (the same as $\gamma$, for now)
* `float EMA_coeff_a` ($\beta$)- moving averages factor for the aMana - (the same as $\gamma$, for now)


## Pseudocode

`Mana` is a struct that holds the different mana values for a given node.
Note that except for `Base cMana` calculation, we need the time when `Mana` values were updated, so we store it in the struct:
 ```go
type Mana struct {
  BaseaMana float
  EffectiveaMana float
  BasecMana float
  EffectivecMana float
  LastUpdated time
}
```

`ManaVector` is a data structure that maps `nodeID`s to `Mana`. It also has a `Type` that denotes the type
of mana this vector deals with (Access or Consensus).
```go
type BaseManaVector struct {
	vector     map[identity.ID]*Mana
	vectorType Type
}
```


### Methods
`ManaVector` should have the following methods:
 - `BookMana(transaction)`: Book mana of a transaction. Trigger `ManaBooked` event. Note, that this method updates
   `Mana` with respect to time and to new `Base aMana` and `Base aMana` values.
  - `GetaMana(nodeID)`: Returns the `Effective aMana` of a particular node. Note, that this method also updates `BaseMana` of the node with respect to time.
  - `GetcMana(nodeID)`: Returns the `Effective cMana` of a particular node. Note, that this method also updates `BaseMana` of the node with respect to time.
 - `update(nodeID, time)`: update `Base aMana`, `Effective aMana` and `Effective cMana` of a node with respect `time`.
 - `updateAll(time)`: update `Base aMana`, `Effective aMana` and `Effective cMana` of all nodes with respect to `time`.

`Mana` should have the following methods:
 - `pledgeAndUpdate(transaction)`: update `Mana` fields and pledge mana with respect to `transaction`.
 - `revokeBasecMana(amount, time)`:  update `Mana` values with respect to `time` and revoke `amount` `BasecMana`.
 - `update(time)`: update all `Mana` fields with respect to `time`.
 - `updateEcM(time)`: update `Effective cMana` wrt to `time`.
 - `updateBaM(time)`: update `Base aMana` wrt to `time`.
 - `updateEaM(time)`: update `Effective aMana` wrt to `time`.


### Booking a transaction

When a transaction gets booked into the Ledger State, `ManaVector.BookMana(transaction)` is executed (for the sake of cleanliness, here we suppose we are updating only the aMana):
```go
func (bmv *ManaVector) BookMana(tx *transaction) {
    pledgedNodeID := tx.accessMana

    for input := range tx.inputs {
        // search for the nodeID that the input's tx pledged its mana to
        inputNodeID := loadPledgedNodeIDFromInput(input)
        // save it for proper event trigger
        oldMana := bmv[inputNodeID]
        // revoke BM1
        bmv[inputNodeID].revokeBasecMana(input.balance, tx.timestamp)
    }

    // save it for proper event trigger
    oldMana :=  bmv[pledgedNodeID]
    // actually pledge and update
    bcmPledged, bamPledged := bmv[pledgedNodeID].pledgeAndUpdate(tx)
}
```
`Base cMana` is being revoked from the nodes that pledged mana for inputs that the current transaction consumes. Then, the appropriate node is located in `Mana Vector`, and mana is pledged to its `Mana`.

Note, that `revokeBasecMana` accesses the mana entry of the nodes within `Mana Vector`, therefore all values are updated with respect to `t`. Notice the two branches after the condition. When `Mana` values had been updated before the transaction's timestamp, a regular update is carried out. However, if `t` is older than the transaction timestamp, an update in the past is carried out and values are updated up to `LastUpdated`.
```go
func (bm *Mana) revokeBasecMana(amount float64, t time.Time) {
	if t.After(bm.LastUpdated) {
		// regular update
		n := t.Sub(bm.LastUpdated)
		// first, update EcM, BaM and EaM until `t`
		bm.updateEcM(n)
		bm.updateBaM(n)
		bm.updateEaM(n)

		bm.LastUpdated = t
		// revoke BcM at `t`
		bm.BasecMana -= amount
	} else {
		// update in past
		n := bm.LastUpdated.Sub(t)
		// revoke BcM at `t`
		bm.BasecMana -= amount
		// update EcM to `bm.LastUpdated`
		bm.EffectivecMana -= amount*(1-math.Pow(math.E,-EMA_coeff_1*n))
	}
}
```
The same regular and past update scheme is applied to pledging mana too:
```go
func (bm *Mana) pledgeAndUpdate(tx *transaction) (bcmPledged int, bamPledged int){
	t := tx.timestamp
	bcmPledged = sum_balance(tx.inputs)

	if t.After(bm.LastUpdated) {
		// regular update
		n := t.Sub(bm.LastUpdated)
		// first, update EcM, BaM and EaM until `t`
		bm.updateEcM(n)
		bm.updateBaM(n)
		bm.updateEaM(n)
		bm.LastUpdated = t
		bm.BasecMana += bcmPledged
		// pending mana awarded, need to see how long funds sat
		for input := range tx.inputs {
			// search for the timestamp of the UTXO that generated the input
			t_inp := LoadTxTimestampFromOutputID(input)
			bamAdd := input.balance * (1 - math.Pow(math.E, -decay*(t-t_inp)))
			bm.BaseaMana += bamAdd
			bamPledged += bamAdd
		}
	} else {
		// past update
		n := bm.LastUpdated.Sub(t)
		// update BcM and BaM at `t`
		bm.BasecMana += bcmPledged
		oldaMana = bm.BaseaMana
		for input := range tx.inputs {
			// search for the timestamp of the UTXO that generated the input
			t_inp := LoadTxTimestampFromOutputID(input)
			bamAdd := input.balance * (1-math.Pow( math.E,-decay*(t-t_inp) ) ) * math.Pow(math.E, -decay*n)
			bm.BaseaMana += bamAdd
			bamPledged += bamAdd
		}
		// update EcM and EaM to `bm.LastUpdated`
		bm.EffectivecMana += amount*(1-math.Pow(math.E,-EMA_coeff_1*n))
		if EMA_coeff_2 != decay {
			bm.EffectiveaMana += (bm.BaseaMana - oldaMana) *EMA_coeff_2*(math.Pow(math.E,-decay*n)-
                math.Pow(math.E,-EMA_coeff_2*n))/(EMA_coeff_2-decay) / math.Pow(math.E, -decay*n)
		} else {
			bm.EffectiveaMana += (bm.BaseaMana - oldaMana) * decay * n
		}
}
	return bcmPledged, bamPledged
}
```
Notice, that in case of `EMA_coeff_2 = decay`, a simplified formula can be used to calculate `EffectiveaMana`. The same approach is applied in `updateEaM()`.

```go
func (bm *Mana) updateEcM(n time.Duration) {
    bm.EffectivecMana = math.Pow(math.E, -EMA_coeff_1 * n) * bm.EffectivecMana +
                                 (1-math.Pow(math.E, -EMA_coeff_1 * n)) * bm.BasecMana
}
```
```go
func (bm *Mana) updateBaM(n time.Duration) {
    bm.BaseaMana = bm.BaseaMana * math.Pow(math.E, -decay*n)
}
```
```go
func (bm *Mana) updateEaM(n time.Duration) {
	if EMA_coeff_2 != decay {
		bm.EffectiveaMana = math.Pow(math.E, -emaCoeff2 * n) * bm.EffectiveaMana +
			(math.Pow(math.E, -decay * n) - math.Pow(math.E, -EMA_coeff_2 * n)) /
				(EMA_coeff_2 - decay) * EMA_coeff_2 / math.Pow(math.E, -decay * n)*bm.BaseaMana
	} else {
		bm.EffectiveaMana = math.Pow(math.E, -decay * n)*bm.EffectiveaMana +
			decay * n * bm.BaseaMana
	}
}
```

### Any module accesses the Base Mana Vector

In this case, the accessed entries within `Mana Vector` are updated via the method:
```go
func (bmv *ManaVector) update(nodeID ID, t time.Time ) {
    oldMana :=  bmv[nodeID]
    bmv[nodeID].update(t)
}
```
where `t` is the access time.
```go
func (bm *Mana) update(t time.Time ) {
    n := t - bm.LastUpdated
    bm.updateEcM(n)
    bm.updateBaM(n)
    bm.updateEaM(n)

    bm.LastUpdated = t
}
```





























 To do

Talk about independent update time
Talk about mana in the past
