+ Feature name: `Mana`
+ Start date: 2021-04-01

# Introduction (WIP)

This section defines two types of *Base Mana* calculations (*Base Mana 1* and *Base Mana 2*) and determine when the two types of *Mana* (Access Mana and Consensus Mana) will be used, as well as the methods to calculate them.

# Motivation

The Coordicide project introduces node identities. In order to discourage the creation of counterfeit identities (Sybils), we require a Sybil protection mechanism, which links a certain *difficult-to-obtain* resource to each node. We propose to use stake as such resource, and we refer generally to the sybil protection mechanism as *Mana*. 

Due to the different nature of each module, it is natural to use different formulas to calculate the Mana used by them. Here, we discuss in details how to calculate each different type of Mana (Access and Consensus, or aMana and cMana, respectively) of a state of the Tangle.

Mana is a crucial aspect in the following building blocks:

* Rate control: The throughput of each node is bounded (from below) by the Access Mana owned.
* Neighbor Selection: Nodes with similar Total Mana (i.e., Access + Consensus) will be neighbors with high probability. (EDIT)
* Voting: The weight of a vote should be proportional to the Consensus Mana owned at a certain Tangle State.
* dRNG: The dRNG committees will be constituted by the high Consensus Mana nodes, at a certain Tangle State.

We stress here that this process does not influence the actual token balances in any way, but it is only used to give higher weight to “trusted” nodes. 

# Detailed Design

Access and Consensus Mana are essentially the first iteration of a reputation score of a node in the IOTA network. Each transaction must have an `accessMana` and `consensusMana` field to determine which node to pledge these two types of mana to. Both of these fields denote a `nodeID`, the receiver of mana. `accessMana` and `consensusMana` do not have to be pledged to the same node. In addition to the mana fields, a `timestamp` field is also added to the transactions.

The `Access Mana Vectors` consist of a `Base aMana Vector` and its respective `Effective aMana Vector`, each of them assigning one real value to each known node in the network. Analogously, the `Consensus Mana Vectors` consist of a `Base cMana Vector` and its respective `Effective cMana Vector`. They are both calculated locally in each node, as a function that takes value transactions and a reference point in time (that has to be larger than the timestamps of all said value transactions) as input and produces the `Access Mana Vector` and the `Consensus Mana Vector` as outputs.

<p style="text-align: center;">
<img src="https://latex.codecogs.com/gif.latex?\begin{bmatrix}&space;&&space;\text{Node&space;}1&\text{Node&space;}2&space;&&space;\dots&\text{Node&space;}k&space;\\&space;\text{Base&space;aMana}&space;&&space;\text{Ba}_1&space;&\text{Ba}_2&space;&&space;\dots&space;&\text{Ba}_k&space;\\&space;\text{Eff&space;aMana}&space;&&space;\text{Ea}_1&&space;\text{Ea}_2&space;&&space;\dots&\text{Ea}_k&space;\end{bmatrix}" title="\begin{bmatrix} & \text{Node }1&\text{Node }2 & \dots&\text{Node }k \\ \text{Base aMana} & \text{Ba}_1 &\text{Ba}_2 & \dots &\text{Ba}_k \\ \text{Eff aMana} & \text{Ea}_1& \text{Ea}_2 & \dots&\text{Ea}_k \end{bmatrix}" />
<img src="https://latex.codecogs.com/gif.latex?\begin{bmatrix}&space;&&space;\text{Node&space;}1&\text{Node&space;}2&space;&&space;\dots&\text{Node&space;}k&space;\\&space;\text{Base&space;cMana}&space;&&space;\text{Bc}_1&space;&\text{Bc}_2&space;&&space;\dots&space;&\text{Bc}_k&space;\\&space;\text{Eff&space;cMana}&space;&&space;\text{Ec}_1&&space;\text{Ec}_2&space;&&space;\dots&\text{Ec}_k&space;\end{bmatrix}" title="\begin{bmatrix} & \text{Node }1&\text{Node }2 & \dots&\text{Node }k \\ \text{Base cMana} & \text{Bc}_1 &\text{Bc}_2 & \dots &\text{Bc}_k \\ \text{Eff cMana} & \text{Ec}_1& \text{Ec}_2 & \dots&\text{Ec}_k \end{bmatrix}" />
</p>

## Initialization

When a node joins the network, it will query other nodes to get their snapshot file, containing a `aMana Snapshot State` and a `cMana Snapshot State`, that will be used as initialization data. 

## Updating the Mana vectors: part 1 (Base Mana)

The `Consensus Mana Vector` and the `Access Mana Vector` are updated using different algorithms. We start by defining how each of the Base Mana Vectors will be updated when adding a new transaction to the Mana State:

### Base cMana update

When funds are spent from an address, an equal amount of Base cMana will be pledged to a node. This pledge is revoked once the funds are spent again and pledged to a different node. 

Just before updating the Base cMana vector, it has to be stored in a temporary vector; the last Base cMana state and the time relative to the last update are going to be used later for the Effective cMana calculations. This temporary vector can be deleted right after the Effective cMana vector update.

The update of the Base cMana state goes as follows: if a new transaction -with $n$ inputs $I_j$ (of value $x_j$) and $m$ outputs $O_j$ (of value $y_j$)- pledges cMana to a node $N$:

1. we add  $\sum_{j=1}^{m}y_j$  (or, equivalently, $\sum_{j=1}^{n}x_j$) to the Base cMana vector of the node $N$.

<p style="text-align: center;">
<img src="https://i.imgur.com/bKMkUbK.png" />
</p>

2. Each input $I_j$ corresponds to some UTXO (and, consequently, to some transaction) stored in the Ledger State. Then, we locate its corresponding Pledged Node ID (let us say, $\text{Node}_j$) and subtract $x_j$ from the Base cMana state of the node $\text{Node}_j$, for each $I_j$, $j=1,\dots,n$.

<p style="text-align: center;">
<img src="https://i.imgur.com/0X8pXAU.png" />
</p>


### Base aMana update

When funds are transferred from an address, an amount of Base aMana proportional to the funds and the time the funds spent in the address will be pledged to a node. This pledge is never revoked, as opposed to Base cMana. Nevertheless, the Base aMana of a node will *decay* over time. The update of the Base aMana state goes as follows:

Suppose that the timestamp of the transaction being added to the Mana State is $t$ and the outdated Base aMana vector is relative to the time $t-n$. In this case, we start updating the Base aMana vector as follows:

$$
  \text{aMana}(\text{Node\_i})=\text{aMana}(\text{Node\_i})e^{-\gamma n}
$$

where $\gamma$ is a parameter set accordingly to the desired properties of the decay (a half life). 

We continue with the algorithm as follows. Suppose that the new transaction added to the Mana State consisting of $n$ inputs $I_j$ (of value $x_j$), and pledging Base aMana to a node $N$, has its timestamp pointing to $t-\delta$. The node will calculate the total pending Mana that was generated until the time $t-\delta$ by the address relative to $I_j$, $j=1,\dots,n$, applying, for each $I_j$, the formula:

$$
  \text{PM}(I_j)=\frac{1}{\gamma}x_j(1-e^{-\gamma \Delta_{j}})
$$ 

where $\Delta_{j}$ is the difference between the timestamps of the output relative to $I_j$ and the current transaction timestamp $t-\delta$; $\gamma$ is the same parameter as above. Then, we update node $N$'s Base aMana entry, adding the following term:

$$
 e^{-\gamma \delta}\sum_{j=1}^{n}\text{PM}(I_j)
$$

This value has to be temporarily stored to enable the Effective aMana update.


## Updating the Mana vectors: part 2 (Effective Mana)

Since both `Base Mana` pledging processes result in discontinuous functions over time, an exponential moving average is applied, resulting in (smooth and continuous) `Effective aMana` and `Effective cMana`.

### Effective cMana

Suppose that the timestamp of the transaction being added to the Mana State is $t$ and the outdated Effective cMana vector is relative to the time $t-n$. In this case, we start the algorithm updating the Effective cMana entries as follows:

<img src="https://latex.codecogs.com/gif.latex?\begin{aligned}&space;\text{Effective\_cMana(Node\_i)}&space;=&&space;(1-\alpha)^n\text{Effective\_cMana(Node\_i)}\\&space;&plus;&(1-(1-\alpha)^n)\text{cMana(Node\_i)}&space;\end{aligned}" title="\begin{aligned} \text{Effective\_cMana(Node\_i)} =& (1-\alpha)^n\text{Effective\_cMana(Node\_i)}\\ +&(1-(1-\alpha)^n)\text{cMana(Node\_i)} \end{aligned}" />

where $\alpha$ is a parameter set according to the desired properties of the moving averages. 

The algorithm is not finalized yet. Now, suppose that the transaction being added to the Mana State, has a timestamp $t-\delta$. If the Base cMana balance of a node $i$ instantly before we added this transaction was $\text{cMana}^{-}(\text{Node\_i})$ and the new Base cMana balance, after the addition of this transaction is $\text{cMana}^{+}(\text{Node\_i})$, then we update the Effective cMana vector adding to each $\text{Effective\_cMana(Node\_i)}$ entry the term:

$$
(1-(1-\alpha)^{\delta})[\text{cMana}^{+}(\text{Node\_i})-\text{cMana}^{-}(\text{Node\_i})]
$$

Obs: This term can be negative, but the resulting Effective cMana will not be.
Obs 2: Here, we need to use an old value of $\text{cMana}$. So whenever we are updating the Mana State, we need to temporarily store the $\text{cMana}$ vector to update the $\text{Effective\_cMana}$ state. After the $\text{Effective\_cMana}$ was already updated, we can get rid of this temporary (and outdated) vector.

### Effective aMana

Suppose that the timestamp of the transaction being added to the Mana State is $t$ and the outdated Effective aMana vector is relative to the time $t-n$. In this case, we begin updating the Effective aMana entries as follows:

<img src="https://latex.codecogs.com/png.latex?\begin{aligned}&space;\text{Effective\_aMana(Node\_i)}&space;=&&space;(1-\alpha)^n\text{Effective\_aMana(Node\_i)}\\&space;&plus;&\frac{1-(1-\alpha)^n\exp(n\gamma)}{1-(1-\alpha)\exp(\gamma)}\alpha\text{aMana(Node\_i)}&space;\end{aligned}" title="\begin{aligned} \text{Effective\_aMana(Node\_i)} =& (1-\alpha)^n\text{Effective\_aMana(Node\_i)}\\ +&\frac{1-(1-\alpha)^n\exp(n\gamma)}{1-(1-\alpha)\exp(\gamma)}\alpha\text{aMana(Node\_i)} \end{aligned}" />

where $\alpha$ is the same parameter set for the Effective aMana and $\gamma$ is the same parameter used to update the Base aMana vector. Notice that here, the value of $\text{aMana(Node\_i)}$ used is the one already updated. 

We continue as follows. Suppose that the transaction being added to the Mana State has a timestamp $t-\delta$. Then, if this transaction pledges Mana to node $N$, we update the Effective aMana vector adding to the Effective aMana of the node $N$ the term:

$$
 \frac{1-(1-\alpha)^{\delta}\exp(\delta\gamma)}{1-(1-\alpha)\exp(\gamma)}\alpha e^{-\gamma \delta}\sum_{j=1}^{n}\text{PM}(I_j)
$$


where the term $e^{-\gamma \delta}\sum_{j=1}^{n}\text{PM}(I_j)$ is the same it was added when updating the Base aMana vector. Here, we need to use a value calculated by the function that updates the Base aMana vector. So whenever we are updating the Base aMana vector, we need to temporarily store this amount $e^{-\gamma \delta}\sum_{j=1}^{n}\text{PM}(I_j)$ to update the Effective aMana vector. After the $\text{Effective\_aMana}$ is already updated, we can get rid of this temporary variable.
