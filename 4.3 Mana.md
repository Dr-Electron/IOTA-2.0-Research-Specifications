+ Feature name: `Mana`
+ Start date: 2021-04-01

# 4.3.1 Introduction

This section introduces  **Access Mana** and **Consensus Mana** and determines which modules will use each of the two types of Mana.

Any permissionless system needs a Sybil protection mechanism. In coordicide, this is done by forcing every node to create a node identity (see also **Peer Discovery** LINK?????). Two *Difficult-to-obtain* resources are linked to each node identity; we call them **aMana** (**Access Mana**) and **cMana** (**Consensus Mana**). 

Both Manas are, perhaps, best visualized as tools with multiple roles in the network. They are related to the IOTA token, but are not tokens by themselves (????? add a good explanation here) and do not interfere with the token balance in any way. When a value transaction is processed, a certain amount of aMana and cMana&mdash;dependent on the amount of IOTAs moved by the transaction&mdash;will be "pledged" to specified node IDs. The Mana pledged to each node ID must be stored as an extension of the ledger state. The only way a node can obtain Mana (either aMana or cMana) is to convince some token holders to pledge Mana to it. In this sense, Mana can be thought as Delegated Proof of Token Ownership. Mana provides adequate Sybil protection because is difficult to be acquired in arbitrary amounts.  

Mana is used as Sybil protection in different modules, namely congestion control, neighbor selection, consensus protocol, dRNG, and approval weights. Due to the different nature and requirements of each module, it is natural to use different formulas to calculate the Mana used by them.

Consensus Mana should be seen as the Mana that is responsible for the security of the system. In particular, it must be used for the consensus protocol, the dRNG module, and the approval weight. Moreover, it serves as an eclipse protection mechanism in the autopeering by guaranteeing that nodes of similar Mana peer with each other. Access Mana is used to grant access to the network through the congestion control; the amount of data a node can add to the Tangle is dependent to its access Mana.

We give a short overview on how each module uses Mana:

* **Rate control**: The throughput of each node is dependent on the Access Mana owned.
* **Neighbor Selection**: Only nodes with similar Consensus Mana can peer.
* **Voting**: The voting power of a node is proportional to the Consensus Mana.
* **dRNG**: The dRNG committee consists on the top Consensus Mana nodes.

# 4.3.2. Detailed Design

Each transaction must have an `AccessManaNodeID` and a `ConsensusManaNodeID` field to determine which node to pledge these two types of Mana to. Both of these fields consist of a node ID from the node that will receive the Mana. Access Mana and Consensus Mana do not have to be pledged to the same node. In addition to the Mana fields, a `Timestamp` field is also part of the transactions (see INSERT LINK). 

Both Manas are **exponential moving averages** (EMA) of the **Base Manas** (specifically, cMana is the EMA of Base cMana, and aMana is the EMA of Base aMana). An EMA is a type of moving average that places a greater weight and significance on the most recent data points. More precisely, the weighting for older datum decreases exponentially in time, however, never reaching zero. For more information on this subject, see ?????LINK.

We define the following parameters:

* $\gamma$- decay factor for Base aMana 
* $\alpha$- moving average factor for the cMana 
* $\beta$- moving average factor for the aMana 

It is important to note that both Mana pledging happens when a transaction is confirmed on the node and booked on the Ledger State. At the same time, entries of the nodes whose Mana is not being modified during the pledging are updated only with respect to the (possibly) newer time reference. In general, updates only due to time (without Mana pledging) could happen whenever a node's Mana is being accessed by an external module (FPC, Autopeering, DRNG, Rate Control, tools, etc.).

## 4.3.2.1 Consensus Mana

The base cMana of a node `nodeID` at time `time` is defined as the sum over all unspent outputs at time `time` of transactions  with  `ConsensusManaNodeID = nodeID`. This means that, when an output is spent, its cMana pledge is revoked and pledged to a (possibly) different node. If a transaction $T_i$ with timestamp $t_i$ pledges $M_i$ cMana to a node $Z$, then the cMana evolution over time relative to this transaction will be given by:

$$
\text{cMana}_Z^{T_i}(t) = \begin{cases}
        0, \text{ if } t< t_i \\
        M_i\left(1-e^{-\alpha (t-t_i)}\right), \text{ if } t\geq t_i  \\
\end{cases}
$$

The total cMana of a node $Z$ will be, then, given by the sum of $\text{cMana}_Z^{T_i}(t)$ among all the transactions $T_i$ that pledge cMana to node $Z$. Nevertheless, computing the mana using this equation can be excessively demanding in the case where a node has multiples pledges at different times. For that reason, the cMana shall computed recursively, updating it based on its last value. This update is suited for three different situations (here, $t_0$ is the reference time of the outdated cMana value):

1. pledging of the cMana relative to one transaction with timestamp smaller than $t_0$.  
2. pledging of the cMana relative to one transaction with timestamp larger than $t_0$.  
3. updating the cMana to a time $t_1>t_0$ without any new cMana pledging.

In the first case, the reference time of the cMana must not be changed, whereas in the second case, the reference time of the cMana must be changed to the timestamp of the transaction. This means that a node must never update the cMana to a point in the past (relatively to the last cMana calculated). The update must be done in three steps:

* **Base cMana update**. This step is done only when a new transaction is being added to the ledger state (and, consequently, new cMana is being pledged). Just before updating the Base cMana vector, it has to be stored in a temporary vector; the last Base cMana state (that we call $\text{Old\_Base\_cMana}$) and the time relative to the last update are going to be used later for the cMana calculations. This temporary vector can be deleted right after the cMana vector update.
    The update of the Base cMana state goes as follows: if a new transaction with $n$ inputs of value $x_j$ pledges cMana to a node $N$, then
    1. we add $\sum_{j=1}^{n}x_j$ to the Base cMana vector of the node $N$.
    2. Each input $I_j$ corresponds to some UTXO (and, consequently, to some transaction) stored in the Ledger State. Then, we locate the node Id (let us say, $\text{Node}_j$) to whom the cMana relative to this output was pledged to in the past. Then, we subtract $x_j$ from the Base cMana state of the node $\text{Node}_j$, for each $I_j$, $j=1,\dots,n$.

* **Updating the cMana with respect to time**. This step is done only when the reference time of the cMana must be updated. Suppose that the outdated cMana is relative to time $t-n$ and we want to update it to time $t$. In this case, we update the cMana entries as follows:

    $$
    \text{cMana}(\text{Node}_i)=e^{-\alpha n} \text{cMana}(\text{Node}_i)+(1-e^{-\alpha n})\text{Old\_Base\_cMana}(\text{Node}_i)
    $$
    where $\alpha$ is the moving average parameter for the cMana. 
    
* **Pledging and revoking cMana**. This step is done only when a new transaction is being added to the ledger state (and, consequently, new cMana is being pledged). Suppose that the cMana is (after last step) relative to time $t$ and the transaction being added has a timestamp $t-\delta$. 
    
    If the Base cMana balance of a node $i$ instantly before we added this transaction was $\text{Old\_Base\_cMana}(\text{Node}_i)$ and the new Base cMana balance, after the addition of this transaction is $\text{Base\_cMana}(\text{Node}_i)$, then we update the cMana vector adding to each $\text{cMana(Node\_i)}$ entry the term:

    $$
    (1-e^{-\alpha \delta})[\text{Base\_cMana}(\text{Node}_i)-\text{Old\_Base\_cMana}(\text{Node}_i)]
    $$

    The term above can be negative&mdash;since some nodes have their Base cMana revoked&mdash;but the resulting cMana must not be.

**Example 1:**

Suppose transaction $z$ was booked and we want to update the Base cMana vector accordingly. Additionally, suppose transaction $z$ pledges cMana to node $N_z$, transaction $x$ pledged cMana to node $N_x$, and transaction $y$ pledged cMana to node $N_y$.

<p style="text-align: center;">
<img src="https://github.com/iotaledger/Coordicide-Specifications/blob/section/mana/images/cmana.png" />
</p>

The update of the Base cMana would proceed as follows: 

1. Add 300 to the Base cMana vector of the node $N_z$.
2. Subtract 100 from the Base cMana state of the node $N_x$.
3. Subtract 200 from the Base cMana state of the node $N_y$.

## 4.3.2.2 Access Mana

When an output is spent and funds are consequently transferred, a certain amount of Base aMana&mdash;dependent on the amount of funds and the age of the output&mdash;will be pledged to a node. This pledge is never revoked, as opposed to Base cMana. Nevertheless, the Base aMana of a node will *decay* over time, which means that all the calculations for aMana will be slightly different than for cMana. The Base aMana at time $t$, relative to an output $T_i$ (of amount $M_i$) spent by a transaction wih timestamp $t-n$ and generated by a transaction wih timestamp $t-n-\delta$ is, for $n,\delta>0$

$$
  \text{Base\_aMana}^{T_i}(t)= M (1-e^{-\gamma \delta}) e^{-\gamma n}, \text{ if } t\geq t-n
$$ 

If this same output pledges aMana to a node $Z$, then the aMana evolution over time (again, for $n,\delta>0$) relative to it will be given by:

$$
\text{aMana}_Z^{T_i}(t) = \begin{cases}
        M_i(1-e^{-\gamma\delta})\dfrac{\beta e^{-\beta n}}{\beta-\gamma}\left(e^{(\beta-\gamma)n}-1\right), \text{ if }\beta\neq \gamma\\
        M_i(1-e^{-\gamma\delta})\gamma ne^{-\gamma n}, \text{ if } \beta= \gamma\\
\end{cases}
$$

The base aMana of a node `nodeID` at time `time` is defined as the sum over all spent outputs $T_i$ at time `time` of transactions  with  `AccessManaNodeID = nodeID`. Nevertheless, as in the cMana case, computing the mana using this equation can be excessively demanding. For that reason, the aMana shall computed recursively, updating it based on its last value. This update is suited for three different situations (here, $t_0$ is the reference time of the outdated aMana value):

1. pledging of the aMana relative to one transaction with timestamp smaller than $t_0$.  
2. pledging of the aMana relative to one transaction with timestamp larger than $t_0$.  
3. updating the aMana to a time $t_1>t_0$ without any new aMana pledging.

In the first case, the reference time of the aMana must not be changed, whereas in the second case, the reference time of the cMana must be changed to the timestamp of the transaction. This means that a node must never update the aMana to a point in the past (relatively to the last aMana calculated). The update must be done in four steps:

* **Base aMana update with respect to time**. This step is done only when the reference time of the aMana must be updated. Suppose that the outdated Base aMana is relative to time $t-n$ and we want to update it to time $t$. In this case, we update the aMana entries as follows:

    $$
    \text{Base\_aMana}(\text{Node}_i) = e^{-\gamma n}\text{Base\_aMana}(\text{Node}_i)
    $$

* **Base aMana pledging**. This step is done only when a new transaction is being added to the ledger state (and, consequently, new aMana is being pledged). Suppose that the new transaction consists of $m$ inputs $I_j$ (of value $x_j$), and pledges aMana to a node $N$. We update the Base aMana of node $N$ by adding to its Base aMana the value

    $$
    d=e^{-\gamma n} \sum_{j=1}^{m}x_j(1-e^{-\gamma \delta_{j}})
    $$ 
    where $\delta_{j}$ is the difference between the timestamps of the transaction that generated $I_j$ and the current transaction timestamp $t-n$, $t$ is the new reference time of the aMana, and $\gamma$ is the decay factor. This value $d$ has to be temporarily stored, since it will be used in the aMana update.

* **Updating the aMana with respect to time**. This step is done only when the reference time of the aMana must be updated. Suppose that the outdated aMana is relative to time $t-n$ and we want to update it to time $t$. In this case, we update the aMana entries as follows:

    $$
    \text{ aMana}(\text{Node}_i)=\begin{cases}  
    e^{-\beta n} \text{Old  aMana}(\text{Node}_i)+\frac{e^{-\gamma n}-e^{-\beta n}}{(\beta-\gamma)e^{-\gamma n}}    \beta\text{Base\_aMana}(\text{Node}_i),\text{ if }\beta\neq\gamma\\
    e^{-\beta n} \text{Old  aMana}(\text{Node}_i)+n\beta\text{Base\_aMana}(\text{Node}_i),\text{ if }\beta=\gamma\\
    \end{cases}
    $$

    where $\beta$ is the moving average parameter for the aMana and $\gamma$ is the Base aMana decay factor. Notice that, here, the value of $\text{Base\_aMana(Node}_i)$ used is the one already updated. 

* **Pledging aMana**. This step is done only when a new transaction is being added to the ledger state (and, consequently, new aMana is being pledged). Suppose that the aMana is (after last step) relative to time $t$ and the transaction being added has a timestamp $t-\delta$. Then, we update the aMana vector adding to each $\text{aMana(Node\_i)}$ entry the term:

    $$
    \begin{cases}  
    \frac{e^{-\gamma \delta}-e^{-\beta \delta}}{(\beta-\gamma)e^{-\gamma \delta}}    \beta d,\text{ if }\beta\neq\gamma\\
    \delta \beta d,\text{ if }\beta=\gamma\\
    \end{cases}
    $$
    where the term $d$ is the same it was added when updating the Base aMana vector. 
    

## 4.3.2.3. Initialization

The Mana state machine is an extension of the ledger state, hence its calculation depends on the ledger state perception of the node. Snapshotting is the mechanism that saves the ledger states and prunes unnecessary transactions. Together with the ledger state, aMana and cMana vectors (and the reference time relative to them) are also saved, since a certain ledger state reflects a certain Mana distribution in the network. 

When a node joins the network, it will query other nodes to get their snapshot file, containing a `aMana Snapshot Vector` and a `cMana Snapshot Vector`, that will be used as initialization data. In case of a large database, initial synching and solidification may a computationally heavy task due to the sheer amount of messages in the tangle. Mana calculation only adds to this burden. Then, some additional mechanism may be needed to be implemented, such as for example delaying Mana calculation until the initial synching is finished.

# 4.3.3. Algorithm

## 4.3.3.1. Parameter Values

The following parameters will be used by default, and all nodes must know them. We do not have explicit rules to punish nodes that clearly do not use these parameters, but we expect that they would be eventually ignored, due to other implicit mechanisms. For instance, even if the Mana vectors of a certain node is significantly different from the other nodes' view (causing a divergence from the majority's opinion in the voting protocol), with a very high probability its opinion will not affect the final outcome of the voting. For other modules (like rate control), a node with a significantly different perception of Mana will be blacklisted and will not harm the network. Thus, the nodes have plenty incentives to follow the rules.

* `float decay` ($\gamma$)- decay factor for Base aMana - (for a half life of ~6 hours we need $\gamma=0.00192541 \frac{1}{\text{min}}$)
* `float EMA_coeff_c` ($\alpha$)- moving average factor for the cMana - (the same as $\gamma$, for now)
* `float EMA_coeff_a` ($\beta$)- moving average factor for the aMana - (the same as $\gamma$, for now)

## 4.3.3.2. Pseudocode

In this section, for the sake of clarification, we introduce an example of code of the functions defined above. 

```
function Update_Mana_Vector(transaction):
    if transaction != []:
        t = timestamp(transaction)         

        # if the tx is not old, add it and update the vector to timestamp(transaction)   
        if t > update_time:
            Update_Base_aMana_time(t,update_time)
            Update_Eff_cMana_time(t,update_time)
            Update_Eff_aMana_time(t,update_time)
            update_time  = t        
            for each node i:
                Base_cMana_old(i) = Base_cMana(i)
                Base_aMana_old(i) = Base_aMana(i)
                Update_Base_cMana_tr(transaction)
                Update_Base_aMana_tr(t,transaction)
            
        # add a transaction in the past    
        if t < update_time:
            for each node i:
                Base_cMana_old(i) = Base_cMana(i)
                Base_aMana_old(i) = Base_aMana(i)
                Update_Base_cMana_tr(transaction)
                Update_Eff_cMana_tr(t,transaction,Base_cMana_old)
                Update_Base_aMana_tr(t,transaction)
                Update_Eff_aMana_tr(t,transaction,Base_aMana_old)
```

```
function Update_Base_aMana_time(t,update_time):
    n = t-update_time
    for each node i:
        Base_aMana(i) = Base_aMana(i)*exp(-decay*n)  
```
```
function Update_Eff_cMana_time(t,update_time):
    n = t-update_time
    for each node i:
        Eff_cMana(i) = exp(-EMA_coeff_c*n)*Eff_cMana(i)
                        +(1-exp(-EMA_coeff_c*n))*Base_cMana(i)
```
```
function Update_Eff_aMana_time(t,update_time):
    n = t-update_time
    if decay != EMA_coeff_a:
        for each node i:
            Eff_aMana(i) = exp(-EMA_coeff_a*n)*Eff_aMana(i)
                        +(1-exp((decay-EMA_coeff_a)*n))/(EMA_coeff_a-decay))
                        *EMA_coeff_a*Base_aMana(i)
    else:       
        for each node i:
            Eff_aMana(i) = exp(-EMA_coeff_a*n)*Eff_aMana(i)
                         + decay*EMA_coeff_a*Base_aMana(i)              
```
```
function Update_Base_cMana_tr(transaction):
    Base_cMana(node(transaction)) = Base_cMana(node(transaction))
                                +sum_outputs(transaction) 
    for each inp in input(transaction):
        Base_cMana(node(inp)) = Base_cMana(node(inp))-amount(inp)   
```
```
function Update_Base_aMana_tr(t,transaction):
    for each inp in input(transaction):
        Base_aMana(node(transaction)) = Base_aMana(node(transaction))
                            +exp(-decay (max(t,update_time)-t))
                            *amount(inp)
                            *(1-exp(-decay*(t-time(inp)))) 
```

```
function Update_Eff_cMana_tr(t,transaction,Base_cMana_old):
    for each node i:
        if Base_cMana(i) != Base_cMana_old(i):
            Eff_cMana(i) = Eff_cMana(i)
                            +(1-(1-EMA_coeff_c)**(t-time(transaction)))
                            *[Base_cMana(i)-Base_cMana_old(i)]
```
```
function Update_Eff_aMana_tr(t,transaction,Base_aMana_old):
    n = t-time(transaction)
    if Base_aMana(i) != Base_aMana_old(i):
        if decay != EMA_coeff_a:
            Eff_aMana(node(transaction)) = Eff_aMana(node(transaction))
                        +(exp(-decay*n)-exp(-EMA_coeff_a*n))/(EMA_coeff_a-decay))
                        *EMA_coeff_a*[Base_aMana(node(transaction))-Base_aMana_old(node(transaction))]
        else:
            Eff_aMana(node(transaction)) = Eff_aMana(node(transaction))
                                +exp(-decay*n)*decay*EMA_coeff_a
                                *[Base_aMana(node(transaction))-Base_aMana_old(node(transaction))]

```
