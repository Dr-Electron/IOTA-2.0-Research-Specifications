This note details how the value tangle will be managed.

Created June 12th.


# 4.1.1 Summary

In this specification, we outline the value tangle management, which forms the backbone of the value transfer application.  In this specification, we describe how transfers are verified, decided upon, and recorded.  


We highly recommend first reading the [message tangle specification](https://https://hackmd.io/YfrUh4wqSua0Ou4-XHwYIA?both).  Overall the message tangle is much simpler because it has no conflicts.  However, the basic tangle management is described in great detail.  Instead of retyping many of these explanations, we will often simply refer the reader to that specification. 

This specification covers a lot of information.  For the reader's ease, the Components section is broken up into the following subsections, each one formatted as a small specification. 

1. Timestamps
2. Indexed transactions and reattachments
3. Solidification
4. Conflict detection 
5. Tip Selection
6. Correction Check
7. Finality
8. Snapshotting

# 4.1.2 Preliminaries
## 4.1.2.1 Parameters, lists, and functions
The following are parameters.  
* `d` Estimation of network delay ~5 seconds. We assume all messages arrive at almost all  nodes in this time.  
* `c` FCoB parameter ~d.
* `D` Gratuitous network delay~5 minutes.  We assume all messages are delivered to all nodes within this time.  This parameter is also used in the message tangle.  
* `w` window~30 minutes. Require `w>2D`. This parameter is also used in the message tangle.
* `DeltaValue` max difference in consecutive timestamps. Require `DeltaValue>w+D`.  This parameter is similar to `Delta` on the message tangle. 
* `epoch` is the length of time of each index.
* `correctionCheckTime` the time till the correction check
* `theta` confidence level of grade 3 finality for messages.  
* `T` time for grade 4 finality 
* `snapShotTimeValue` Age of a transaction when snapshotted. Require `snapSshotTimeValue>DeltaValue+w+2D` This parameter is similar to `snapShotTime` on the message tangle, alathough this parameter is global: it must be the same for all nodes.   


The following are lists.
* `valueTangle` The database of value objects.
* `transactionList` The database of all transactions. 
* `indexedTxList` is the database of indexed transactions: see Main Components Subsection 1 below.
*  `eligibleValueTipsList` The value objects eligible for the selection algorithm.  
* `pending` The value objects not initially eligible for tip selection.  
* `correctionQueue` An ordered list of transactions whose eligibility flag must be checked again.
* `snapShotFile` which is discussed in Components Subsection 8.
* `recentlyBookedQueue` an ordered list of value objects that were snapshotted.
* `transactionsBookedThisEpoch` lists the transactions that were booked in this epoch.
In implementations, many of these lists can exist simply as flags on objects in `valueTangle`.   

We use the following variable
* `currentTime` which gives the current time of the node.  


We define the following functions.
* `isSolid` Determines if a value object is solid or not
* `belowMaxDepthCheck` Determines if a value object satisfies the below max depth criterion. 
* `getValueTip` Function which employs the tip selection algorithm on the value tangle.
* `valueConfirmationConfidence` Measures the number of approvers on the value tangle.


## 4.1.2.2 How value objects and transactions are stored

Every value object and transaction can be identified by their `valueObjectID` and `transactionID` respectively.  Each value object contains the following information which is relevant to this specification:
* `parent1` and `parent2` These are value object IDmessage IDs of two other messages and endow the valumessage tangle with a DAG structure.  Together these fields shall be called *parents*.
* `transaction` this is the payload of each value object. 
* `timeStamp` which indicates the time the value object was created.  


Value objects will be stored with the following fields:
* `arrivalTime` The time that the value object was first parsed.  
* `eligible` is a Boolean value, denoting if the message was ever eligible for tip selection. 
* `container` is a list of the messages which have this value object as a payload.
* `solid` is a Boolean flag indicating if the parents are solidified or not.  
* `indexedTx` the indexed transaction associated to the value object.


We introduce an object called `indexedTx` or indexed transaction, which isn't rigorously defined in Main Components Subsection 2 below. These objects will be stored in the list `indexedTxList` along with the following fields:
* `indexedTxID` is the hash of `index+indexedTxID.transaction`.  This hash uniquely identifies each indexed transaction.
* `transaction`  is the hash of the transaction it contains
* `index`  is coarse measurement of time: see Main Components Subsection 1 below.
* `container` which lists the value objects containing the transaction with that index.  
* `opinionField` Contains the opinion on the timestamp of a message.  As specified [here](https://hackmd.io/xBfQ04NkRi6IrwhEQm7aJQ), this field is a triple `(opinion,level,timeFormed)` where `opinion` is a Boolean value, `level` is in the set {1,2,3}, and `timeFormed` is a time. This `opinionField` is also manipulated by FPC.
* `arrivalTime` is the time the indexed transaction was created. 
 

Transactions contain a field `inputs` which lists the UTXO inputs it consumes, and a field `outputs` which lists the outputs created.  Recall from [the UTXO specification](https://) that each input has a `transaction` field. Transactions will be stored in `transactionList` along with the fields:
* `container` which is a list of `indexedTxID`s of the indexed transactions containing that transaction
In Components Subsection 8, we reference other fields in the transaction layout, but we refer the reader to the specification linked above.



# 4.1.3 Main Components

As mentioned in the introduction, this section is divided into 9 subsections. To help orientate the reader, we briefly outline the actions performed on a value object.

After a message has been processed on the communication layer, it passes through the payload parser.  If the payload is a value object, the parser calls the `value object processor` which does the following actions.
1. Timestamp check 
2. Duplicate detector 
3. Conflict Check
4. Initial Eligibility Check

These actions are discussed in the first four sections.  



## 4.1.3.1 Timestamps

Every value object must have a timestamp in order to enable snapshotting, and these timestamps must be enforced through some consensus mechanism.  On the message tangle this is done through voting.  However, on this layer we do not want to vote on timestamps again.  Thus, we require that a value object must have the same timestamp as the message containing it.   

### Detailed design


When a value object is first parsed, we check if the timestamp of the value message is the same as its container, with the following check.
```
Input: valueObjectID, messageID

If valueObjectID.timeStamp not= messageID.timestamp
    Then Return INVALID
```
If this check is invalid, the value object ceases to be parsed and is deleted.


### Rationale

Since message timestamps are enforced through voting, the timestamps in the value tangle are also enforced. Since the timestamp is written in the value object, it is objective and agreed upon by all.

### Alternatives

Alternatively, value objects can inherit their timestamp from their containing message. However, since a value object can be reattached in multiple messages, the timestamp is not well defined. To rectify this, we may let timestamp of a value object be the oldest timestamp of a message containing it. This definition is still problematic because the value of the timestamp can change. Later we will perform a below max depth check, but changing a timestamp can change the results of this check.  

Another alternative is to have value objects inherit the timestamp of their parent, but then differentiate different value objects contained in messages with different timestamps.  This latter approach is similar in spirit to the indexing which we mention below.  







## 4.1.3.2 Indexed transactions and reattachments

Value objects can be reattached multiple times in the message tangle, assuming the message has the correct timestamp.  Similarly, a transaction can be reattached multiple times by any party since neither messages nor value objects are signed by the account holders of the spent funds.  Transactions which are reattached should, in general, not be considered distinct.  If reattached transactions were considered conflicts, then the FCoB rule (see Subsection 4) would cancel both out. 

However, this approach precludes snapshotting: when receiving a transaction, a node would need to check its entire history for duplicates. This is simply not practical.  As a solution, we divide the timeline into "indices" or epochs. Transactions issued in the same index will be identified together in an object called `indexedTx` or an indexed transaction.  FPC will vote on indexed transactions.

### Detailed Design

First, after a new value object has passed the timestamp check, the node searches the value tangle for duplicates.  If it is a duplicate, no further action is taken besides updating the container field.  If the value object is not a duplicate, it can be added to the value tangle. 

After a value object is added to the value tangle, we create the indexed transaction object.  The timeline is divided up into periods which we call *epochs* which are each of length `epoch` which are enumerated chronologically.  The *index* of a value object is simply the epoch of its timestamp. The indexed transaction is then simply the hash of transaction ID and the index.  The indexed transaction identifies all the reattachments of a transaction issued in the same epoch while differentiating those issued in different epochs.   


We summarise these actions in the following pseudocode which we dub the `duplicate detector`.  Let `valueObjectID` be the hash of the value object, and suppose its contained in the message with hash `messageID`.
```
If valueObjectID in valueTangle, then add messageID to valueObjectID.container
Else 
    Add valueObjectID to value Tangle  
    Set valueObjectID.containter={messageID}
    Set valueObjectID.eligible=FALSE
    If valueObjectID.transaction in transactionList, then add valueObjectID to valueObjectID.transaction.container
    Else
        Add valueObjectID.transaction to transacitonList
        Set valueObjectID.transaction.container={valueObjectID}
        Set valueObjectID.transaction.eligible=False
    Set index=floor(valueobjectID.timestamp/epoch)
    Set indexedTxID=hash(index valueObjectID.transaction)
    Set valueObjectID.indexedTx=indexedTxID
    If indexedTxID in indexedTxList, then add valueobjectID to indexedTxID.container
    Else
        Add indexedTxID to indexedTxList
        Set indexedTxID.transaction=valueObject.transaction
        Set indexedTxID.index=index
        Set indexedTxID.container={valueobjectID}
        Set indexedTxID.opinionField=NULL
        Set indexedTxID.arrivalTime=currentTime
```


### Rationale

The indices create a well defined equivalence relation on the transactions. Moreover, if someone reattaches a transaction after a long period time, e.g. after snapshotting, the transaction will have a different index and will be considered distinct.  

###  Drawback

If the epochs are large, then when a transaction is reattached, it will have the same epoch.  However, if the a transaction arrives around the changing of an epoch, an attacker can censor this transaction by reattaching the transaction in the next epoch.  This would really only affect the transactions issued in the last 5 seconds of each epoch, but still could represent a problem.  




## 4.1.3.3 Solidification

A value object is solid if the node has its past cone.  Solidification on the value tangle works fundamentally differently than on the message tangle.  On the communication layer, a node can send solidification requests and nodes only gossip upon solidification.  Since the communication layer operates independently of the value transfer application, we do not have these tools here.  Thus, nodes must simply wait for value objects to solidify, and this application lacks any particular solidification module.

As a consequence, we vote even on unsolidifed transactions.  Since we can only wait for transactions to be solidified (see next subsection), this would allow an attacker to solidify big batches of transactions at once and overload ths network by solidifying large structures simultaneously.  

One might think that by voting on unsolidified transactions, an attacker can increase the number of votes taking place.  This is false: the number of votes taking place is limited by how many conflicts an attacker can create which is bounded by the number of messages they can issue.  This limit is set by the rate control module, and not be any solidification mechanism. 








## 4.1.3.4 Conflict detection 

At the core of the protocol, we use FPC to choose between conflicts by voting on indexed transactions. How FPC interacts with the value tangle is specified [here](https://hackmd.io/xBfQ04NkRi6IrwhEQm7aJQ).  In this section we define conflicts and discuss how the opinion field is initially set.  



### Detailed design

The following is our definition of conflict. **Two indexed transactions conflict if they have the same index and their associated transactions have overlapping inputs**.  Under this definition, reattachments are never conflicts because either they have different indices or they define the same indexed transaction.  

After the a indexed transaction `indexedTxID` is created, a node should check for conflicts.
```
Intialize list conflicts={}
Forall x in indexedTxList
    If indexedTxID.index=x.index AND (indexedTxID.transaction.inputs INTERSECT x.transaction.inputs) is not empty
    Then Add x to conflicts
If conflicts is not empty, then add indexedTxID to conflicts
```

If the list of conflicts is not empty, then we have to vote on each object in this list.  Thus, we have the set the initial opinion of each object using what is called the *FCoB rule*: an object is disliked if a conflict is detected before `arrivalTime+c` where `c` is the FCoB parameter.  (FCoB stands for Fast Consensus of Barcelona, where we devised the rule.)  Since the decision time is based on the arrival time of messages, we can also set the level of knowledge flag based on the arrival time.  

Specifically, we perform the following algorithm on the list `conflicts`.
```
Forall x in conflicts
    If x.opinionField=Null
    Then
        Set x.opinionField.timeFormed=currentTime
        If currentTime<x.arrivalTime+c, then Set x.opinionField.opinion=FALSE
        If Abs(x.arrivalTime+c-currentTime)<D, then Set  x.opinionField.level=1
        Else 
            If Abs(x.arrivalTime+c-currentTime)<2D, then Set  x.opinionField.level=2
            Else Set x.opinionField.level=3
```

### Rationale

FPC is a binary voting protocol: it only votes yes or no on each indexed transaction.  Thus, we do not choose between conflicting transaction, but choose which value objects we approve. However, it is imperative that no pair of conflicting transactions approved by FPC, otherwise the ledger will become invalid. Recall that with the UTXO scheme, the ledger state will be valid if and only if no two transactions consume the same inputs.  

Suppose `tx1` and `tx2` are conflicting indexed transactions.  If roughly half the network has a positive initial opinion about `tx1` and the other half about `tx2`, then with a nonnegligible probability, FPC will output "good" on both indexed transactions, which is intolerable.  The FCoB rule prevents this situation.  Indeed, assuming `tx2` arrives to our node second, it will always be disliked by the most of the network.
1. Every node receives `tx1` before `tx2`.  In this case, under the FCoB rule, all nodes will initially dislike `tx2`
2. Not all nodes receive `tx1` before `tx2`.  Since our node received `tx1` before `tx2`, and since the network delay for most nodes is less than `c`, no node will receive `tx2`  time `c` before `tx1`, and thus all nodes will dislike `tx2` under the FCoB rule.

Since the FCoB rule is decided by the arrival times, we can use estimations of the network delay to determine the level of knowledge of our opinion in the same manner as timestamps on the message tangle: see [Components Subsection 1](https://hackmd.io/YfrUh4wqSua0Ou4-XHwYIA?both).  As with the message tangle we use `D`, the large estimate on the network delay, so nodes with longer message delays will not fall out of sync.  However, a smaller estimation of the network delay suffices to determine `c` because the arguments work in the previous paragraph if vast majority of nodes initially dislike  `tx2`.  Moreover, have `c=D` would cause intolerable confirmation times, as demonstrated by the tip selection algorithm below.



## 4.1.3.5 Tip Selection

The tip selection in algorithm on the value tangle works on the same principles as the message tangle.  We will perform RURTS on a restricted subset. This subset will be maintained by inductively maintaining a subtangle of good value objects marked with the `eligible` flag.  

### Detailed design

We define the following function which determines if a value object should be flagged as eligible.  
```
Function Name: isEligible
Input: valueObjectID
Output: Boolean value

If valueObjectID.indexedTx.opinionField.opinion=FALSE, then Return FAlSE
If valueObjectID.indexedTx.opinionField.level=1, then Return FAlSE

If valueObjectID.parent1 not in valueTangle, then Return FALSE
If { DeltaValue>valueObjectID.timestamp-valueObjectID.parent1.timeStamp >0} is FALSE
    Then Return FALSE
If valueObjectID.parent1.eligible=FALSE, then Return False

If valueObjectID.parent2 not in valueTangle, then Return FALSE
If { DeltaValue>valueObjectID.timestamp-valueObjectID.parent2.timeStamp >0} is FALSE
    Then Return FALSE
If valueObjectID.parent2.eligible=FALSE, then Return False


Forall input in valueobjectID.transaction.inputs
    If input not in transactionList AND input not in snapShotFile.outputs, then Return False
    If input not in snapShotFile.outputs and (Forall X in  input.container, X.eligible=False AND X.timeStamp>valueObjectID.timeStamp)=FALSE
    Then Return False

If (Forall messageID in valueObjectID.container, messageID.elegible=FALSE)=FALSE, then Return False 

Return True
```

For a value object with ID `valueObjectID`, at time `valueObjectID.arrivalTime+d`, a node performs the *first eligiblity check*, checking if the object is eligible.
```
If isEligible(valueObjectID)=True
Then
    valueObjectID.elible=True
    valueObjectId.transaction.eligible=True
    Add (valueobjectID,currentTime) to end of correctionQueue
    Add valueObjectID to eligibleValueTipsList
    Remove valueObjectID.parent1 from eligibleValueTipsList
    Remove valueObjectID.parent2 from eligibleValueTipsList
Else Add valueObjectID to pending
```

Periodically, the node must check the pending list for newly eligible value objects.
```
Forall valueobjectID in pending
If isEligible(valueObjectID)=True
    Then
        Remove valueObjectID from pending
        valueObjectID.elible=True
        valueObjectId.transaction.eligible=True
        Add valueObjectID to eligibleValueTipsList
        Remove valueObjectID.parent1 from eligibleValueTipsList
        Remove valueObjectID.parent2 from eligibleValueTipsList   
```



We can now define the following function.
```
Function: getValueTip
Inputs: none
Outputs: valueObjectID

While (currentTime-valueObjectID.timeStamp<Delta) is FALSE
    Randomly select valueObjectID from eligibleValueTipsList
EndWhile
Return valueObjectID
```

### Rationale

As with the message tangle, the node checks each value object if it is eligible.  If not, the node puts the object in the buffer until it becomes eligible. The only difference is that a node must perform the first check at `c+d` to allow for any conflicts to be detected.  Otherwise, the tip selection algorithm here behaves exactly the same as on the message tangle: see [Components Subsection 3](https://hackmd.io/YfrUh4wqSua0Ou4-XHwYIA?both).  

However, the check for eligibility is more complicated and is combined with the below max depth check.    In particular, we only flag an object as eligible if it satisfies the following.
* The object has opinion field either Null, good level 2, or good level 3.  This means that either no conflict was detected, or it was detected and the voting has been resolved.
* Each parent is eligible and satisfies the below max depth criterion.
* Each UTXO input is contained in some eligible value object whose timestamp is older than the value object in question.
* The value object is contained in a message that is eligible for tip selection on the message tangle.  

These criterion are carefully chosen so that we ensure the following three things happen.
1. Only a solidified subtangle of value transactions are permanently stored in the ledger which contains a valid UTXO graph.  
2. The value objects in the value tangle are also recorded in messages which will not be orphaned.
3. That we are able to do snapshotting. Indeed, the below max depth criterion between the timestamps of a value object and its parent allow for the same snapshotting capabilities that we have on the message tangle.  See  [Components Subsection 5](https://hackmd.io/YfrUh4wqSua0Ou4-XHwYIA?both).  Similarly, the timestamp requirement on the containers of the UTXO inputs allow us to determine conclusively when a transactions UTXO inputs will not become "solid": see Subsection BLANK below.





## 4.1.3.6 Correction check

The first check for eligibility happens when a value object is `c+d` old. However, since `c+d~2d~10 seconds`, if a node experiences a delay (such as a mild DDOS attack), a conflict might arrive after this check is performed, and the node may even arrive at the wrong initial opinion.  Since the levels of knowledge uses `large D`, the node will still come to the correct final opinion after running FPC.  But, the eligibility status must still be adjusted to matched this final opinion.  Moreover, other value objects may rely on one of these "delayed conflicts", complicating the process.

To summarise the following, we wait `correctionCheckTime` after the a value object was first flagged eligible.


### Detailed Design

Recall that `correctionQueue` is an ordered list of pairs `(valueObjectID,time)' representing the time each value object was flagged as eligible.  We want to recheck these value objects on a FIFO basis. Specifically, the following pseudo will continuously run in a loop.  
```
Forall (valueObjectID,time) in correctionQueue
	While time+D>currentTime
		Do nothing
	Endwhile
	If isEligible(valueObjectID)=FALSE, Set valueObjectID.eligible=FALSE
	Remove (valueObjectID,time) from correctionQueue
```

### Rationale


### Drawbacks

Suppose a node is slightly out of sync, for instance it is experience a mild DDoS attack.  Suppose further that the node falsely marks a value object `v` as eligible because the arrival of a conflict was delayed. The node may choose `v` in its tip selection process, and create a value object referencing it.  However, when `v` fails the correction check,   this new value object will be invalidated.  This may cause problems for the node is and is an attack vector.  Unfortunately, this is partly a consequence of FLP impossibility: if some message on the communication layer can be delayed indefinitely, then no node can every correctly finalise on the status of any transaction.  

### Alternatives

There are some intuitive ways to optimise this process.  First, the `isEligible` function checks way more than is necessary at this point.  Indeed, the timestamp checks and the message checks are completely unnecessary.  In fact, all that needs checked is
* The parents are still eligible
* Each UTXO input is contained in an eligible value object

Next, If a value object `v1` references value object `v2`, and `v2` fails the correction  check, then `v1` is also doomed to fail the correction check.  However, in the algorithm described above, `v1` must wait till it is processed by the correction checker before the eligibility flag is changed.  In the mean time `v1` and its approvers will still be available for tip selection.  To optimise this process, when the eligibility flag of `v2` is changed, the node can walk the tangle, changing all the eligibility flags everything in its future cone to `FALSE`. 

In a similar vein, the correction check could be triggered by events like conflict checks and opinion finalisations. These triggers could reduce the time that it takes for corrections to take place.  






## 4.1.3.7 Finality

Finality on the value tangle and the message tangle largely behaves the same, with only a few modification.  The primary difference is a new grade between 1 and 2 which includes the correction check.  


### Detailed Design

There are four grades of finality for a value objects.
* Grade 1: The value object  has the `eligible` flag set to `True`.
* Grade 1.5: The value object has the `eligible` flag set to `TRUE` and is not on the `correctionQueue`.
* Grade 2: The value object 
	* has Grade 1.5 finality
	* the confidence level is greater than `theta` for some parameter.
	* and is contained in a grade 2 final message
* Grade 3: The value object 
	* has Grade 2 finality 
	* the timestamp is older than `T`
	* and is contained in a grade 3 final message.  

To make these definitions precise, we define the following function:
```
Define: confirmationConfidenceValue
Inputs: messageID
Outputs: number between 0 and 1

Return Probability that getValueTip indirectly references messageID
```

### Rationale

The rationale here is largely the same as on the message tangle as discussed in [Components Subsection 4](https://hackmd.io/YfrUh4wqSua0Ou4-XHwYIA?both).  However, we introduce a finality grade in between grade 1 and grade 2 to account for the correction checks.  As discussed in the previous section, if a node is out of sync, it can select tips which later will be invalidated.  However, with finality grade 1.5, this cannot happen. 










## 4.1.3.8 Snapshotting

The value transfer application maintains two state machines: the ledger and the mana state.  The `snapShotFile` records the changes made to these machines so that value objects and their transactions can be deleted when they are no longer needed to validate incoming objects.  

### Detailed Design


The `snapShotFile` is divided into lists.  First, `snapShotFile.outputs' lists all the unspent outputs that have been snapshotted. Each output is stored with the following information:
* `address` The public key needed to validate the signature of a transaction consuming this output.  In other words, it is the address the funds are stored on.
* `balance` The amount of funds stored on this output.
* `pledgeType` A Boolean flag indicating which mana type the pledge is.  
* `nodeID`  The node ID receiving the mana.
* `timeStamp' which is the time the output was added to the file.  
The second list, `snapShotFile.manaState' stores the mana held by each node. We refer to [the mana specification](https://) for the layout of this file.  

When a node `Book`s a transaction with `transactionID`, it performs the following actions
* Add each output in `transactionID.outputs` to `snapShotFile.outputs' and set all the fields in the obvious manner: the information for the first four fields can be found in the [transaction layout specification](https://).
* Performs the required changes in `snapShotFile.manaState' as prescribed in  [the mana specification](https://).

With these preliminaries established, we can discuss the actual mechanics of snapshotting.  Consider a value object `valueObjectID`.  At time `valueObjectID.timeStamp+snapShotTimeValue', the following logic is performed.
```
If {   		 valueObjectID.parent1 in recentlyBookedQueue
	AND  valueObjectID.parent2 in recentlyBookedQueue
	AND {Forall input in valueObjectID.transaction.outputs, output in snapShotFile.outputs}
	AND valueObjectID.eligible=TRUE
	AND confirmationConfidenceValue(valueObjectID)>theta
	}
Then 
	If valueObjectID.transaction in transactionsBookedThisEpoch,
	Then	
		 Book valueObjectID.transaction
		 Add valueObjectID.transaction to transactionsBookedThisEpoch
	Append (valueObjectID,currentTime) to recentlyBookedQueue
Endif
Forall input in valueObjectID.transaction.inputs
	Remove input from snapShotFile.outputs
Endforall
Remove  valueObjectID from valueObjectID.transaction.container 
If valueObjectID.transaction.container=empty, then remove valueObjectID.transaction from transactionList
Remove valueObjectID from valueObjectID.indexedTx.container  
If valueObjectID.indexedTX.container=empty, then remove valueObjectID.indexedTX from indexedTxList
Remove valueObjectID from pending
Remove valueObjectID from valueTangle
Remove valueObjectID from eligibleValueTipsList
```
At this point the value object has been snapshotted, and, as fas as the value transfer application is concerned, it maybe deleted from memory.  Similarly, if the container of either a transaction or indexed transaction becomes empty, it may be deleted.  

The `recentlyBookedQueue` must be regularly scrubbed, with the following perpetual loop.
```
Forall (valueObjectID,time) in recentlyBookedQueue
 	While time+w+2D>currentTime
		Do nothing
	Endwhile
	Remove (valueObjectID,time) from correctionQueue
 ```
 
 Lastly, `transactionsBookedThisEpoch` must be emptied after the node has snapshotted all value objects with index i for each value of i.  
 
 ### Rationale

Most of the information saved in  `snapShotFile` is actually only necessary for the [mana calculations](https://), and so we do not justify them here.  When snapshotting happens, we book the value object, i.e. record its changes on the state machine if and only if it is grade 3 final with `T=snapShotTime`.  However,  for each indexed transaction, we only apply the changes at most once per a single indexed transaction.  

After we determine if the changes should be booked and do the possible booking, we are free to remove value object from the value tangle.  If the value object was not booked, then it is simply forgotten. 

We recall some of the discussion about finality from the message tangle: see [Components Subsection 4](https://hackmd.io/YfrUh4wqSua0Ou4-XHwYIA?both).  In theory, the snapshotting algorithm works because at `snapShotTime` every value object will either be definitely  orphaned and has a near zero confirmation confidence, or it will not be orphaned and has a very high confirmation confidence.  Thus our snapshotting algorithm should not consider many edge cases with confirmation confidence around say .5.  This ensures that all nodes will agree on whether each value object will be orphaned or not.  

###  Alternatives

Nodes do not need to delete value objects after snapshotting.  They may archive them in memory or do whatever they wish with the information.  


## 4.1.3.9 Remaining Problems
Problem: reattachments in higher epochs will not appear as unsolidified until the thing in the previous epoch has been snapshotted.

This makes a real attack vector: someone issues a transaction in Epoch i.  Then someone reattaches it in epoch i-1.  The transaction is in epoch i-1 is consumed first, which is fine.  But this makes the original one invalid: and so a whole future cone will be orphaned.  

Similarly, if these value objects are issued very close to eachother, different people will think think different ones arrived first: a problem.  

Snapshotting will resolve these differences, but the damage will be done.   









<!--stackedit_data:
eyJkaXNjdXNzaW9ucyI6eyJiOENCTzJrcTNzVHNTZVZuIjp7In
RleHQiOiJtb3N0Iiwic3RhcnQiOjEyMzEsImVuZCI6MTIzMX0s
InhHZXFQazB5T1NWcElGelQiOnsidGV4dCI6IldlIGFzc3VtZS
BhbGwgbWVzc2FnZXMgYXJlIGRlbGl2ZXJlZCB3aXRoaW4gdGhp
cyB0aW1lLiIsInN0YXJ0IjoxMzIxLCJlbmQiOjEzODh9LCJDUz
RnWFpWd1ZvTGo1Nnk3Ijp7InRleHQiOiJlYWNoIGluZGV4LiIs
InN0YXJ0IjoxNzE1LCJlbmQiOjE3MjZ9LCJPMjI0b3IyU0RFTz
lSTExoIjp7InRleHQiOiJ0aGUgdGltZSB0aWxsIHRoZSBjb3Jy
ZWN0aW9uIGNoZWNrIiwic3RhcnQiOjE3NTEsImVuZCI6MTc4NX
0sIjlab2pvMWJFZ3ltcUh0OEoiOnsidGV4dCI6InRoZXRhYCIs
InN0YXJ0IjoxNzg5LCJlbmQiOjE3OTV9LCJ5VmJ1TDZhaUQ4MU
RQQVRpIjp7InRleHQiOiJzbmFwU2hvdCIsInN0YXJ0IjoxODg1
LCJlbmQiOjE4OTN9LCJvR0tMVWU3NUt0SGdEbVZkIjp7InRleH
QiOiJBZ2Ugb2YgYSB0cmFuc2FjdGlvbiIsInN0YXJ0IjoxOTA0
LCJlbmQiOjE5MjR9LCJ4NkQ3OG1wSTNmSGl1a0M2Ijp7InRleH
QiOiJhbHRob3VnaCB0aGlzIHBhcmFtZXRlciBpcyBnbG9iYWw6
IGl0IG11c3QgYmUgdGhlIHNhbWUgZm9yIGFsbCBub2Rlcy4iLC
JzdGFydCI6MjA1NSwiZW5kIjoyMTI1fSwickVXYjE5VnJjVk1C
V3lnZiI6eyJ0ZXh0IjoiVHgiLCJzdGFydCI6MjI2OCwiZW5kIj
oyMjcwfSwiY0oxTnppS3lzUnFHVFZ0aSI6eyJ0ZXh0IjoicGFy
ZW50MWAgYW5kIGBwYXJlbnQyIiwic3RhcnQiOjM2NjYsImVuZC
I6MzY4N30sIkpZSHJrTU15VlBqbFQ5amIiOnsidGV4dCI6InZh
bHVlIG9iamVjdHMiLCJzdGFydCI6MjE4OCwiZW5kIjoyMjAxfS
wiNDhGejI0M2lodmx2Ym53dyI6eyJ0ZXh0Ijoid2FzIGZpcnN0
IHBhcnNlZCIsInN0YXJ0Ijo0MDg4LCJlbmQiOjQxMDR9LCJkNm
RvNXp3dzl5dGlXNnN2Ijp7InRleHQiOiJoZSBpbmRleGVkIHRy
YW5zYWN0aW9uIGFzc29jaWF0ZWQgdG8gdGhlIHZhbHVlIG9iam
VjdC4iLCJzdGFydCI6NDM4MCwiZW5kIjo0NDM0fSwiaGRKS21X
dWJFczkzM0hKSCI6eyJ0ZXh0IjoiaW5kZXgraW5kZXhlZFR4SU
QudHJhbnNhY3Rpb24iLCJzdGFydCI6NDY5NSwiZW5kIjo0NzI0
fSwiNWlpWlUyeUV6ajRUcU5JVSI6eyJ0ZXh0IjoidHJhbnNhY3
Rpb25gICBpcyB0aGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24g
aXQgY29udGFpbnMiLCJzdGFydCI6NDc4NywiZW5kIjo0ODQzfS
wiajZRVFJhRlYyQ3JtY2kwSSI6eyJ0ZXh0IjoiVGltZXN0YW1w
cyIsInN0YXJ0Ijo2NTMwLCJlbmQiOjY1NDB9LCJkbGkwQ251NF
V6cEVQdnhiIjp7InRleHQiOiJpdCBpcyBvYmplY3QgYW5kIiwi
c3RhcnQiOjc0NDQsImVuZCI6NzQ2M30sIkdCVVFTV2ZoZ1JlVm
gzSGYiOnsidGV4dCI6IndvdWxkIiwic3RhcnQiOjg3ODUsImVu
ZCI6ODc5MH0sIjdGMzR4clMzMkJ4TGZxOHQiOnsidGV4dCI6Im
1lc3NhZ2UgdGFuZ2xlIHNwZWNpZmljYXRpb25dKGh0dHBzOi8v
aHR0cHM6Ly9oYWNrbWQuaW8vWWZyVWg0d3FTdWEwT3U0LVhId1
lJQT/igKYiLCJzdGFydCI6MzUzLCJlbmQiOjQzNn0sIjlhaEJp
Wm9GSm83eVlvaXAiOnsidGV4dCI6InNwZWNpZmljYXRpb24iLC
JzdGFydCI6Njk3LCJlbmQiOjcxMH0sIml2Y0h4WTJvbkd2NkFm
aEsiOnsidGV4dCI6InNwZWNpZmljYXRpb24iLCJzdGFydCI6OD
YyLCJlbmQiOjg3NX0sImhJNU92SEgydng2bWhadkgiOnsidGV4
dCI6InNtYWxsIiwic3RhcnQiOjg1NiwiZW5kIjo4NjF9LCJ1N1
cyVlk2Rmh3bUdhUW9EIjp7InRleHQiOiJUaGlzIHBhcmFtZXRl
ciBpcyBzaW1pbGFyIHRvIGBEZWx0YWAgb24gdGhlIG1lc3NhZ2
UgdGFuZ2xlIiwic3RhcnQiOjE2MTksImVuZCI6MTY3N30sIm9o
NTVicURjWEhXc2E2VHUiOnsidGV4dCI6ImBUYCIsInN0YXJ0Ij
oxODUxLCJlbmQiOjE4NTR9LCJHS1FCTUpYWFFQVEpMNkZwIjp7
InRleHQiOiJkZWxldGVkLiIsInN0YXJ0Ijo3MjU4LCJlbmQiOj
cyNjZ9LCJvaHQ3dVBBZlZxRFlpUk9LIjp7InRleHQiOiJ0aGUi
LCJzdGFydCI6NzY2MSwiZW5kIjo3NjY0fSwiMXhoTjJHQVM3b3
dvRXBaeCI6eyJ0ZXh0IjoibGV0Iiwic3RhcnQiOjc3MjAsImVu
ZCI6NzcyM30sIjRZTWVGRm1oRlB3R0xHUWgiOnsidGV4dCI6Im
JlbG93IG1heCBkZXB0aCIsInN0YXJ0Ijo3OTEyLCJlbmQiOjc5
Mjd9LCJhck9YMGpPSUsweFpySGpxIjp7InRleHQiOiJBbm90aG
VyIiwic3RhcnQiOjgwMDEsImVuZCI6ODAwOH0sImNpSExBUVc2
R2NmOWN3YTQiOnsidGV4dCI6InJhdGUgY29udHJvbCBtb2R1bG
UiLCJzdGFydCI6MTMxMjAsImVuZCI6MTMxMzl9LCIzQmFEdXNW
YjR4Q1FOdVlpIjp7InRleHQiOiJ1bnNvbGlkaWZlZCIsInN0YX
J0IjoxMjU1MCwiZW5kIjoxMjU2MX0sIllYQ1NhZmU0NnNVY2g5
Q2kiOnsidGV4dCI6IltoZXJlXShodHRwczovL2hhY2ttZC5pby
94QmZRMDROa1JpNklyd2hFUW03YUpRKSIsInN0YXJ0IjoxMzM3
OSwiZW5kIjoxMzQyN30sIlhGRnB3RzlweWRCN2c1ZlYiOnsidG
V4dCI6InNlY3Rpb24iLCJzdGFydCI6MTM0MzgsImVuZCI6MTM0
NDV9LCJqWDZmbDZONTRzS2x1Q2RxIjp7InRleHQiOiJTb2xpZG
lmaWNhdGlvbiBvbiB0aGUgdmFsdWUgdGFuZ2xlIHdvcmtzIGZ1
bmRhbWVudGFsbHkgZGlmZmVyZW50bHkgdGhhbiBvbiB0aGXigK
YiLCJzdGFydCI6MTIwNjAsImVuZCI6MTIxNTN9LCI0TTBBYmRi
SXN5MlhKN0VwIjp7InRleHQiOiJpbiIsInN0YXJ0IjoxNzI1Ny
wiZW5kIjoxNzI1OX0sIkgyU3NhNHlNQTBLTmM2dWUiOnsidGV4
dCI6ImFzIHRoZSIsInN0YXJ0IjoxNzMxOSwiZW5kIjoxNzMyNX
0sIm1UNDBGVFlyMWprdVVCTXUiOnsidGV4dCI6Ii4iLCJzdGFy
dCI6MjA2NzUsImVuZCI6MjA2NzZ9LCJCUGNoNExKcjgzUkVJV1
VwIjp7InRleHQiOiJnb29kIGxldmVsIDIiLCJzdGFydCI6MjA3
MjEsImVuZCI6MjA3MzN9LCJJSVdqREUwTE9qVDZlOXY4Ijp7In
RleHQiOiJjcml0ZXJpb24iLCJzdGFydCI6MjA5MTUsImVuZCI6
MjA5MjR9LCJ1SW1GVmtBbmJQdWhIMGtVIjp7InRleHQiOiIuIi
wic3RhcnQiOjIxMjQxLCJlbmQiOjIxMjQyfSwidGhwY0RYZklF
OE9lV2lReiI6eyJ0ZXh0IjoiQkxBTksiLCJzdGFydCI6MjE5ND
YsImVuZCI6MjE5NTF9LCJoWm9hTXViUnp3Q2tUdFdGIjp7InRl
eHQiOiJgbGFyZ2UgRGAiLCJzdGFydCI6MjIzMTMsImVuZCI6Mj
IzMjJ9LCJBQXk0aUpDelZaUklUUHA3Ijp7InRleHQiOiJgQm9v
a2BzIiwic3RhcnQiOjI3NjI4LCJlbmQiOjI3NjM1fSwiZktVdl
VVdlF5Y2FTT2t3dSI6eyJ0ZXh0IjoiZmFzIiwic3RhcnQiOjI5
NDA4LCJlbmQiOjI5NDExfSwicXNFUDJRZWFpTmdnQ3hjSyI6ey
J0ZXh0IjoicGVycGV0dWFsIGxvb3AiLCJzdGFydCI6Mjk2NzYs
ImVuZCI6Mjk2OTB9LCJsckRYVlZDZVNKY1lNVzFJIjp7InRleH
QiOiJpIiwic3RhcnQiOjI5OTcyLCJlbmQiOjI5OTczfSwiNVZp
Q01OUWV6V2huREcwdSI6eyJzdGFydCI6MzE2NDMsImVuZCI6Mz
E2NDgsInRleHQiOiJFcG9jaCJ9fSwiY29tbWVudHMiOnsibWls
VDlnU09RMTBnZE9RVyI6eyJkaXNjdXNzaW9uSWQiOiJiOENCTz
JrcTNzVHNTZVZuIiwic3ViIjoiZ2g6NTExMTI2MTgiLCJ0ZXh0
Ijoid2hhdCBkb2VzIHRoaXMgbWVhbj8iLCJjcmVhdGVkIjoxNT
k1ODc0NTg5MjE4fSwiM0E1czAxczdIdm9hQ1JjdiI6eyJkaXNj
dXNzaW9uSWQiOiJ4R2VxUGsweU9TVnBJRnpUIiwic3ViIjoiZ2
g6NTExMTI2MTgiLCJ0ZXh0IjoiV2hhdCBpcyB0aGUgZGlmZmVy
ZW5jZSB0byBkLCBub3cgZm9yIGFsbCBub2Rlcz8iLCJjcmVhdG
VkIjoxNTk1ODc0NjI4MzI2fSwiU0VDT21nSXE3N0ZONTZEZyI6
eyJkaXNjdXNzaW9uSWQiOiJDUzRnWFpWd1ZvTGo1Nnk3Iiwic3
ViIjoiZ2g6NTExMTI2MTgiLCJ0ZXh0Ijoid2hhdCBpbmRleD8g
RG9uIHQgdW5kZXJzdGFuZCIsImNyZWF0ZWQiOjE1OTU4NzQ2Nz
c2MjB9LCJ1RjNxWTlwV0Z1VHZCNXNKIjp7ImRpc2N1c3Npb25J
ZCI6Ik8yMjRvcjJTREVPOVJMTGgiLCJzdWIiOiJnaDo1MTExMj
YxOCIsInRleHQiOiI/IiwiY3JlYXRlZCI6MTU5NTg3NDY5NjMz
N30sImhicWJ2OFFWaUJ3bU1kOWIiOnsiZGlzY3Vzc2lvbklkIj
oiOVpvam8xYkVneW1xSHQ4SiIsInN1YiI6ImdoOjUxMTEyNjE4
IiwidGV4dCI6InNhbWUgYXMgaW4gbWVzc2FnZSB0YW5nbGU/Ii
wiY3JlYXRlZCI6MTU5NTg3NDcyNzQyOH0sIkthNWVSVHNFODBq
dXV3QU4iOnsiZGlzY3Vzc2lvbklkIjoieVZidUw2YWlEODFEUE
FUaSIsInN1YiI6ImdoOjUxMTEyNjE4IiwidGV4dCI6ImluIFZU
UCBpdCBpcyBcInNuYXBzaG90XCIiLCJjcmVhdGVkIjoxNTk1OD
c0ODUwMTczfSwicjc4ZVE4QW1VYVkzNUhSNSI6eyJkaXNjdXNz
aW9uSWQiOiJvR0tMVWU3NUt0SGdEbVZkIiwic3ViIjoiZ2g6NT
ExMTI2MTgiLCJ0ZXh0Ijoid2hhdCBpcyB0aGUgYWdlIG9mIGEg
dHJhbnNhY3Rpb24/IiwiY3JlYXRlZCI6MTU5NTg3NDg3OTIyNH
0sIjg5ZWs0aEhUcWFIbFBYc1QiOnsiZGlzY3Vzc2lvbklkIjoi
eDZENzhtcEkzZkhpdWtDNiIsInN1YiI6ImdoOjUxMTEyNjE4Ii
widGV4dCI6IldoeSBpcyB0aGlzPyBJZiBvbmUgbm9kZSBjaGFu
Z2VzIHRoaXMgdmFsdWUsIHByb3RvY29sIGJyZWFrcz8iLCJjcm
VhdGVkIjoxNTk1ODc0OTY1NTgyfSwiUWVYSzhpSXBCNkNJRmVD
NCI6eyJkaXNjdXNzaW9uSWQiOiJyRVdiMTlWcmNWTUJXeWdmIi
wic3ViIjoiZ2g6NTExMTI2MTgiLCJ0ZXh0IjoiV2h5IG5vdCBU
eCAtPiBUcmFuc2FjdGlvbj8iLCJjcmVhdGVkIjoxNTk1ODc1MT
I3OTU4fSwiWXJLek8xZGJpSzNIRGF4VyI6eyJkaXNjdXNzaW9u
SWQiOiJjSjFOemlLeXNScUdUVnRpIiwic3ViIjoiZ2g6NTExMT
I2MTgiLCJ0ZXh0IjoidmFsdWVQYXJlbnRzID8gdG8gZGlzdGlu
Z3Vpc2ggYmV0d2VlbiB0aGUgbWVzc2FnZVBhcmVudHM/IiwiY3
JlYXRlZCI6MTU5NTkxMzgxNDEzMH0sIkRoNlVUUGpnN1dsRXFP
NUEiOnsiZGlzY3Vzc2lvbklkIjoiSllIcmtNTXlWUGpsVDlqYi
IsInN1YiI6ImdoOjUxMTEyNjE4IiwidGV4dCI6IndoYXQgaXMg
YSB2YWx1ZSBvYmplY3Q/IEEgTWVzc2FnZSB3aXRoIGEgdHJhbn
NhY3Rpb24gcGF5bG9hZD8iLCJjcmVhdGVkIjoxNTk1OTEzOTM3
MDc0fSwiMUZQSG5nUEpJQzhnZ0hRSyI6eyJkaXNjdXNzaW9uSW
QiOiI0OEZ6MjQzaWh2bHZibnd3Iiwic3ViIjoiZ2g6NTExMTI2
MTgiLCJ0ZXh0Ijoid2hhdCBkb2VzIHBhcnNlZCBtZWFuIGluIH
RoZSAncHJvY2Vzc2luZ1wiIG9mIGEgbWVzc2FnZT8iLCJjcmVh
dGVkIjoxNTk1OTE0MTk3OTM2fSwiQnMweXZTTjZ4cUtsZlhuYy
I6eyJkaXNjdXNzaW9uSWQiOiJkNmRvNXp3dzl5dGlXNnN2Iiwi
c3ViIjoiZ2g6NTExMTI2MTgiLCJ0ZXh0IjoiPyIsImNyZWF0ZW
QiOjE1OTU5MTQyOTA3NjZ9LCI2cEVtWjRJeXZyeGNlRUQ5Ijp7
ImRpc2N1c3Npb25JZCI6ImhkSkttV3ViRXM5MzNISkgiLCJzdW
IiOiJnaDo1MTExMjYxOCIsInRleHQiOiI/IiwiY3JlYXRlZCI6
MTU5NTkxNDM2MTM5N30sIkJsb0RlY1NXT2lYbE1LaXoiOnsiZG
lzY3Vzc2lvbklkIjoiNWlpWlUyeUV6ajRUcU5JVSIsInN1YiI6
ImdoOjUxMTEyNjE4IiwidGV4dCI6InRyYW5zYWN0aW9uSUQgPy
IsImNyZWF0ZWQiOjE1OTU5MTQ0NDM2MzJ9LCIwSWJqd0VCME5W
ZGdIdWVFIjp7ImRpc2N1c3Npb25JZCI6Imo2UVRSYUZWMkNybW
NpMEkiLCJzdWIiOiJnaDo1MTExMjYxOCIsInRleHQiOiJJIHRo
aW5rIHRoYXQgd2Ugc2hvdWxkIGRlbWFuZCB0aGF0IHRpbWVzdG
FtcHMgaW4gdGhlIHZhbHVlIHRhbmdsZSBhcmUgaW5jcmVhc2lu
ZzsgcGFyZW50LnRpbWVzdGFtcCA8IHRpbWVzdGFtcC4gSWYgbm
90IHdlIG1heSBoYXZlIG5lZ2F0aXZlIG1hbmEgdmFsdWVzLi4u
IiwiY3JlYXRlZCI6MTU5NTkxNDczMzkyNX0sIjhQeFlDaEl2cU
9EZnFvZksiOnsiZGlzY3Vzc2lvbklkIjoiajZRVFJhRlYyQ3Jt
Y2kwSSIsInN1YiI6ImdoOjUxMTEyNjE4IiwidGV4dCI6IkFoIG
9rOyBJIGRpZCBmaW5kIGl0IGluIEJlbG93TWF4RGVwdGhDaGVj
ayBmb3IgbWVzc2FnZXMgd2hpY2ggaW5kdWNlcyBtb25vdG9uaW
N0eSBmb3IgdmFsdWUgdGFuZ2xlIGFzIHdlbGwuIFN0aWxsIGkg
dGhpbmsgdGhpcyBtb25vdG9uaWN0eSBwcm9wZXJ0eSBpcyB2ZX
J5IG5hdHVyYWwgYW5kIHNob3VsZCBiZSBtZW50aW9uZWQiLCJj
cmVhdGVkIjoxNTk1OTE1MzkwNjQzfSwiRndQY0hyNDZRNnF1Qn
BxRiI6eyJkaXNjdXNzaW9uSWQiOiJkbGkwQ251NFV6cEVQdnhi
Iiwic3ViIjoiZ2g6NTExMTI2MTgiLCJ0ZXh0Ijoib2JqZWN0aX
ZlPyIsImNyZWF0ZWQiOjE1OTU5MTU0NDYyMzR9LCJvckRWbGx4
UlZzeVVpMUhtIjp7ImRpc2N1c3Npb25JZCI6InJFV2IxOVZyY1
ZNQld5Z2YiLCJzdWIiOiJnaDo1MDY2MTg0NCIsInRleHQiOiJJ
dHMgdG9vIGxvbmcgdG8gd3JpdGUgb3ZlciBhbmQgb3ZlciIsIm
NyZWF0ZWQiOjE1OTU5MjcwMDU1NDB9LCJRWHNRVlRGRVpBVGV3
dUNEIjp7ImRpc2N1c3Npb25JZCI6ImNKMU56aUt5c1JxR1RWdG
kiLCJzdWIiOiJnaDo1MDY2MTg0NCIsInRleHQiOiJQYXJlbnQg
aXMgYSByZWxhdGl2ZSB0ZXJtLiAgVGhlIHBhcmVudHMgb2YgYS
B2YWx1ZSBvYmplY3QgYXJlIGFnYWluIHZhbHVlIG9iamVjdHMu
IiwiY3JlYXRlZCI6MTU5NTkyNzA5OTU4OX0sIjFQcUo1M1NZYk
h6Q21GQXoiOnsiZGlzY3Vzc2lvbklkIjoiR0JVUVNXZmhnUmVW
aDNIZiIsInN1YiI6ImdoOjUxMTEyNjE4IiwidGV4dCI6Im1heS
Aob25seSBpZiB0aGV5IGFyZSBpc3N1ZWQgYXQgYWJvdXQgdGhl
IHNhbWUgdGltZSkiLCJjcmVhdGVkIjoxNTk2MDEyMDk3ODQyfS
wiWkhRV3Y3V1hQMG01cXFwWSI6eyJkaXNjdXNzaW9uSWQiOiJ4
R2VxUGsweU9TVnBJRnpUIiwic3ViIjoiZ2g6NTExMTI2MTgiLC
J0ZXh0IjoiV2UgaGF2ZSB0byByZW1hcmsgd2hhdCBoYXBwZW5z
IGlmIHRoaXMgc3Ryb25nIGFzc3VtcHRpb24gaXMgbm90IHNhdG
lzZmllZCEgUmUtc3luYyBvciBkZWF0aD8iLCJjcmVhdGVkIjox
NTk2MDE2Njk2NjM1fSwiUzBwVG9QT0Q4M0JRVlRGOSI6eyJkaX
NjdXNzaW9uSWQiOiI3RjM0eHJTMzJCeExmcTh0Iiwic3ViIjoi
Z2g6NjgyNTAzNTAiLCJ0ZXh0IjoiQ2hhbmdlIHRvIFwiU2VjdG
lvbiAzLjJcIi4iLCJjcmVhdGVkIjoxNTk2MDQ5NTAzODI2fSwi
aXU0aTFaS2wwTHpsWXM3NCI6eyJkaXNjdXNzaW9uSWQiOiI5YW
hCaVpvRkpvN3lZb2lwIiwic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0
ZXh0IjoiXCJzZWN0aW9uXCIgc291bmRzIGJldHRlciIsImNyZW
F0ZWQiOjE1OTYwNDk1ODc2NDl9LCI4bDBSSEZ5dVVnRkNreFdp
Ijp7ImRpc2N1c3Npb25JZCI6Iml2Y0h4WTJvbkd2NkFmaEsiLC
JzdWIiOiJnaDo2ODI1MDM1MCIsInRleHQiOiJzdWJzZWN0aW9u
PyIsImNyZWF0ZWQiOjE1OTYwNDk2MjY2MTF9LCJlUTkwSnZxYV
FGZHBLeUxDIjp7ImRpc2N1c3Npb25JZCI6ImhJNU92SEgydng2
bWhadkgiLCJzdWIiOiJnaDo2ODI1MDM1MCIsInRleHQiOiJzaG
9ydD8iLCJjcmVhdGVkIjoxNTk2MDQ5NjM3NTU1fSwiQzNBTzdK
MGQ0QWNBVURVZCI6eyJkaXNjdXNzaW9uSWQiOiJ1N1cyVlk2Rm
h3bUdhUW9EIiwic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZXh0Ijoi
Tm90IHRoZSBzYW1lIHdoeT8gSWYgZGlmZmVyZW50IGFkZCB0by
BpbmRleCBvZiBwYXJhbWV0ZXJzIiwiY3JlYXRlZCI6MTU5NjA2
MDQyNzM2OX0sIndPZ2x3TEJJeUVyZG51MUEiOnsiZGlzY3Vzc2
lvbklkIjoib2g1NWJxRGNYSFdzYTZUdSIsInN1YiI6ImdoOjY4
MjUwMzUwIiwidGV4dCI6Indhc24ndCBpdCBzdXBwb3NlZCB0by
BiZSBCTUQgdGltZT8iLCJjcmVhdGVkIjoxNTk2MDYwNDY0NDA5
fSwiU0tuakJIajE1M3FYRHA0NyI6eyJkaXNjdXNzaW9uSWQiOi
JkbGkwQ251NFV6cEVQdnhiIiwic3ViIjoiZ2g6NjgyNTAzNTAi
LCJ0ZXh0IjoiSSB3b3VsZCBhbHNvIGNoYW5nZSB0aGUgd29yZG
luZyAoSSBjb3JyZWN0ZWQgdGhlIHR5cG8pOiBcIm9iamVjdGl2
ZSwgaGVuY2UgYWdyZWVkIHVwb24gYnkgYWxsLlwiIiwiY3JlYX
RlZCI6MTU5NjA2MTEzNTQyM30sImpQQ0Z1dzZnSkQwQktnb2Ui
OnsiZGlzY3Vzc2lvbklkIjoiR0tRQk1KWFhRUFRKTDZGcCIsIn
N1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6ImRlbGV0ZWQgZnJv
bS4uLiIsImNyZWF0ZWQiOjE1OTYwNjExNjM4NzF9LCJNeVhhQm
M2S1k1UkRLUXB5Ijp7ImRpc2N1c3Npb25JZCI6Im9odDd1UEFm
VnFEWWlST0siLCJzdWIiOiJnaDo2ODI1MDM1MCIsInRleHQiOi
J0aGVpciIsImNyZWF0ZWQiOjE1OTYwNjExOTU2NTR9LCJUR3FF
MFNTczBiVWx3dEUzIjp7ImRpc2N1c3Npb25JZCI6IjF4aE4yR0
FTN293b0VwWngiLCJzdWIiOiJnaDo2ODI1MDM1MCIsInRleHQi
OiJsZXQgdGhlIiwiY3JlYXRlZCI6MTU5NjA2MTIxMTM3MH0sIk
1GOURoR0JJVXRMNWlzQ2siOnsiZGlzY3Vzc2lvbklkIjoiNFlN
ZUZGbWhGUHdHTEdRaCIsInN1YiI6ImdoOjY4MjUwMzUwIiwidG
V4dCI6IlwiQmVsb3cgTWF4IERlcHRoXCIgc2luY2UgaXRzIHRl
cm0/IiwiY3JlYXRlZCI6MTU5NjA2MTI1MDc4N30sIm8yUEJ0Qm
NXdkVzQW0wc0EiOnsiZGlzY3Vzc2lvbklkIjoiYXJPWDBqT0lL
MHhackhqcSIsInN1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6Ik
FuIiwiY3JlYXRlZCI6MTU5NjA2MTMwNjQ1Nn0sImFrSFBxWHlK
a0JFRUZFeTYiOnsiZGlzY3Vzc2lvbklkIjoiY2lITEFRVzZHY2
Y5Y3dhNCIsInN1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6Ilwi
U2VlIHNlY3Rpb25zLi4uXCIiLCJjcmVhdGVkIjoxNTk2MDYxNT
U5MDg0fSwiaVBSbGlwWHlqa0FhVk1UTSI6eyJkaXNjdXNzaW9u
SWQiOiIzQmFEdXNWYjR4Q1FOdVlpIiwic3ViIjoiZ2g6NjgyNT
AzNTAiLCJ0ZXh0IjoidW5zb2xpZGlmaWVkIHZzIHVuc29saWQ/
IiwiY3JlYXRlZCI6MTU5NjA2MTU5MTY4N30sInE3ZFpHWlQ1cD
RJR0lURXUiOnsiZGlzY3Vzc2lvbklkIjoiWVhDU2FmZTQ2c1Vj
aDlDaSIsInN1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6ImNoYW
5nZSB0byBcIlNlY3Rpb24uLlwiIiwiY3JlYXRlZCI6MTU5NjA2
MTg1OTA5MX0sImJGeUMwYXEzUm1aRlVUMUoiOnsiZGlzY3Vzc2
lvbklkIjoiWEZGcHdHOXB5ZEI3ZzVmViIsInN1YiI6ImdoOjY4
MjUwMzUwIiwidGV4dCI6InN1YnNlY3Rpb24iLCJjcmVhdGVkIj
oxNTk2MDYxODcwODEzfSwiOVJIZEh5NmdOakFSbXVpNiI6eyJk
aXNjdXNzaW9uSWQiOiJqWDZmbDZONTRzS2x1Q2RxIiwic3ViIj
oiZ2g6NTExMTI2MTgiLCJ0ZXh0IjoiSSBkb24gdCB1bmRlcnN0
YW5kLiBJc250IHZhbHVlIHRhbmdsZSBhIHN1YnNldCBhbmQgaG
VuY2UgbWVzc2FnZSBzb2xpZGlmaWNhdGlvbiBkb2VzIHRoZSBq
b2IgYW55d2F5PyIsImNyZWF0ZWQiOjE1OTYxMTg5NzA0NjJ9LC
JwUGhrYlN2b1FWVVBrWnNMIjp7ImRpc2N1c3Npb25JZCI6IjRN
MEFiZGJJc3kyWEo3RXAiLCJzdWIiOiJnaDo2ODI1MDM1MCIsIn
RleHQiOiJ0eXBvPyIsImNyZWF0ZWQiOjE1OTYxMzU3MTgxNDB9
LCI4dGlhbm9MNEE5akpCQjhBIjp7ImRpc2N1c3Npb25JZCI6Ik
gyU3NhNHlNQTBLTmM2dWUiLCJzdWIiOiJnaDo2ODI1MDM1MCIs
InRleHQiOiJhcyBpbiB0aGU/IiwiY3JlYXRlZCI6MTU5NjEzNT
czMzM2MH0sIlZyRkloVHcxa0d1NGZ5ZmwiOnsiZGlzY3Vzc2lv
bklkIjoibVQ0MEZUWXIxamt1VUJNdSIsInN1YiI6ImdoOjY4Mj
UwMzUwIiwidGV4dCI6IjoiLCJjcmVhdGVkIjoxNTk2MTM2MDY3
ODQ0fSwiWVE2Y0hPQVZuOW9NOXZNViI6eyJkaXNjdXNzaW9uSW
QiOiJCUGNoNExKcjgzUkVJV1VwIiwic3ViIjoiZ2g6NjgyNTAz
NTAiLCJ0ZXh0IjoiTGV2ZWwgMiBnb29kIiwiY3JlYXRlZCI6MT
U5NjEzNjA5MzgzM30sInF5S3NiZE01c042THJqcGgiOnsiZGlz
Y3Vzc2lvbklkIjoiSUlXakRFMExPalQ2ZTl2OCIsInN1YiI6Im
doOjY4MjUwMzUwIiwidGV4dCI6ImNyaXRlcmlvbiB2cyBjcml0
ZXJpYT8iLCJjcmVhdGVkIjoxNTk2MTM2MzkzMzY1fSwiemkzd2
NhYnB1VnVGZnpPTSI6eyJkaXNjdXNzaW9uSWQiOiJ1SW1GVmtB
bmJQdWhIMGtVIiwic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZXh0Ij
oiOiIsImNyZWF0ZWQiOjE1OTYxMzY0NDQ3OTN9LCJEZ2VpY3BK
ekpqQm9TSzdRIjp7ImRpc2N1c3Npb25JZCI6InRocGNEWGZJRT
hPZVdpUXoiLCJzdWIiOiJnaDo2ODI1MDM1MCIsInRleHQiOiI/
IiwiY3JlYXRlZCI6MTU5NjEzNjQ5Nzg3OX0sIkVqcVdOMGNGUj
BtaU5IWk8iOnsiZGlzY3Vzc2lvbklkIjoiaFpvYU11YlJ6d0Nr
VHRXRiIsInN1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6InNpbm
NlIHdlIGNhcGl0YWxpc2VkIEQsIHRoZSB3b3JrIGxhcmdlIGlz
IHJlZHVuZGFudCIsImNyZWF0ZWQiOjE1OTYxMzY1MzQzNDV9LC
JDU0xndTQ2QUllMFN4d1ROIjp7ImRpc2N1c3Npb25JZCI6Imha
b2FNdWJSendDa1R0V0YiLCJzdWIiOiJnaDo2ODI1MDM1MCIsIn
RleHQiOiJPciB1c2UgXCJEIGluc3RlYWQgb2YgZFwiIiwiY3Jl
YXRlZCI6MTU5NjEzNjU1MzA4N30sIjBBTFNJSW5pZkFnSWxVbm
UiOnsiZGlzY3Vzc2lvbklkIjoiQUF5NGlKQ3pWWlJJVFBwNyIs
InN1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6IklzIHRoaXMgc3
VwcG9zZWQgdG8gYmUgbGlrZSB0aGlzPyIsImNyZWF0ZWQiOjE1
OTYxMzY4MDI5MDl9LCIxZzVSUUdNV24zRjI3S21oIjp7ImRpc2
N1c3Npb25JZCI6ImZLVXZVVXZReWNhU09rd3UiLCJzdWIiOiJn
aDo2ODI1MDM1MCIsInRleHQiOiJmYXIgb3IgZmFzdD8iLCJjcm
VhdGVkIjoxNTk2MTM3NTEzNTYyfSwieG9TdjBMMDFPOVo5Z0Fj
NyI6eyJkaXNjdXNzaW9uSWQiOiJxc0VQMlFlYWlOZ2dDeGNLIi
wic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZXh0IjoiSSB0aGluayBp
dCB3b3VsZCBiZSBuaWNlIHRvIGNoZWNrIHdpdGggdGhlIGRldn
MgaG93IGRvYWJsZSBhcmUgcGVycGV0dWFsIGxvb3BzLCBJIGZl
ZWwgd2UgaGF2ZSBxdWl0ZSBzb21lIG9mIHRoZW0uIiwiY3JlYX
RlZCI6MTU5NjEzNzU2MzQxNn0sIlUzMWRDU3pCeThEa3I2aUMi
OnsiZGlzY3Vzc2lvbklkIjoibHJEWFZWQ2VTSmNZTVcxSSIsIn
N1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6Iml0YWxpYyBvciBi
b3hlZCBzaW5jZSBpdCBpcyBhbiB2YXJpYWJsZT8iLCJjcmVhdG
VkIjoxNTk2MTM3NTkwODg3fSwieU0zNnhKWnVVaDFVSm1jZiI6
eyJkaXNjdXNzaW9uSWQiOiI1VmlDTU5RZXpXaG5ERzB1Iiwic3
ViIjoiZ2g6NTExMTI2MTgiLCJ0ZXh0IjoiZG8gd2UgaGF2ZSBz
dGlsbCBcImVwb2Noc1wiPyIsImNyZWF0ZWQiOjE1OTc4NDcyMD
U0Njd9fSwiaGlzdG9yeSI6Wy0yMDc5ODQ5Njg4LC0xNjc4MjE2
MTg4LC04NTg4NzI3MjYsMTU4NDQzMTkyNiwtMzMyMjMzMDczLC
0xNzcyMzQwNzU3LDQyODcxMTU5OSwxMzU1OTUzNjEwLC0xMTUx
NDgyMDA2LC0xODU0NjcyMTcyLC0xMzIwMTAyNTcyLC0zODAxNz
MxMywyOTY0OTYwNjYsMTY5ODE3MDY3NiwtMTE4NjcxODcwNCwt
MzM4MDg2MTEwLC0xMDM0OTMwMzY1LDE5MjA1OTU5ODYsNTk1Mj
E3ODk0LDE4OTgxMzUxMDldfQ==
-->