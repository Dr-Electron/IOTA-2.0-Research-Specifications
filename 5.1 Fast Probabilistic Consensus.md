+ Feature name:  FPC specifications
+ Start date: 2020-03-16

# 5.1 FPC specification


The module presented in this specification, FPC, allows nodes to find consensus on whether a transaction is valid or not. 

The specification will be subdivided into the following subsections:

1. The core FPC protocol: our basic consensus protocol on binary opinions. It may be used on different layers and kinds of messages. 
2. FPC on tangle: opinions on transaction of the tangle become dependent. This parts specifies monotonicity and consistency rules.
3. Message compression of FPC: reducing message complexity through message compression and reducing overhead of demanded nodes by gossiping of opinions.
4. protocol interface: data layer and value layer. This part specifies when FPC is started; it defines how the variables `queryStatus` and `answerStatus` are set. Also function`getInitialOpinion`has to be specified.  -> This part should essentially be covered by Billy.
5. Resynchronization interface: if protocol does not auto-terminate -> resynchronization
6. Berserk detection: mechanism that allows the detection of Berserk behavior. This part may be integrated later on. This depends on how we do proceed with reporting malicious behavior etc.
7. Protocol monitoring: information every node saves for testing of the protocol (in test net, finding optimal parameter sets) and for monitoring in main net
8. Testing: This section discusses how the protocol is tested. It subdivides into two parts: testing the logic and test behavior in Byzantine infrastructure.
9. 

# 5.1.1 Motivation

# 5.1.2 Dependencies
The FPC module depends on the following other modules:
> [name=Sebastian MuFinalizationThresholder, time=Fri, Jun 19, 2020 10:42 AM] wait until respecive specs are available then synronize

 - 4.3 Mana (to obtain list of mana)
 - 5.3 dRNG (to obtain random number)
  - 5.4 Resynchronization  
  - 3.2 Finality
  - 1.2 Communication Specifications  Payloads and Ontologies 
  - 4.2 UTXO and Realities calculations
  - 2.1 Autopeering (to obtain a list of nodes)  Rate control (gossiping of high mana nodes, do FPC messages need to pass rate control?)

# 5.1.3 Remarks
FPC on tangle is essentially a consensus on "time". At various parts local clocks will be used and compared to timestamps of messages. There are general standing assumption on network latency and clock synchronizations. In a nutshell, they are that the differences in clocks are at least one order of magnitude lower than the network latency. 


# 5.1.4 The core FPC

The protocol tries to find consensus on the validity of a transaction `objectID`. Every node has an initial opinion `opinion`(boolean) on this transaction. These opinions are updated in rounds until the protocol terminates using a local stopping rule. 

## 5.1.4.1 Protocol variables

We define the type `Opinion`. 
```
Opinion: {
    DISLIKE: 0,
    LIKE: 1,
    NULL: NULL  #The node does not know about the object,
    NA : NA # a node does not receive an answer of the opinion of another node
}
```



* `FinalizationThreshold` integer - number of consecutive rounds before FPC auto-terminates
* `FinalizationThreshold2` integer - number of consecutive rounds with non-random threshold
* `FirstRoundThreshold`  double - threshold in first round
* `SubsequentRoundsLowerBoundThreshold` double -  lower random threshold bound in subsequent rounds
*  `SubsequentRoundsUpperBoundThreshold` double -  upper random threshold bound in subsequent rounds
* `maxRound` integer - maximal number of rounds before querying stops
* `querySize` integer - quorum size, number of nodes that are queries
* `roundLength` double - length (in sec) of a round, this has to be synchronized !? For instance, by the DRNG, maybe start with 10s, and FPC only uses DRNG every second round
* `timeOut` - somehow a timer that is updated periodically, connected to `roundLength` TBD

The above variables can in theory be chosen locally for each node. However, the security of the protocol depends on that they are chosen in a reasonable way. The best is if these variables are chosen the same for every node. The IF recommends to use the default values.

IF default/recommendation values are:

TO COME

## 5.1.4.2 Local variables

Every node has the following variables
* `opinion` Opinion
* `nodeList` list of all nodes
* `manaList` list of mana of nodes
* `mana` double - mana of node
* `opinion` boolean - transaction true or false
* `cnt` integer - counter that counts the number of consecutives rounds with unchanged opinion
* `queryStatus` boolean - status if actively querying
* `answerStatus` boolean - status if answerying queries, default value here is `TRUE`
* `round` integer - counts number of rounds in FPC
* `rn` double - random number from dRNG
* `rnCycle` double - random number instance (random numbers are produced at a certain period, this variable counts the current cycle) (-> connect to dRNG)
* `queryList`- list of nodes to query
* `opinionQuery` - list of opinion of nodes in `queryList`, nonreplies are encoded with `NA`
* `reachedMaxRound` boolean - indicating whether protocl reached `maxRound` before auto-termination, default calue `FALSE`
> [name=Sebastian Mueller] Present the above in a table?


## 5.1.4.3 Functions that are called
* `getIninitialOpinion` input: `objectID` output: opinion
* `getRN` input: `rnCycle` output: `rn`
* `getNodes` input:   output: `nodeList`
* `getMana` input: `nodeList` output: `manaList`
* `getSample` input: `querySize` `nodeList` `manaList` : output `queryList`
* `getOpinion` input: `objectID` `queryList` output: `opinionQuery`
* `checkQuerySuccessful` input: `queryList` `opinionQuery` output: `querySuccessful`: c*hecks whether `opinionQuery` from `getOpinion` contains enough answers*
*  `opinionUpdate` input: queryStatus output: `opinion` 
> [name=Sebastian Mueller] How do we write functions? Compare to https://hackmd.io/1oJWLLMPRmaA-GkgWJPi0Q.
## 5.1.4.4 Pseudocode 
 
Note: In the pseudocode at various places global variables are again used as input for the functions. 

### `getInitialOpinion`

This function depends on the ontology. 

### `getRN(layer, a, b, time)`
```
gets a uniform random number between (a,b),
to come, to be discussed with DRNG, 
Note: each layer may use a different random number

OUTPUT: randomThreshold, source of randomness
```

### `getNodes` 
This function should be defined somewhere in autopeering module?

### `getMana`

This function may be specified in Mana part


### `getSample(querySize, nodeList, manaList)`
```
queryList = empty
while (queryList does not contain querySize different element){
newSample:=Sample(nodeList, weight=mana, replacement=TRUE)
queryList = concat(queryList, newSample)
}
return queryList
```

### `getOpinion(queryList, timeOut)`

```
send queries to all nodes of queryList
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
return opinionQuery
```

### `checkQuerySuccessful(queryList, opinionQuery)`
```
# `manaMin` double - minimal mana of answers that have to arrive before new random number is issued  -> change to function
manaMin:=0.5 #at least 50% of the queried mana has to reply; this value may be changed
queriedMana := sum(manaList[queryList])
answerMana :=  sum(manaList[queryList[replied==TRUE]])/queriedMana
querySuccessful := ifElse( answerMana>= manaMin, TRUE, False)
return querySuccessful
```

### `sendOpinion(timeOut)`

```
answer queries that arrive before timeOut
```


### `opinionUpdate(layer, opinion, querySize, nodeList, manaList, FirstRoundThreshold, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)`
```
Sample :=getSample(querySize, nodeList, manaList)
opinionQuery := getOpinion(queryList, timeOut)
if (!checkQuerySuccessful(queryList, opinionQuery)){ #check if sufficiently many nodes replied in time
    newOpinion := opinion # if not keep old opinion 
}
else{ # otherwise update according to FPC rule
    etaStar := mean(opinionQuery, NA.remove=TRUE)
    totalMana := sum(listMana, NA.remove=TRUE) # remove nodes that did not answer
    eta := opinion*mana + etaStar*(totalMana-mana)/totalMana
    if (round == 1){ #first FPC round uses different threshold
        if (eta < FirstRoundThreshold){
            newOpinion <-0
        }
        else newOpinion <-1
    }
    else #the subsequent rounds (before the FinalizationThreshold2 confirming) use random threshold
        rn := getRN(layer, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, time)  # here we have to synchronize/wait for random number
        if (eta < rn){
            newOpinion <-0
        }
        else newOpinion <-1       
}

return newOpinion 
```


### `mainFPC(objectId, queryStatus)`
```
if (queryStatus turns TRUE ){ 
    opinion := getInitialOpinion(objectID)
    listMana := getMana()
    listNode := getNodes()
    cnt := 1
}
wait for new FPC round # next random number from dRNG
#start the first FPC round
round := 1 
opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, FirstRoundThreshold, ubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)
if (opinion==opinionNew) cnt++
else cnt:=0
opinion := opinionNew
round++

#continue FPC, subsequent rounds 
while queryStatus {
    if (cnt <= FinalizationThreshold-FinalizationThreshold2) # we use random threshold{
        opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, FirstRoundThreshold, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)
        if (opinion==opinionNew) cnt++
        else cnt:=0
        opinion := opinionNew
    }
    else {  # we use deterministic threshold for FinalizationThreshold2 "confirming" rounds
    opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, 0.5, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, 1, time)
        if (opinion==opinionNew) cnt++
        else cnt:=0
        opinion := opinionNew      
    }
    round++
    if (cnt==FinalizationThreshold) queryStatus:=FALSE
    if (round>=MaxRound) {
        queryStatus:=FALSE
        reachedMaxRound:=TRUE
    }
}
return(opinion)
```

## 5.1.4.5 Message/transaction layout


### Querying message

### Answering message
This is done in the next section.

# 5.1.5 FPC on tangle

In the tangle reality FPC may have to be applied to various messages simultaneously. Moreover, the tangle (the local view of every node) has to be monotone and consistent. We have to address the three following points:
* **Parallelity:** Many ongoing votings at the same time 
* **Consistency:** Layer should not contain contradicting messages
* **Monotonicity:** Liked  messages should not refer to disliked messages

## 5.1.5.1 Parallelity
At every round FPC decides on possibly several opinions. However, the every node will only query other nodes once (!). This is done for scalability. 

The local variable `opinions` records the vector of all opinions under vote. 

### `getInitialOpinions`

This function depends on the ontology and uses `getInitialOpinions` in a straightforward way.


### `getOpinions(queryList, timeOut)`
```
send queries to all nodes of queryList
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
return opinionsQuery
```
FPC is now applied for each opinion separately. This may not be optimal, but this is addressed in Section 3. It may that the outcome is not consistent or monotone. 


### single vs. multiple dRNG in each round

Discussion: using a different threshold for every opinion (e.g. hash(objectID) X hash(rn)) may lead to the following attack vector. If the number of votings is large then with high probability some of the will always have a random threshold close to 0.5, in other words for a random subset of tx there is no random threshold and hence the protocol is unsafe. 

Advantage of using the same random threshold is also that the two following functions have less to do, i.e., monotonicity and consistency is increased.

It may be good to use different random thresholds for the voting on different layers! (-> `getRN()`)

## 5.1.5.2 Consistency and Monotonicity

### `applyMonotonicityRule()`
```
functions that make temporary ledger state monoton, past cone of liked tx are like, future cones of disliked tx dislike, generalize these rules to level of knowledge -> Billy
```

### `applyConsistencyRule()`
```
functions that make temporary ledger state consistent
if two contradiction transaction are liked, choose the one with the higher mana (?)/ the previous favorite/ hash?
```
## 5.1.5.3 Data layer
FPC is used in the data layer to decide on the validity of the timestamp of a message. We can use here a symmetric range of the random threshold, `a=beta, b=1-beta`



## 5.1.5.4 Value layer
FPC decides in particular between two conflicting transaction, thresholds below 0.5 may lead to liking both transaction after voting. TO DISCUSS: asymmetric random threshold `a=0.5, b=1-beta`. Since there are no simulations yet, it lay be good to run some to check performances. 


# 5.1.6 Message compression of FPC


## 5.1.6.1 Compression in query messages
**Query:** reduce message identifier, e.g., Prefix trie or Cuckoo filter
**Answer:** Bitmask, respond in same order with 1bit per message

# 5.1.7 Gossiping
High mana nodes will be queried too often. They have the possibility to gossip their opinion. However, it is yet not clear who will  be allowed to gossip. 

### Everybody can gossip
This solution follows the idea that IOTA is all but freedom. Every node can decide on his own whether to gossip or not. Nevertheless, IF has to propose a reference implementation.

Advantages:
* if not in place, high mana nodes may be spammed by querries. But is this a reasonable concern for Coordicide 1.0?

Disadvantages: 
* local optimum may not be global optimum
* if all nodes gossip, network may reach congestion. But is this a reasonable concern for Coordicide 1.0?

### Threshold for gossiping

There is a global threshold, like the 100 top mana holders can gossip, the others are querying. However, mana perception is local and hence the threshold can't be sharp. 


### Proposal
TO DISCUSS
* every node is free to gossip
* nodes who gossip, close the port corresponding to queries, this allows other nodes to see whether this node gossips, 
* in IF reference implementation: if own mana perception is above a certain threshold, that would lead to overquery, then gossip

### Changes in the FPC protocol

Warning: the code may depend on the above decision who is going to gossip their opinion. 
### `getOpinions(queryList, timeOut)`
```
send queries to all nodes of queryList that do not gossip
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
read opinions from tangle of all to all nodes of queryList that do gossip

return opinionsQuery
```
Edge cases: what happens if gossiping node is queried? (Angelo: not reply at all, you even don t listen (close ports), Seb: be kind if possible).

If node has to gossip but is not?

# 5.1.7  Protocol monitoring




# 5.1.8 Testing

## 5.1.8.1 Edge cases

## 5.1.8.2 Spamming

## 5.1.8.3 Adversarial strategies

<!--stackedit_data:
eyJkaXNjdXNzaW9ucyI6eyIwU1Y4YmhLcDFjTnJDUzdFIjp7In
RleHQiOiJNYW5hICh0byBvYnRhaW4gbGlzdCBvZiBtYW5hKSIs
InN0YXJ0IjoxODA4LCJlbmQiOjE4Mzd9LCJXU1BQcGxQYkg4dH
BVNW83Ijp7InRleHQiOiIjIDUuMS41IEZQQyBvbiB0YW5nbGUi
LCJzdGFydCI6MTA0MTMsImVuZCI6MTA0MzR9LCI2bDdPRExlT2
ZGRWhva241Ijp7InRleHQiOiJTaW5jZSB0aGVyZSBhcmUgbm8g
c2ltdWxhdGlvbnMgeWV0LCBpdCBsYXkgYmUgZ29vZCB0byBydW
4gc29tZSB0byBjaGVjayBwZXJmb3Jt4oCmIiwic3RhcnQiOjEz
MjA4LCJlbmQiOjEzMjkzfSwiMDhtRjdPODZGNUdRR2RaayI6ey
J0ZXh0Ijoibm9kZSBnb3NzaXBzLCIsInN0YXJ0IjoxNDU1MSwi
ZW5kIjoxNDU2NH0sInhhZ0xic3JmRXo4UUpXdkMiOnsidGV4dC
I6Ikl0IG1heSBzZXJ2ZSBvbiB2YXJpb3VzIG9udG9sb2dpZXMg
YXMgY29uc2Vuc3VzIHByb3RvY29sLiIsInN0YXJ0IjozNTcsIm
VuZCI6MzU4fSwiU0dqNUhSVXZDam5FcFFvZiI6eyJ0ZXh0Ijoi
dHJhbnNhY3Rpb24iLCJzdGFydCI6NDQ2LCJlbmQiOjQ1N30sIl
dZWjFhV3hxSlVvQTZpY1UiOnsidGV4dCI6IjQuIHByb3RvY29s
IGludGVyZmFjZTogZGF0YSBsYXllciBhbmQgdmFsdWUgbGF5ZX
IuIFRoaXMgcGFydCBzcGVjaWZpZXMgd2hlbiBGUEPigKYiLCJz
dGFydCI6NzAwLCJlbmQiOjk2OX0sIkNBeUV1REZOSWJWa1hDWD
MiOnsidGV4dCI6IlJlc3luY2hyb25pemF0aW9uIGludGVyZmFj
ZTogaWYgcHJvdG9jb2wgZG9lcyBub3QgYXV0by10ZXJtaW5hdG
UgLT4gcmVzeW5jaHJvbmnigKYiLCJzdGFydCI6OTczLCJlbmQi
OjEwNTh9LCJmcnZqVVN5SmxLUGhLREQ4Ijp7InRleHQiOiJCZX
JzZXJrIGRldGVjdGlvbjogbWVjaGFuaXNtIHRoYXQgYWxsb3dz
IHRoZSBkZXRlY3Rpb24gb2YgQmVyc2VyayBiZWhhdmlvci4gVG
hp4oCmIiwic3RhcnQiOjEwNjIsImVuZCI6MTU2NH0sIkVzeVNn
SEh2Y2ZvaVpkVzUiOnsidGV4dCI6IiMgNS4xLjEgTW90aXZhdG
lvbiIsInN0YXJ0IjoxNTcwLCJlbmQiOjE1ODh9LCIwaEZEUGEz
QURWMkNRUEo3Ijp7InRleHQiOiIjIDUuMS4yIERlcGVuZGVuY2
llcyIsInN0YXJ0IjoxNTkwLCJlbmQiOjE2MTB9LCJJSnppOHgw
SDBEbzBxY2hIIjp7InRleHQiOiJGUEMgb24gdGFuZ2xlIGlzIG
Vzc2VudGlhbGx5IGEgY29uc2Vuc3VzIG9uIFwidGltZVwiLiBB
dCB2YXJpb3VzIHBhcnRzIGxvY2FsIGNsb2PigKYiLCJzdGFydC
I6MjE3OCwiZW5kIjoyNTIwfSwiNzBhbmVjMW5rUXVRcmpISiI6
eyJ0ZXh0IjoiOS4iLCJzdGFydCI6MTU2NSwiZW5kIjoxNTY3fS
wiaWlWcmpnclJocUdTRUpUdSI6eyJ0ZXh0IjoidGhyZXNob2xk
Iiwic3RhcnQiOjMyNzAsImVuZCI6MzI3OX0sIjh2dWFBb2hKMD
VYem1ydEYiOnsidGV4dCI6InRoaXMgaGFzIHRvIGJlIHN5bmNo
cm9uaXplZCAhPyBGb3IgaW5zdGFuY2UsIGJ5IHRoZSBEUk5HLC
BtYXliZSBzdGFydCB3aXRoIDEwcyzigKYiLCJzdGFydCI6MzY4
OSwiZW5kIjozODEwfSwialJJbWFJbzRmYTVNbzZJWSI6eyJ0ZX
h0Ijoic29tZWhvdyBhIHRpbWVyIHRoYXQgaXMgdXBkYXRlZCBw
ZXJpb2RpY2FsbHksIGNvbm5lY3RlZCB0byBgcm91bmRMZW5ndG
hgIFRCRCIsInN0YXJ0IjozODI1LCJlbmQiOjM5MDF9LCJIdFBU
SVlvTW9xNFdvTDBvIjp7InRleHQiOiJUaGUgYWJvdmUgdmFyaW
FibGVzIGNhbiBpbiB0aGVvcnkgYmUgY2hvc2VuIGxvY2FsbHkg
Zm9yIGVhY2ggbm9kZS4gSG93ZXZlciwgdGhl4oCmIiwic3Rhcn
QiOjM5MDMsImVuZCI6NDEyNn0sImJXc0xzOXFIdkVOM2h1akUi
OnsidGV4dCI6InZhcmlhYmxlcyIsInN0YXJ0Ijo0Mjc5LCJlbm
QiOjQyODh9LCJUSDU0SXZSTkpyZ0JDMGZFIjp7InRleHQiOiIq
IGBtYW5hTGlzdGAgbGlzdCBvZiBtYW5hIG9mIG5vZGVzXG4qIG
BtYW5hYCBkb3VibGUgLSBtYW5hIG9mIG5vZGUiLCJzdGFydCI6
NDM0MCwiZW5kIjo0NDA1fSwiSnJ3SWp1S2s5ZlBTWGhCcCI6ey
J0ZXh0IjoiYm9vbGVhbiAtIHRyYW5zYWN0aW9uIHRydWUgb3Ig
ZmFsc2UiLCJzdGFydCI6NDQxOCwiZW5kIjo0NDUzfSwiR1phS0
VvREMwcjk2ekJFMSI6eyJ0ZXh0IjoiVGhpcyBmdW5jdGlvbiBk
ZXBlbmRzIG9uIHRoZSBvbnRvbG9neS4iLCJzdGFydCI6NjA5NS
wiZW5kIjo2MTMzfSwiOHdydVdKOWJiaWVVTlZ6MyI6eyJ0ZXh0
IjoiTm90ZTogZWFjaCBsYXllciIsInN0YXJ0Ijo2MjUyLCJlbm
QiOjYyNjh9LCJhQ0pLNG9wWmthWmY0aUxXIjp7InRleHQiOiJg
YT0wLjUsIGI9MS1iZXRhYCIsInN0YXJ0IjoxMzE4OSwiZW5kIj
oxMzIwNn19LCJjb21tZW50cyI6eyI0aG5Sak9PVzRIaUtNTnZq
Ijp7ImRpc2N1c3Npb25JZCI6IjBTVjhiaEtwMWNOckNTN0UiLC
JzdWIiOiJnaDo1MTExMjYxOCIsInRleHQiOiJzbmFwc2hvdHRl
ZCBtYW5hIHZzIGFsdGVybmF0aXZlcyIsImNyZWF0ZWQiOjE1OT
Y1MjAzMDQ3MjR9LCI5OG84NGttSDM0REFjY3VpIjp7ImRpc2N1
c3Npb25JZCI6IldTUFBwbFBiSDh0cFU1bzciLCJzdWIiOiJnaD
o1MTExMjYxOCIsInRleHQiOiIhIFRoaXMgc2VjdGlvbiBtYXkg
Y2hhbmdlIChpZiBmYWN0IGJlIGRlbGV0ZWQpICBpbiBwYXJhbG
xlbCByZWFsaXR5IHVuaXZlcnNlLiIsImNyZWF0ZWQiOjE1OTY1
MjA4Njk1NjF9LCJocURtMUZTbkZlTmpuWU5sIjp7ImRpc2N1c3
Npb25JZCI6IjZsN09ETGVPZkZFaG9rbjUiLCJzdWIiOiJnaDo1
MTExMjYxOCIsInRleHQiOiJEb25lIGluIHRoZSBtZWFudGltZS
wgbm8gYmFkIHN1cnByaXNlcyIsImNyZWF0ZWQiOjE1OTY1MjEx
MTE4OTZ9LCI2QUZubW1OejJ1bkdSUUZKIjp7ImRpc2N1c3Npb2
5JZCI6IjA4bUY3Tzg2RjVHUUdkWmsiLCJzdWIiOiJnaDo1MTEx
MjYxOCIsInRleHQiOiJ3ZWxsIGF0IGxlYXN0IGFuIGluZGljYX
Rpb24iLCJjcmVhdGVkIjoxNTk2NTIxMjQxNTMxfSwiZGM2Zzhk
Qld3WWRMQ0VZWCI6eyJkaXNjdXNzaW9uSWQiOiIwU1Y4YmhLcD
FjTnJDUzdFIiwic3ViIjoiZ2g6NTExMTI2MTgiLCJ0ZXh0Ijoi
anVzdCBGUENNYW5hIiwiY3JlYXRlZCI6MTU5NjUyOTk3NzExMX
0sImpRS1NTZmxaOTJ4R3ZNRHoiOnsiZGlzY3Vzc2lvbklkIjoi
eGFnTGJzcmZFejhRSld2QyIsInN1YiI6ImdoOjY4MjUwMzUwIi
widGV4dCI6IlJlbW92ZSBhcyBvbnRvbG9naWVzIGluIG5ldmVy
IGNsZWFyIiwiY3JlYXRlZCI6MTU5Nzc3NjkyNDU0Mn0sInltMD
cyeFJtS1V5ZVFacEQiOnsiZGlzY3Vzc2lvbklkIjoiU0dqNUhS
VXZDam5FcFFvZiIsInN1YiI6ImdoOjY4MjUwMzUwIiwidGV4dC
I6IlRyYW5zYWN0aW9uIHZzIFZhbHVlIE1lc3NhZ2U/IiwiY3Jl
YXRlZCI6MTU5Nzc3NzM4ODE0Mn0sIjV5dUl5NlhWWE5lMExhMD
UiOnsiZGlzY3Vzc2lvbklkIjoiV1laMWFXeHFKVW9BNmljVSIs
InN1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6IklzIHRoaXMgNS
4yPyIsImNyZWF0ZWQiOjE1OTc3NzgxNTQwOTB9LCJCcmJ3RlR4
dUJzbEEzMkl1Ijp7ImRpc2N1c3Npb25JZCI6IkNBeUV1REZOSW
JWa1hDWDMiLCJzdWIiOiJnaDo2ODI1MDM1MCIsInRleHQiOiJU
aGlzIGlzIG5vdCBjb3ZlcmVkIGhlcmUsIHNob3VsZCB3ZSByZW
ZlciB0byA1LjQ/IiwiY3JlYXRlZCI6MTU5Nzc3ODE5OTI3OH0s
Im5qUkRNNlJtTXJZSnZ4QTIiOnsiZGlzY3Vzc2lvbklkIjoiZn
J2alVTeUpsS1BoS0REOCIsInN1YiI6ImdoOjY4MjUwMzUwIiwi
dGV4dCI6IkFsbCBvZiB0aGlzIGlzIGluY29tcGxldGUiLCJjcm
VhdGVkIjoxNTk3Nzc4MjE4ODE3fSwiNGdkZzVpaUxxT3RkYUE0
eCI6eyJkaXNjdXNzaW9uSWQiOiJFc3lTZ0hIdmNmb2laZFc1Ii
wic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZXh0IjoiV2lsbCBzb21l
dGhpbmcgYmUgd3JpdHRlbiBoZXJlPyIsImNyZWF0ZWQiOjE1OT
c3NzgyMzM4NTl9LCJZYVNCcnk4TlY0eG5VRXJTIjp7ImRpc2N1
c3Npb25JZCI6IjBoRkRQYTNBRFYyQ1FQSjciLCJzdWIiOiJnaD
o2ODI1MDM1MCIsInRleHQiOiJUaGlzIHNlY3Rpb24gc2hvdWwg
ZWl0aGVyIGJlIGF0IGJlIGJlZ2lubmluZyBvciBza2lwcGVkIG
ltby4gVGhlIGRlcGVuZGVuY2llcyBzaG91bGQgdXNlIHRoZSBw
cm9wZXIgcmVmZXJlbmNlIHdoZW50IGhleSBhcHBlYXIuIiwiY3
JlYXRlZCI6MTU5Nzc3ODQ0NDk4MH0sIkFPV1BoQjR4UWU4NjFQ
S0MiOnsiZGlzY3Vzc2lvbklkIjoiSUp6aTh4MEgwRG8wcWNoSC
IsInN1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6IlNob3VsZCB3
ZSBzYXkgc29tdGhpbmcgYWJvdXQgc3luY2hyb25vdXMgdnMgQX
N5bmNocm9ub3VzPyIsImNyZWF0ZWQiOjE1OTc3Nzg1MzMyMjF9
LCJNZ01Db1ltdGh6ell5dktSIjp7ImRpc2N1c3Npb25JZCI6Ij
cwYW5lYzFua1F1UXJqSEoiLCJzdWIiOiJnaDo2ODI1MDM1MCIs
InRleHQiOiJHb3NzaXBpbmc/IiwiY3JlYXRlZCI6MTU5Nzc3OD
U2NDk3M30sIjlqTlUyWjUyNlM3MzZReDciOnsiZGlzY3Vzc2lv
bklkIjoiaWlWcmpnclJocUdTRUpUdSIsInN1YiI6ImdoOjY4Mj
UwMzUwIiwidGV4dCI6IlRocmVzaG9sZCBvZiB0aGUgcHJvcG9y
dGlvbiBvZiBvcGluaW9ucyIsImNyZWF0ZWQiOjE1OTc3Nzk0Mz
A5NjJ9LCJ2RUg4eDFmM2NOMWh4bWtwIjp7ImRpc2N1c3Npb25J
ZCI6Ijh2dWFBb2hKMDVYem1ydEYiLCJzdWIiOiJnaDo2ODI1MD
M1MCIsInRleHQiOiJEZWxldGUgdGhpcz8iLCJjcmVhdGVkIjox
NTk3NzgyOTc3NzM0fSwiZ3pTODZjcGp3ZlBSbzg0YSI6eyJkaX
NjdXNzaW9uSWQiOiJqUkltYUlvNGZhNU1vNklZIiwic3ViIjoi
Z2g6NjgyNTAzNTAiLCJ0ZXh0IjoiTm90IENsZWFyIiwiY3JlYX
RlZCI6MTU5Nzc4MzExNzY2OX0sIllYeW5vOUh2OWdOUmExQ2Yi
OnsiZGlzY3Vzc2lvbklkIjoiSHRQVElZb01vcTRXb0wwbyIsIn
N1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6IlNvIHNob3VsZCB3
ZSBhbGxvdyB0aGlzPyBJZiBub3Qgc2hvdWxkIHRoaXMgYmUgc2
FpZD8iLCJjcmVhdGVkIjoxNTk3NzgzMTcyNjI0fSwiVXFsQUda
RUNqemg1MU1FRCI6eyJkaXNjdXNzaW9uSWQiOiJiV3NMczlxSH
ZFTjNodWpFIiwic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZXh0Ijoi
SXMgdGhhdCB0aGUgYmVzdCB3b3JkIHRvIHVzZT8gQXMgYW4gZX
hhbXBsZSBcIk9waW5pb25cIiBpcyBhIHJlbGF0aW9uIGJldHdl
ZW4gbm9kZSBhbmQgVHJhbnNhY3Rpb24uIFRoaXMgbWVhbnMgdG
hlIG5vZGUgZG9udCBoYXZlIG9uZSBPcGluaW9uLCBidXQgb25l
IHBlciB0cmFuc2FjdGlvbi4iLCJjcmVhdGVkIjoxNTk3NzgzOT
UxODc4fSwiR25wOHEwMXVtZmlVdTd6TiI6eyJkaXNjdXNzaW9u
SWQiOiJUSDU0SXZSTkpyZ0JDMGZFIiwic3ViIjoiZ2g6NjgyNT
AzNTAiLCJ0ZXh0IjoiU2hvdWxkIHRoaXMgYmUgdXBkYXRlZCB3
aXRoIHRoZSBraW5kIG9mIG1hbmE/IiwiY3JlYXRlZCI6MTU5Nz
c4Mzk4Mzc3MH0sImt6d0J5ejRFRWt1Qm9pM0ciOnsiZGlzY3Vz
c2lvbklkIjoiSnJ3SWp1S2s5ZlBTWGhCcCIsInN1YiI6ImdoOj
Y4MjUwMzUwIiwidGV4dCI6Ikl0cyB0d2ljZSBpbiB0aGUgbGlz
dCIsImNyZWF0ZWQiOjE1OTc3ODM5OTc4NjN9LCJib2Jla0FyNE
N3RUo5TUppIjp7ImRpc2N1c3Npb25JZCI6IkdaYUtFb0RDMHI5
NnpCRTEiLCJzdWIiOiJnaDo2ODI1MDM1MCIsInRleHQiOiJDb2
5mdXNpbmcgYXMgT250b2xvZ3kgaXMgbm90IGRlZmluZWQiLCJj
cmVhdGVkIjoxNTk3Nzg0MjA0ODgwfSwiY3V5ZzlIZWcwR2NURF
NBSiI6eyJkaXNjdXNzaW9uSWQiOiI4d3J1V0o5YmJpZVVOVnoz
Iiwic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZXh0IjoiTGF5ZXIgaX
Mgbm90IHdlbGwgZGVmaW5lZCIsImNyZWF0ZWQiOjE1OTc3OTU2
NzA3Nzl9LCI1QWVCMlo5MHBEdXhkUE1tIjp7ImRpc2N1c3Npb2
5JZCI6ImFDSks0b3Baa2FaZjRpTFciLCJzdWIiOiJnaDo2ODI1
MDM1MCIsInRleHQiOiJzeW1ib2xzIG5vdCBpbiBhY2NvcmRhbm
NlIHRvIHRoZSBkZWZpbmVkIHBhcmFtZXRlcnMiLCJjcmVhdGVk
IjoxNTk3Nzk3NDMwNDY5fX0sImhpc3RvcnkiOlstNDgyMjIxND
gsMTYwNTM2MDI3NywtMzAyNjI4MzQzLDE2NDczOTE2NjgsLTQ1
NjYyMzEyLDEzMDg0MjM1NzUsMTAwMzk5OTU3NiwtMTU0MTI0Nj
EzNiw5NTkwMTIyMTMsMTMzNzY0OTcwNCw1NDYxMTEwMTgsLTQz
NzQ4NTMzNCw0MDYxNDQ5NTUsNjIzMjQxNTUyLDEzNTYxNDg2OC
w4NTAwMjM4MzcsLTEzMDc2MjY2M119
-->