+ Feature name:  FPC specifications
+ Start date: 2020-03-16

# 5.1 FPC specification


The module presented in this specification, FPC, allows nodes to find consensus on whether a transaction is valid or not. 

The specification will be subdivided into the following subsections:

1. The core FPC protocol: our basic consensus protocol on binary opinions. It may be used on different layers and kinds of messages. 
2. FPC on tangle: opinions on transaction of the tangle become dependent. This parts specifies monotonicity and consistency rules.
3. Message compression of FPC: reducing message complexity through message compression and gossiping of opinions for high mana nodes. This part has to be updated and revised due to the parallel reality approach.
4. protocol interface: data layer and value layer. This part specifies when FPC is started; it defines how the variables `queryStatus` and `answerStatus` are set. Also function`getInitialOpinion`has to be specified.  -> This part should essentially be covered by Billy.
5. Resynchronization interface: if protocol does not auto-terminate -> resynchronization
6. Berserk detection: mechanism that allows the detection of Berserk behavior. This part may be integrated later on. This depends on how we do proceed with reporting malicious behavior etc.
7. Protocol monitoring: information every node saves for testing of the protocol (in test net, finding optimal parameter sets) and for monitoring in main net
8. Testing: This section discusses how the protocol is tested. It subdivides into two parts: testing the logic and test behavior in Byzantine infrastructure.
9. 

# 5.1.1 Motivation

# 5.1.2 Dependencies
The FPC module depends on the following other modules:
> [name=Sebastian MuFinalizationThresholder, time=Fri, Jun 19, 2020 10:42 AM] wait until respecive specs are available then synronize

 - 4.3 Mana (to obtain list of mana)
 - 5.3 dRNG (to obtain random number)
  - 5.4 Resynchronization  
  - 3.2 Finality
  - 1.2 Communication Specifications  Payloads and Ontologies 
  - 4.2 UTXO and Realities calculations
  - 2.1 Autopeering (to obtain a list of nodes)  Rate control (gossiping of high mana nodes, do FPC messages need to pass rate control?)

# 5.1.3 Remarks
FPC on tangle is essentially a consensus on "time". At various parts local clocks will be used and compared to timestamps of messages. There are general standing assumption on network latency and clock synchronizations. In a nutshell, they are that the differences in clocks are at least one order of magnitude lower than the network latency. 


# 5.1.4 The core FPC

The protocol tries to find consensus on the validity of a transaction `objectID`. Every node has an initial opinion `opinion`(boolean) on this transaction. These opinions are updated in rounds until the protocol terminates using a local stopping rule. 

## 5.1.4.1 Protocol variables

We define the type `Opinion`. 
```
Opinion: {
    DISLIKE: 0,
    LIKE: 1,
    NULL: NULL  #The node does not know about the object,
    NA : NA # a node does not receive an answer of the opinion of another node
}
```



* `FinalizationThreshold` integer - number of consecutive rounds before FPC auto-terminates
* `FinalizationThreshold2` integer - number of consecutive rounds with non-random threshold
* `FirstRoundThreshold`  double - threshold in first round
* `SubsequentRoundsLowerBoundThreshold` double -  lower random threshold bound in subsequent rounds
*  `SubsequentRoundsUpperBoundThreshold` double -  upper random threshold bound in subsequent rounds
* `maxRound` integer - maximal number of rounds before querying stops
* `querySize` integer - quorum size, number of nodes that are queries
* `roundLength` double - length (in sec) of a round, this has to be synchronized !? For instance, by the DRNG, maybe start with 10s, and FPC only uses DRNG every second round
* `timeOut` - somehow a timer that is updated periodically, connected to `roundLength` TBD

The above variables can in theory be chosen locally for each node. However, the security of the protocol depends on that they are chosen in a reasonable way. The best is if these variables are chosen the same for every node. The IF recommends to use the default values.

IF default/recommendation values are:

TO COME

## 5.1.4.2 Local variables

Every node has the following variables
* `opinion` Opinion
* `nodeList` list of all nodes
* `manaList` list of mana of nodes
* `mana` double - mana of node
* `opinion` boolean - transaction true or false
* `cnt` integer - counter that counts the number of consecutives rounds with unchanged opinion
* `queryStatus` boolean - status if actively querying
* `answerStatus` boolean - status if answerying queries, default value here is `TRUE`
* `round` integer - counts number of rounds in FPC
* `rn` double - random number from dRNG
* `rnCycle` double - random number instance (random numbers are produced at a certain period, this variable counts the current cycle) (-> connect to dRNG)
* `queryList`- list of nodes to query
* `opinionQuery` - list of opinion of nodes in `queryList`, nonreplies are encoded with `NA`
* `reachedMaxRound` boolean - indicating whether protocl reached `maxRound` before auto-termination, default calue `FALSE`
> [name=Sebastian Mueller] Present the above in a table?


## 5.1.4.3 Functions that are called
* `getIninitialOpinion` input: `objectID` output: opinion
* `getRN` input: `rnCycle` output: `rn`
* `getNodes` input:   output: `nodeList`
* `getMana` input: `nodeList` output: `manaList`
* `getSample` input: `querySize` `nodeList` `manaList` : output `queryList`
* `getOpinion` input: `objectID` `queryList` output: `opinionQuery`
* `checkQuerySuccessful` input: `queryList` `opinionQuery` output: `querySuccessful`: c*hecks whether `opinionQuery` from `getOpinion` contains enough answers*
*  `opinionUpdate` input: queryStatus output: `opinion` 
> [name=Sebastian Mueller] How do we write functions? Compare to https://hackmd.io/1oJWLLMPRmaA-GkgWJPi0Q.
## 5.1.4.4 Pseudocode 
 
Note: In the pseudocode at various places global variables are again used as input for the functions. 

### `getInitialOpinion`

This function depends on the ontology. 

### `getRN(layer, a, b, time)`
```
gets a uniform random number between (a,b),
to come, to be discussed with DRNG, 
Note: each layer may use a different random number

OUTPUT: randomThreshold, source of randomness
```

### `getNodes` 
This function should be defined somewhere in autopeering module?

### `getMana`

This function may be specified in Mana part


### `getSample(querySize, nodeList, manaList)`
```
queryList = empty
while (queryList does not contain querySize different element){
newSample:=Sample(nodeList, weight=mana, replacement=TRUE)
queryList = concat(queryList, newSample)
}
return queryList
```

### `getOpinion(queryList, timeOut)`

```
send queries to all nodes of queryList
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
return opinionQuery
```

### `checkQuerySuccessful(queryList, opinionQuery)`
```
# `manaMin` double - minimal mana of answers that have to arrive before new random number is issued  -> change to function
manaMin:=0.5 #at least 50% of the queried mana has to reply; this value may be changed
queriedMana := sum(manaList[queryList])
answerMana :=  sum(manaList[queryList[replied==TRUE]])/queriedMana
querySuccessful := ifElse( answerMana>= manaMin, TRUE, False)
return querySuccessful
```

### `sendOpinion(timeOut)`

```
answer queries that arrive before timeOut
```


### `opinionUpdate(layer, opinion, querySize, nodeList, manaList, FirstRoundThreshold, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)`
```
Sample :=getSample(querySize, nodeList, manaList)
opinionQuery := getOpinion(queryList, timeOut)
if (!checkQuerySuccessful(queryList, opinionQuery)){ #check if sufficiently many nodes replied in time
    newOpinion := opinion # if not keep old opinion 
}
else{ # otherwise update according to FPC rule
    etaStar := mean(opinionQuery, NA.remove=TRUE)
    totalMana := sum(listMana, NA.remove=TRUE) # remove nodes that did not answer
    eta := opinion*mana + etaStar*(totalMana-mana)/totalMana
    if (round == 1){ #first FPC round uses different threshold
        if (eta < FirstRoundThreshold){
            newOpinion <-0
        }
        else newOpinion <-1
    }
    else #the subsequent rounds (before the FinalizationThreshold2 confirming) use random threshold
        rn := getRN(layer, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, time)  # here we have to synchronize/wait for random number
        if (eta < rn){
            newOpinion <-0
        }
        else newOpinion <-1       
}

return newOpinion 
```


### `mainFPC(objectId, queryStatus)`
```
if (queryStatus turns TRUE ){ 
    opinion := getInitialOpinion(objectID)
    listMana := getMana()
    listNode := getNodes()
    cnt := 1
}
wait for new FPC round # next random number from dRNG
#start the first FPC round
round := 1 
opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, FirstRoundThreshold, ubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)
if (opinion==opinionNew) cnt++
else cnt:=0
opinion := opinionNew
round++

#continue FPC, subsequent rounds 
while queryStatus {
    if (cnt <= FinalizationThreshold-FinalizationThreshold2) # we use random threshold{
        opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, FirstRoundThreshold, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)
        if (opinion==opinionNew) cnt++
        else cnt:=0
        opinion := opinionNew
    }
    else {  # we use deterministic threshold for FinalizationThreshold2 "confirming" rounds
    opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, 0.5, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, 1, time)
        if (opinion==opinionNew) cnt++
        else cnt:=0
        opinion := opinionNew      
    }
    round++
    if (cnt==FinalizationThreshold) queryStatus:=FALSE
    if (round>=MaxRound) {
        queryStatus:=FALSE
        reachedMaxRound:=TRUE
    }
}
return(opinion)
```

## 5.1.4.5 Message/transaction layout


### Querying message

### Answering message
This is done in the next section.

# 5.1.5 FPC on tangle

In the tangle reality FPC may have to be applied to various messages simultaneously. Moreover, the tangle (the local view of every node) has to be monotone and consistent. We have to address the three following points:
* **Parallelity:** Many ongoing votings at the same time 
* **Consistency:** Layer should not contain contradicting messages
* **Monotonicity:** Liked  messages should not refer to disliked messages

## 5.1.5.1 Parallelity
At every round FPC decides on possibly several opinions. However, the every node will only query other nodes once (!). This is done for scalability. 

The local variable `opinions` records the vector of all opinions under vote. 

### `getInitialOpinions`

This function depends on the ontology and uses `getInitialOpinions` in a straightforward way.


### `getOpinions(queryList, timeOut)`
```
send queries to all nodes of queryList
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
return opinionsQuery
```
FPC is now applied for each opinion separately. This may not be optimal, but this is addressed in Section 3. It may that the outcome is not consistent or monotone. 


### single vs. multiple dRNG in each round

Discussion: using a different threshold for every opinion (e.g. hash(objectID) X hash(rn)) may lead to the following attack vector. If the number of votings is large then with high probability some of the will always have a random threshold close to 0.5, in other words for a random subset of tx there is no random threshold and hence the protocol is unsafe. 

Advantage of using the same random threshold is also that the two following functions have less to do, i.e., monotonicity and consistency is increased.

It may be good to use different random thresholds for the voting on different layers! (-> `getRN()`)

## 5.1.5.2 Consistency and Monotonicity

### `applyMonotonicityRule()`
```
functions that make temporary ledger state monoton, past cone of liked tx are like, future cones of disliked tx dislike, generalize these rules to level of knowledge -> Billy
```

### `applyConsistencyRule()`
```
functions that make temporary ledger state consistent
if two contradiction transaction are liked, choose the one with the higher mana (?)/ the previous favorite/ hash?
```
## 5.1.5.3 Data layer
FPC is used in the data layer to decide on the validity of the timestamp of a message. We can use here a symmetric range of the random threshold, `a=beta, b=1-beta`



## 5.1.5.4 Value layer
FPC decides in particular between two conflicting transaction, thresholds below 0.5 may lead to liking both transaction after voting. TO DISCUSS: asymmetric random threshold `a=0.5, b=1-beta`. Since there are no simulations yet, it lay be good to run some to check performances. 


# 5.1.6 Message compression of FPC


## 5.1.6.1 Compression in query messages
**Query:** reduce message identifier, e.g., Prefix trie or Cuckoo filter
**Answer:** Bitmask, respond in same order with 1bit per message

# 5.1.7 Gossiping
High mana nodes will be queried too often. They have the possibility to gossip their opinion. However, it is yet not clear who will  be allowed to gossip. 

### Everybody can gossip
This solution follows the idea that IOTA is all but freedom. Every node can decide on his own whether to gossip or not. Nevertheless, IF has to propose a reference implementation.

Advantages:
* if not in place, high mana nodes may be spammed by querries. But is this a reasonable concern for Coordicide 1.0?

Disadvantages: 
* local optimum may not be global optimum
* if all nodes gossip, network may reach congestion. But is this a reasonable concern for Coordicide 1.0?

### Threshold for gossiping

There is a global threshold, like the 100 top mana holders can gossip, the others are querying. However, mana perception is local and hence the threshold can't be sharp. 


### Proposal
TO DISCUSS
* every node is free to gossip
* nodes who gossip, close the port corresponding to queries, this allows other nodes to see whether this node gossips, 
* in IF reference implementation: if own mana perception is above a certain threshold, that would lead to overquery, then gossip

### Changes in the FPC protocol

Warning: the code may depend on the above decision who is going to gossip their opinion. 
### `getOpinions(queryList, timeOut)`
```
send queries to all nodes of queryList that do not gossip
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
read opinions from tangle of all to all nodes of queryList that do gossip

return opinionsQuery
```
Edge cases: what happens if gossiping node is queried? (Angelo: not reply at all, you even don t listen (close ports), Seb: be kind if possible).

If node has to gossip but is not?

# 5.1.7  Protocol monitoring




# 5.1.8 Testing

## 5.1.8.1 Edge cases

## 5.1.8.2 Spamming

## 5.1.8.3 Adversarial strategies

<!--stackedit_data:
eyJkaXNjdXNzaW9ucyI6eyIwU1Y4YmhLcDFjTnJDUzdFIjp7In
RleHQiOiJNYW5hICh0byBvYnRhaW4gbGlzdCBvZiBtYW5hKSIs
InN0YXJ0IjoxODY3LCJlbmQiOjE4OTZ9LCJXU1BQcGxQYkg4dH
BVNW83Ijp7InRleHQiOiIjIDUuMS41IEZQQyBvbiB0YW5nbGUi
LCJzdGFydCI6MTA0NzIsImVuZCI6MTA0OTN9LCI2bDdPRExlT2
ZGRWhva241Ijp7InRleHQiOiJTaW5jZSB0aGVyZSBhcmUgbm8g
c2ltdWxhdGlvbnMgeWV0LCBpdCBsYXkgYmUgZ29vZCB0byBydW
4gc29tZSB0byBjaGVjayBwZXJmb3Jt4oCmIiwic3RhcnQiOjEz
MjY3LCJlbmQiOjEzMzUyfSwiMDhtRjdPODZGNUdRR2RaayI6ey
J0ZXh0Ijoibm9kZSBnb3NzaXBzLCIsInN0YXJ0IjoxNDYxMCwi
ZW5kIjoxNDYyM30sInhhZ0xic3JmRXo4UUpXdkMiOnsidGV4dC
I6Ikl0IG1heSBzZXJ2ZSBvbiB2YXJpb3VzIG9udG9sb2dpZXMg
YXMgY29uc2Vuc3VzIHByb3RvY29sLiIsInN0YXJ0IjozNTcsIm
VuZCI6MzU4fSwiU0dqNUhSVXZDam5FcFFvZiI6eyJ0ZXh0Ijoi
dHJhbnNhY3Rpb24iLCJzdGFydCI6NDQ2LCJlbmQiOjQ1N30sIk
U3T0lSelVobjJpbG91OEEiOnsidGV4dCI6Im1lc3NhZ2UgY29t
cHJlc3Npb24gb2YgRlBDOiByZWR1Y2luZyBtZXNzYWdlIGNvbX
BsZXhpdHkgdGhyb3VnaCBtZXNzYWdlIGNvbXByZXPigKYiLCJz
dGFydCI6NTUxLCJlbmQiOjc1OH0sIldZWjFhV3hxSlVvQTZpY1
UiOnsidGV4dCI6IjQuIHByb3RvY29sIGludGVyZmFjZTogZGF0
YSBsYXllciBhbmQgdmFsdWUgbGF5ZXIuIFRoaXMgcGFydCBzcG
VjaWZpZXMgd2hlbiBGUEPigKYiLCJzdGFydCI6NzU5LCJlbmQi
OjEwMjh9LCJDQXlFdURGTkliVmtYQ1gzIjp7InRleHQiOiJSZX
N5bmNocm9uaXphdGlvbiBpbnRlcmZhY2U6IGlmIHByb3RvY29s
IGRvZXMgbm90IGF1dG8tdGVybWluYXRlIC0+IHJlc3luY2hyb2
5p4oCmIiwic3RhcnQiOjEwMzIsImVuZCI6MTExN30sImZydmpV
U3lKbEtQaEtERDgiOnsidGV4dCI6IkJlcnNlcmsgZGV0ZWN0aW
9uOiBtZWNoYW5pc20gdGhhdCBhbGxvd3MgdGhlIGRldGVjdGlv
biBvZiBCZXJzZXJrIGJlaGF2aW9yLiBUaGnigKYiLCJzdGFydC
I6MTEyMSwiZW5kIjoxNjIzfSwiRXN5U2dISHZjZm9pWmRXNSI6
eyJ0ZXh0IjoiIyA1LjEuMSBNb3RpdmF0aW9uIiwic3RhcnQiOj
E2MjksImVuZCI6MTY0N30sIjBoRkRQYTNBRFYyQ1FQSjciOnsi
dGV4dCI6IiMgNS4xLjIgRGVwZW5kZW5jaWVzIiwic3RhcnQiOj
E2NDksImVuZCI6MTY2OX0sIklKemk4eDBIMERvMHFjaEgiOnsi
dGV4dCI6IkZQQyBvbiB0YW5nbGUgaXMgZXNzZW50aWFsbHkgYS
Bjb25zZW5zdXMgb24gXCJ0aW1lXCIuIEF0IHZhcmlvdXMgcGFy
dHMgbG9jYWwgY2xvY+KApiIsInN0YXJ0IjoyMjM3LCJlbmQiOj
I1Nzl9LCI3MGFuZWMxbmtRdVFyakhKIjp7InRleHQiOiI5LiIs
InN0YXJ0IjoxNjI0LCJlbmQiOjE2MjZ9LCJpaVZyamdyUmhxR1
NFSlR1Ijp7InRleHQiOiJ0aHJlc2hvbGQiLCJzdGFydCI6MzMy
OSwiZW5kIjozMzM4fSwiOHZ1YUFvaEowNVh6bXJ0RiI6eyJ0ZX
h0IjoidGhpcyBoYXMgdG8gYmUgc3luY2hyb25pemVkICE/IEZv
ciBpbnN0YW5jZSwgYnkgdGhlIERSTkcsIG1heWJlIHN0YXJ0IH
dpdGggMTBzLOKApiIsInN0YXJ0IjozNzQ4LCJlbmQiOjM4Njl9
LCJqUkltYUlvNGZhNU1vNklZIjp7InRleHQiOiJzb21laG93IG
EgdGltZXIgdGhhdCBpcyB1cGRhdGVkIHBlcmlvZGljYWxseSwg
Y29ubmVjdGVkIHRvIGByb3VuZExlbmd0aGAgVEJEIiwic3Rhcn
QiOjM4ODQsImVuZCI6Mzk2MH0sIkh0UFRJWW9Nb3E0V29MMG8i
OnsidGV4dCI6IlRoZSBhYm92ZSB2YXJpYWJsZXMgY2FuIGluIH
RoZW9yeSBiZSBjaG9zZW4gbG9jYWxseSBmb3IgZWFjaCBub2Rl
LiBIb3dldmVyLCB0aGXigKYiLCJzdGFydCI6Mzk2MiwiZW5kIj
o0MTg1fSwiYldzTHM5cUh2RU4zaHVqRSI6eyJ0ZXh0IjoidmFy
aWFibGVzIiwic3RhcnQiOjQzMzgsImVuZCI6NDM0N30sIlRINT
RJdlJOSnJnQkMwZkUiOnsidGV4dCI6IiogYG1hbmFMaXN0YCBs
aXN0IG9mIG1hbmEgb2Ygbm9kZXNcbiogYG1hbmFgIGRvdWJsZS
AtIG1hbmEgb2Ygbm9kZSIsInN0YXJ0Ijo0Mzk5LCJlbmQiOjQ0
NjR9LCJKcndJanVLazlmUFNYaEJwIjp7InRleHQiOiJib29sZW
FuIC0gdHJhbnNhY3Rpb24gdHJ1ZSBvciBmYWxzZSIsInN0YXJ0
Ijo0NDc3LCJlbmQiOjQ1MTJ9LCJHWmFLRW9EQzByOTZ6QkUxIj
p7InRleHQiOiJUaGlzIGZ1bmN0aW9uIGRlcGVuZHMgb24gdGhl
IG9udG9sb2d5LiIsInN0YXJ0Ijo2MTU0LCJlbmQiOjYxOTJ9LC
I4d3J1V0o5YmJpZVVOVnozIjp7InRleHQiOiJOb3RlOiBlYWNo
IGxheWVyIiwic3RhcnQiOjYzMTEsImVuZCI6NjMyN30sImFDSk
s0b3Baa2FaZjRpTFciOnsidGV4dCI6ImBhPTAuNSwgYj0xLWJl
dGFgIiwic3RhcnQiOjEzMjQ4LCJlbmQiOjEzMjY1fX0sImNvbW
1lbnRzIjp7IjRoblJqT09XNEhpS01OdmoiOnsiZGlzY3Vzc2lv
bklkIjoiMFNWOGJoS3AxY05yQ1M3RSIsInN1YiI6ImdoOjUxMT
EyNjE4IiwidGV4dCI6InNuYXBzaG90dGVkIG1hbmEgdnMgYWx0
ZXJuYXRpdmVzIiwiY3JlYXRlZCI6MTU5NjUyMDMwNDcyNH0sIj
k4bzg0a21IMzREQWNjdWkiOnsiZGlzY3Vzc2lvbklkIjoiV1NQ
UHBsUGJIOHRwVTVvNyIsInN1YiI6ImdoOjUxMTEyNjE4IiwidG
V4dCI6IiEgVGhpcyBzZWN0aW9uIG1heSBjaGFuZ2UgKGlmIGZh
Y3QgYmUgZGVsZXRlZCkgIGluIHBhcmFsbGVsIHJlYWxpdHkgdW
5pdmVyc2UuIiwiY3JlYXRlZCI6MTU5NjUyMDg2OTU2MX0sImhx
RG0xRlNuRmVOam5ZTmwiOnsiZGlzY3Vzc2lvbklkIjoiNmw3T0
RMZU9mRkVob2tuNSIsInN1YiI6ImdoOjUxMTEyNjE4IiwidGV4
dCI6IkRvbmUgaW4gdGhlIG1lYW50aW1lLCBubyBiYWQgc3VycH
Jpc2VzIiwiY3JlYXRlZCI6MTU5NjUyMTExMTg5Nn0sIjZBRm5t
bU56MnVuR1JRRkoiOnsiZGlzY3Vzc2lvbklkIjoiMDhtRjdPOD
ZGNUdRR2RaayIsInN1YiI6ImdoOjUxMTEyNjE4IiwidGV4dCI6
IndlbGwgYXQgbGVhc3QgYW4gaW5kaWNhdGlvbiIsImNyZWF0ZW
QiOjE1OTY1MjEyNDE1MzF9LCJkYzZnOGRCV3dZZExDRVlYIjp7
ImRpc2N1c3Npb25JZCI6IjBTVjhiaEtwMWNOckNTN0UiLCJzdW
IiOiJnaDo1MTExMjYxOCIsInRleHQiOiJqdXN0IEZQQ01hbmEi
LCJjcmVhdGVkIjoxNTk2NTI5OTc3MTExfSwialFLU1NmbFo5Mn
hHdk1EeiI6eyJkaXNjdXNzaW9uSWQiOiJ4YWdMYnNyZkV6OFFK
V3ZDIiwic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZXh0IjoiUmVtb3
ZlIGFzIG9udG9sb2dpZXMgaW4gbmV2ZXIgY2xlYXIiLCJjcmVh
dGVkIjoxNTk3Nzc2OTI0NTQyfSwieW0wNzJ4Um1LVXllUVpwRC
I6eyJkaXNjdXNzaW9uSWQiOiJTR2o1SFJVdkNqbkVwUW9mIiwi
c3ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZXh0IjoiVHJhbnNhY3Rpb2
4gdnMgVmFsdWUgTWVzc2FnZT8iLCJjcmVhdGVkIjoxNTk3Nzc3
Mzg4MTQyfSwiQ1RQbEtGUGRWUmNPR0VnaiI6eyJkaXNjdXNzaW
9uSWQiOiJFN09JUnpVaG4yaWxvdThBIiwic3ViIjoiZ2g6Njgy
NTAzNTAiLCJ0ZXh0IjoiSW1jb21wbGV0ZSIsImNyZWF0ZWQiOj
E1OTc3NzgwMDkxMjB9LCI1eXVJeTZYVlhOZTBMYTA1Ijp7ImRp
c2N1c3Npb25JZCI6IldZWjFhV3hxSlVvQTZpY1UiLCJzdWIiOi
JnaDo2ODI1MDM1MCIsInRleHQiOiJJcyB0aGlzIDUuMj8iLCJj
cmVhdGVkIjoxNTk3Nzc4MTU0MDkwfSwiQnJid0ZUeHVCc2xBMz
JJdSI6eyJkaXNjdXNzaW9uSWQiOiJDQXlFdURGTkliVmtYQ1gz
Iiwic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZXh0IjoiVGhpcyBpcy
Bub3QgY292ZXJlZCBoZXJlLCBzaG91bGQgd2UgcmVmZXIgdG8g
NS40PyIsImNyZWF0ZWQiOjE1OTc3NzgxOTkyNzh9LCJualJETT
ZSbU1yWUp2eEEyIjp7ImRpc2N1c3Npb25JZCI6ImZydmpVU3lK
bEtQaEtERDgiLCJzdWIiOiJnaDo2ODI1MDM1MCIsInRleHQiOi
JBbGwgb2YgdGhpcyBpcyBpbmNvbXBsZXRlIiwiY3JlYXRlZCI6
MTU5Nzc3ODIxODgxN30sIjRnZGc1aWlMcU90ZGFBNHgiOnsiZG
lzY3Vzc2lvbklkIjoiRXN5U2dISHZjZm9pWmRXNSIsInN1YiI6
ImdoOjY4MjUwMzUwIiwidGV4dCI6IldpbGwgc29tZXRoaW5nIG
JlIHdyaXR0ZW4gaGVyZT8iLCJjcmVhdGVkIjoxNTk3Nzc4MjMz
ODU5fSwiWWFTQnJ5OE5WNHhuVUVyUyI6eyJkaXNjdXNzaW9uSW
QiOiIwaEZEUGEzQURWMkNRUEo3Iiwic3ViIjoiZ2g6NjgyNTAz
NTAiLCJ0ZXh0IjoiVGhpcyBzZWN0aW9uIHNob3VsIGVpdGhlci
BiZSBhdCBiZSBiZWdpbm5pbmcgb3Igc2tpcHBlZCBpbW8uIFRo
ZSBkZXBlbmRlbmNpZXMgc2hvdWxkIHVzZSB0aGUgcHJvcGVyIH
JlZmVyZW5jZSB3aGVudCBoZXkgYXBwZWFyLiIsImNyZWF0ZWQi
OjE1OTc3Nzg0NDQ5ODB9LCJBT1dQaEI0eFFlODYxUEtDIjp7Im
Rpc2N1c3Npb25JZCI6IklKemk4eDBIMERvMHFjaEgiLCJzdWIi
OiJnaDo2ODI1MDM1MCIsInRleHQiOiJTaG91bGQgd2Ugc2F5IH
NvbXRoaW5nIGFib3V0IHN5bmNocm9ub3VzIHZzIEFzeW5jaHJv
bm91cz8iLCJjcmVhdGVkIjoxNTk3Nzc4NTMzMjIxfSwiTWdNQ2
9ZbXRoenpZeXZLUiI6eyJkaXNjdXNzaW9uSWQiOiI3MGFuZWMx
bmtRdVFyakhKIiwic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZXh0Ij
oiR29zc2lwaW5nPyIsImNyZWF0ZWQiOjE1OTc3Nzg1NjQ5NzN9
LCI5ak5VMlo1MjZTNzM2UXg3Ijp7ImRpc2N1c3Npb25JZCI6Im
lpVnJqZ3JSaHFHU0VKVHUiLCJzdWIiOiJnaDo2ODI1MDM1MCIs
InRleHQiOiJUaHJlc2hvbGQgb2YgdGhlIHByb3BvcnRpb24gb2
Ygb3BpbmlvbnMiLCJjcmVhdGVkIjoxNTk3Nzc5NDMwOTYyfSwi
dkVIOHgxZjNjTjFoeG1rcCI6eyJkaXNjdXNzaW9uSWQiOiI4dn
VhQW9oSjA1WHptcnRGIiwic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0
ZXh0IjoiRGVsZXRlIHRoaXM/IiwiY3JlYXRlZCI6MTU5Nzc4Mj
k3NzczNH0sImd6Uzg2Y3Bqd2ZQUm84NGEiOnsiZGlzY3Vzc2lv
bklkIjoialJJbWFJbzRmYTVNbzZJWSIsInN1YiI6ImdoOjY4Mj
UwMzUwIiwidGV4dCI6Ik5vdCBDbGVhciIsImNyZWF0ZWQiOjE1
OTc3ODMxMTc2Njl9LCJZWHlubzlIdjlnTlJhMUNmIjp7ImRpc2
N1c3Npb25JZCI6Ikh0UFRJWW9Nb3E0V29MMG8iLCJzdWIiOiJn
aDo2ODI1MDM1MCIsInRleHQiOiJTbyBzaG91bGQgd2UgYWxsb3
cgdGhpcz8gSWYgbm90IHNob3VsZCB0aGlzIGJlIHNhaWQ/Iiwi
Y3JlYXRlZCI6MTU5Nzc4MzE3MjYyNH0sIlVxbEFHWkVDanpoNT
FNRUQiOnsiZGlzY3Vzc2lvbklkIjoiYldzTHM5cUh2RU4zaHVq
RSIsInN1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6IklzIHRoYX
QgdGhlIGJlc3Qgd29yZCB0byB1c2U/IEFzIGFuIGV4YW1wbGUg
XCJPcGluaW9uXCIgaXMgYSByZWxhdGlvbiBiZXR3ZWVuIG5vZG
UgYW5kIFRyYW5zYWN0aW9uLiBUaGlzIG1lYW5zIHRoZSBub2Rl
IGRvbnQgaGF2ZSBvbmUgT3BpbmlvbiwgYnV0IG9uZSBwZXIgdH
JhbnNhY3Rpb24uIiwiY3JlYXRlZCI6MTU5Nzc4Mzk1MTg3OH0s
IkducDhxMDF1bWZpVXU3ek4iOnsiZGlzY3Vzc2lvbklkIjoiVE
g1NEl2Uk5KcmdCQzBmRSIsInN1YiI6ImdoOjY4MjUwMzUwIiwi
dGV4dCI6IlNob3VsZCB0aGlzIGJlIHVwZGF0ZWQgd2l0aCB0aG
Uga2luZCBvZiBtYW5hPyIsImNyZWF0ZWQiOjE1OTc3ODM5ODM3
NzB9LCJrendCeXo0RUVrdUJvaTNHIjp7ImRpc2N1c3Npb25JZC
I6Ikpyd0lqdUtrOWZQU1hoQnAiLCJzdWIiOiJnaDo2ODI1MDM1
MCIsInRleHQiOiJJdHMgdHdpY2UgaW4gdGhlIGxpc3QiLCJjcm
VhdGVkIjoxNTk3NzgzOTk3ODYzfSwiYm9iZWtBcjRDd0VKOU1K
aSI6eyJkaXNjdXNzaW9uSWQiOiJHWmFLRW9EQzByOTZ6QkUxIi
wic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZXh0IjoiQ29uZnVzaW5n
IGFzIE9udG9sb2d5IGlzIG5vdCBkZWZpbmVkIiwiY3JlYXRlZC
I6MTU5Nzc4NDIwNDg4MH0sImN1eWc5SGVnMEdjVERTQUoiOnsi
ZGlzY3Vzc2lvbklkIjoiOHdydVdKOWJiaWVVTlZ6MyIsInN1Yi
I6ImdoOjY4MjUwMzUwIiwidGV4dCI6IkxheWVyIGlzIG5vdCB3
ZWxsIGRlZmluZWQiLCJjcmVhdGVkIjoxNTk3Nzk1NjcwNzc5fS
wiNUFlQjJaOTBwRHV4ZFBNbSI6eyJkaXNjdXNzaW9uSWQiOiJh
Q0pLNG9wWmthWmY0aUxXIiwic3ViIjoiZ2g6NjgyNTAzNTAiLC
J0ZXh0Ijoic3ltYm9scyBub3QgaW4gYWNjb3JkYW5jZSB0byB0
aGUgZGVmaW5lZCBwYXJhbWV0ZXJzIiwiY3JlYXRlZCI6MTU5Nz
c5NzQzMDQ2OX19LCJoaXN0b3J5IjpbLTY2MDc3OTQxNiwxNjA1
MzYwMjc3LC0zMDI2MjgzNDMsMTY0NzM5MTY2OCwtNDU2NjIzMT
IsMTMwODQyMzU3NSwxMDAzOTk5NTc2LC0xNTQxMjQ2MTM2LDk1
OTAxMjIxMywxMzM3NjQ5NzA0LDU0NjExMTAxOCwtNDM3NDg1Mz
M0LDQwNjE0NDk1NSw2MjMyNDE1NTIsMTM1NjE0ODY4LDg1MDAy
MzgzNywtMTMwNzYyNjYzXX0=
-->