+ Feature name:  FPC specifications
+ Start date: 2020-03-16

# 5.1 FPC specification


The module presented in this specification, FPC, allows nodes to find consensus on whether a transaction is valid or not. 

The specification will be subdivided into the following subsections:

1. **The core FPC protocol:** our basic consensus protocol on binary opinions. It may be used on different layers and kinds of messages. 
2. **FPC on Tangle:** opinions on transaction of the tangle become dependent. This parts specifies monotonicity and consistency rules.
3. **Message compression:** reducing message complexity through message compression and reducing overhead of demanded nodes by gossiping of opinions.
4. **Gossiping:**
5. **Protocol monitoring:** information every node store for monitoring the main net.
6. **Testing:** This section discusses how the protocol is tested. It subdivides into two parts: testing the logic and test behavior in Byzantine infrastructure.
 

# 5.1.1 Motivation


# 5.1.2 Remarks
The FPC on tangle is essentially a consensus mechanism on a time variable. At various parts local clocks will be used and compared to timestamps of messages. There are general standing assumption on network latency and clock synchronisations, in a nutshell, we consider that the differences in clocks are at least one order of magnitude lower than the network latency. 


# 5.1.3 The core FPC

The protocol tries to find consensus on the validity of a transaction `objectID`. Every node has an initial opinion `opinion`(boolean) on this transaction. These opinions are updated in rounds until the protocol terminates using a local stopping rule. 

## 5.1.3.1 Protocol variables

We define the type `Opinion`. 
```
Opinion: {
    DISLIKE: 0,
    LIKE: 1,
    NULL: NULL  #The node does not know about the object,
    NA : NA # a node does not receive an answer of the opinion of another node
}
```



* `FinalizationThreshold` integer - number of consecutive rounds before FPC auto-terminates
* `FinalizationThreshold2` integer - number of consecutive rounds with non-random threshold
* `FirstRoundThreshold`  double - threshold in first round
* `SubsequentRoundsLowerBoundThreshold` double -  lower random threshold bound in subsequent rounds
*  `SubsequentRoundsUpperBoundThreshold` double -  upper random threshold bound in subsequent rounds
* `maxRound` integer - maximal number of rounds before querying stops
* `querySize` integer - quorum size, number of nodes that are queries
* `roundLength` double - length (in sec) of a round, this has to be synchronized !? For instance, by the DRNG, maybe start with 10s, and FPC only uses DRNG every second round
* `timeOut` - somehow a timer that is updated periodically, connected to `roundLength` TBD

The above variables can in theory be chosen locally for each node. However, the security of the protocol depends on that they are chosen in a reasonable way. The best is if these variables are chosen the same for every node. The IF recommends to use the default values.

IF default/recommendation values are:

TO COME

## 5.1.3.2 Local variables

Every node has the following variables
* `opinion` Opinion
* `nodeList` list of all nodes
* `manaList` list of mana of nodes
* `mana` double - mana of node
* `opinion` boolean - transaction true or false
* `cnt` integer - counter that counts the number of consecutives rounds with unchanged opinion
* `queryStatus` boolean - status if actively querying
* `answerStatus` boolean - status if answerying queries, default value here is `TRUE`
* `round` integer - counts number of rounds in FPC
* `rn` double - random number from dRNG
* `rnCycle` double - random number instance (random numbers are produced at a certain period, this variable counts the current cycle) (-> connect to dRNG)
* `queryList`- list of nodes to query
* `opinionQuery` - list of opinion of nodes in `queryList`, nonreplies are encoded with `NA`
* `reachedMaxRound` boolean - indicating whether protocl reached `maxRound` before auto-termination, default calue `FALSE`
> [name=Sebastian Mueller] Present the above in a table?


## 5.1.3.3 Functions that are called
* `getIninitialOpinion` input: `objectID` output: opinion
* `getRN` input: `rnCycle` output: `rn`
* `getNodes` input:   output: `nodeList`
* `getMana` input: `nodeList` output: `manaList`
* `getSample` input: `querySize` `nodeList` `manaList` : output `queryList`
* `getOpinion` input: `objectID` `queryList` output: `opinionQuery`
* `checkQuerySuccessful` input: `queryList` `opinionQuery` output: `querySuccessful`: c*hecks whether `opinionQuery` from `getOpinion` contains enough answers*
*  `opinionUpdate` input: queryStatus output: `opinion` 
> [name=Sebastian Mueller] How do we write functions? Compare to https://hackmd.io/1oJWLLMPRmaA-GkgWJPi0Q.
## 5.1.3.4 Pseudocode 
 
Note: In the pseudocode at various places global variables are again used as input for the functions. 

### `getInitialOpinion`

This function depends on the ontology. 

### `getRN(layer, a, b, time)`
```
gets a uniform random number between (a,b),
to come, to be discussed with DRNG, 
Note: each layer may use a different random number

OUTPUT: randomThreshold, source of randomness
```

### `getNodes` 
This function should be defined somewhere in autopeering module?

### `getMana`

This function may be specified in Mana part


### `getSample(querySize, nodeList, manaList)`
```
queryList = empty
while (queryList does not contain querySize different element){
newSample:=Sample(nodeList, weight=mana, replacement=TRUE)
queryList = concat(queryList, newSample)
}
return queryList
```

### `getOpinion(queryList, timeOut)`

```
send queries to all nodes of queryList
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
return opinionQuery
```

### `checkQuerySuccessful(queryList, opinionQuery)`
```
# `manaMin` double - minimal mana of answers that have to arrive before new random number is issued  -> change to function
manaMin:=0.5 #at least 50% of the queried mana has to reply; this value may be changed
queriedMana := sum(manaList[queryList])
answerMana :=  sum(manaList[queryList[replied==TRUE]])/queriedMana
querySuccessful := ifElse( answerMana>= manaMin, TRUE, False)
return querySuccessful
```

### `sendOpinion(timeOut)`

```
answer queries that arrive before timeOut
```


### `opinionUpdate(layer, opinion, querySize, nodeList, manaList, FirstRoundThreshold, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)`
```
Sample :=getSample(querySize, nodeList, manaList)
opinionQuery := getOpinion(queryList, timeOut)
if (!checkQuerySuccessful(queryList, opinionQuery)){ #check if sufficiently many nodes replied in time
    newOpinion := opinion # if not keep old opinion 
}
else{ # otherwise update according to FPC rule
    etaStar := mean(opinionQuery, NA.remove=TRUE)
    totalMana := sum(listMana, NA.remove=TRUE) # remove nodes that did not answer
    eta := opinion*mana + etaStar*(totalMana-mana)/totalMana
    if (round == 1){ #first FPC round uses different threshold
        if (eta < FirstRoundThreshold){
            newOpinion <-0
        }
        else newOpinion <-1
    }
    else #the subsequent rounds (before the FinalizationThreshold2 confirming) use random threshold
        rn := getRN(layer, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, time)  # here we have to synchronize/wait for random number
        if (eta < rn){
            newOpinion <-0
        }
        else newOpinion <-1       
}

return newOpinion 
```


### `mainFPC(objectId, queryStatus)`
```
if (queryStatus turns TRUE ){ 
    opinion := getInitialOpinion(objectID)
    listMana := getMana()
    listNode := getNodes()
    cnt := 1
}
wait for new FPC round # next random number from dRNG
#start the first FPC round
round := 1 
opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, FirstRoundThreshold, ubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)
if (opinion==opinionNew) cnt++
else cnt:=0
opinion := opinionNew
round++

#continue FPC, subsequent rounds 
while queryStatus {
    if (cnt <= FinalizationThreshold-FinalizationThreshold2) # we use random threshold{
        opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, FirstRoundThreshold, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)
        if (opinion==opinionNew) cnt++
        else cnt:=0
        opinion := opinionNew
    }
    else {  # we use deterministic threshold for FinalizationThreshold2 "confirming" rounds
    opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, 0.5, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, 1, time)
        if (opinion==opinionNew) cnt++
        else cnt:=0
        opinion := opinionNew      
    }
    round++
    if (cnt==FinalizationThreshold) queryStatus:=FALSE
    if (round>=MaxRound) {
        queryStatus:=FALSE
        reachedMaxRound:=TRUE
    }
}
return(opinion)
```

## 5.1.3.5 Message/transaction layout


### Querying message

### Answering message
This is done in the next section.

# 5.1.4 FPC on tangle

In the tangle reality FPC may have to be applied to various messages simultaneously. Moreover, the tangle (the local view of every node) has to be monotone and consistent. We have to address the three following points:
* **Parallelity:** Many ongoing votings at the same time 
* **Consistency:** Layer should not contain contradicting messages
* **Monotonicity:** Liked  messages should not refer to disliked messages

## 5.1.4.1 Parallelity
At every round FPC decides on possibly several opinions. However, the every node will only query other nodes once (!). This is done for scalability. 

The local variable `opinions` records the vector of all opinions under vote. 

### `getInitialOpinions`

This function depends on the ontology and uses `getInitialOpinions` in a straightforward way.


### `getOpinions(queryList, timeOut)`
```
send queries to all nodes of queryList
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
return opinionsQuery
```
FPC is now applied for each opinion separately. This may not be optimal, but this is addressed in Section 3. It may that the outcome is not consistent or monotone. 


### single vs. multiple dRNG in each round

Discussion: using a different threshold for every opinion (e.g. hash(objectID) X hash(rn)) may lead to the following attack vector. If the number of votings is large then with high probability some of the will always have a random threshold close to 0.5, in other words for a random subset of tx there is no random threshold and hence the protocol is unsafe. 

Advantage of using the same random threshold is also that the two following functions have less to do, i.e., monotonicity and consistency is increased.

It may be good to use different random thresholds for the voting on different layers! (-> `getRN()`)

## 5.1.4.2 Consistency and Monotonicity

### `applyMonotonicityRule()`
```
functions that make temporary ledger state monoton, past cone of liked tx are like, future cones of disliked tx dislike, generalize these rules to level of knowledge -> Billy
```

### `applyConsistencyRule()`
```
functions that make temporary ledger state consistent
if two contradiction transaction are liked, choose the one with the higher mana (?)/ the previous favorite/ hash?
```
## 5.1.4.3 Data layer
FPC is used in the data layer to decide on the validity of the timestamp of a message. We can use here a symmetric range of the random threshold, `a=beta, b=1-beta`



## 5.1.4.4 Value layer
FPC decides in particular between two conflicting transaction, thresholds below 0.5 may lead to liking both transaction after voting. TO DISCUSS: asymmetric random threshold `a=0.5, b=1-beta`. Since there are no simulations yet, it lay be good to run some to check performances. 


# 5.1.5 Message compression of FPC


## 5.1.5.1 Compression in query messages
**Query:** reduce message identifier, e.g., Prefix trie or Cuckoo filter
**Answer:** Bitmask, respond in same order with 1bit per message

# 5.1.6 Gossiping
High mana nodes will be queried too often. They have the possibility to gossip their opinion. However, it is yet not clear who will  be allowed to gossip. 

### Everybody can gossip
This solution follows the idea that IOTA is all but freedom. Every node can decide on his own whether to gossip or not. Nevertheless, IF has to propose a reference implementation.

Advantages:
* if not in place, high mana nodes may be spammed by querries. But is this a reasonable concern for Coordicide 1.0?

Disadvantages: 
* local optimum may not be global optimum
* if all nodes gossip, network may reach congestion. But is this a reasonable concern for Coordicide 1.0?

### Threshold for gossiping

There is a global threshold, like the 100 top mana holders can gossip, the others are querying. However, mana perception is local and hence the threshold can't be sharp. 


### Proposal
TO DISCUSS
* every node is free to gossip
* nodes who gossip, close the port corresponding to queries, this allows other nodes to see whether this node gossips, 
* in IF reference implementation: if own mana perception is above a certain threshold, that would lead to overquery, then gossip

### Changes in the FPC protocol

Warning: the code may depend on the above decision who is going to gossip their opinion. 
### `getOpinions(queryList, timeOut)`
```
send queries to all nodes of queryList that do not gossip
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
read opinions from tangle of all to all nodes of queryList that do gossip

return opinionsQuery
```
Edge cases: what happens if gossiping node is queried? (Angelo: not reply at all, you even don t listen (close ports), Seb: be kind if possible).

If node has to gossip but is not?

# 5.1.7  Protocol monitoring




# 5.1.8 Testing

## 5.1.8.1 Edge cases

## 5.1.8.2 Spamming

## 5.1.8.3 Adversarial strategies

<!--stackedit_data:
eyJkaXNjdXNzaW9ucyI6eyIwU1Y4YmhLcDFjTnJDUzdFIjp7In
RleHQiOiJNYW5hICh0byBvYnRhaW4gbGlzdCBvZiBtYW5hKSIs
InN0YXJ0Ijo5OTQsImVuZCI6OTk0fSwiV1NQUHBsUGJIOHRwVT
VvNyI6eyJ0ZXh0IjoiIyA1LjEuNSBGUEMgb24gdGFuZ2xlIiwi
c3RhcnQiOjkyNzIsImVuZCI6OTI5M30sIjZsN09ETGVPZkZFaG
9rbjUiOnsidGV4dCI6IlNpbmNlIHRoZXJlIGFyZSBubyBzaW11
bGF0aW9ucyB5ZXQsIGl0IGxheSBiZSBnb29kIHRvIHJ1biBzb2
1lIHRvIGNoZWNrIHBlcmZvcm3igKYiLCJzdGFydCI6MTIwNjcs
ImVuZCI6MTIxNTJ9LCIwOG1GN084NkY1R1FHZFprIjp7InRleH
QiOiJub2RlIGdvc3NpcHMsIiwic3RhcnQiOjEzNDEwLCJlbmQi
OjEzNDIzfSwiMGhGRFBhM0FEVjJDUVBKNyI6eyJ0ZXh0IjoiIy
A1LjEuMiBEZXBlbmRlbmNpZXMiLCJzdGFydCI6OTk0LCJlbmQi
Ojk5NH0sImlpVnJqZ3JSaHFHU0VKVHUiOnsidGV4dCI6InRocm
VzaG9sZCIsInN0YXJ0IjoyMTI5LCJlbmQiOjIxMzh9LCI4dnVh
QW9oSjA1WHptcnRGIjp7InRleHQiOiJ0aGlzIGhhcyB0byBiZS
BzeW5jaHJvbml6ZWQgIT8gRm9yIGluc3RhbmNlLCBieSB0aGUg
RFJORywgbWF5YmUgc3RhcnQgd2l0aCAxMHMs4oCmIiwic3Rhcn
QiOjI1NDgsImVuZCI6MjY2OX0sImpSSW1hSW80ZmE1TW82SVki
OnsidGV4dCI6InNvbWVob3cgYSB0aW1lciB0aGF0IGlzIHVwZG
F0ZWQgcGVyaW9kaWNhbGx5LCBjb25uZWN0ZWQgdG8gYHJvdW5k
TGVuZ3RoYCBUQkQiLCJzdGFydCI6MjY4NCwiZW5kIjoyNzYwfS
wiSHRQVElZb01vcTRXb0wwbyI6eyJ0ZXh0IjoiVGhlIGFib3Zl
IHZhcmlhYmxlcyBjYW4gaW4gdGhlb3J5IGJlIGNob3NlbiBsb2
NhbGx5IGZvciBlYWNoIG5vZGUuIEhvd2V2ZXIsIHRoZeKApiIs
InN0YXJ0IjoyNzYyLCJlbmQiOjI5ODV9LCJiV3NMczlxSHZFTj
NodWpFIjp7InRleHQiOiJ2YXJpYWJsZXMiLCJzdGFydCI6MzEz
OCwiZW5kIjozMTQ3fSwiVEg1NEl2Uk5KcmdCQzBmRSI6eyJ0ZX
h0IjoiKiBgbWFuYUxpc3RgIGxpc3Qgb2YgbWFuYSBvZiBub2Rl
c1xuKiBgbWFuYWAgZG91YmxlIC0gbWFuYSBvZiBub2RlIiwic3
RhcnQiOjMxOTksImVuZCI6MzI2NH0sIkpyd0lqdUtrOWZQU1ho
QnAiOnsidGV4dCI6ImJvb2xlYW4gLSB0cmFuc2FjdGlvbiB0cn
VlIG9yIGZhbHNlIiwic3RhcnQiOjMyNzcsImVuZCI6MzMxMn0s
IkdaYUtFb0RDMHI5NnpCRTEiOnsidGV4dCI6IlRoaXMgZnVuY3
Rpb24gZGVwZW5kcyBvbiB0aGUgb250b2xvZ3kuIiwic3RhcnQi
OjQ5NTQsImVuZCI6NDk5Mn0sIjh3cnVXSjliYmllVU5WejMiOn
sidGV4dCI6Ik5vdGU6IGVhY2ggbGF5ZXIiLCJzdGFydCI6NTEx
MSwiZW5kIjo1MTI3fSwiYUNKSzRvcFprYVpmNGlMVyI6eyJ0ZX
h0IjoiYGE9MC41LCBiPTEtYmV0YWAiLCJzdGFydCI6MTIwNDgs
ImVuZCI6MTIwNjV9fSwiY29tbWVudHMiOnsiNGhuUmpPT1c0SG
lLTU52aiI6eyJkaXNjdXNzaW9uSWQiOiIwU1Y4YmhLcDFjTnJD
UzdFIiwic3ViIjoiZ2g6NTExMTI2MTgiLCJ0ZXh0Ijoic25hcH
Nob3R0ZWQgbWFuYSB2cyBhbHRlcm5hdGl2ZXMiLCJjcmVhdGVk
IjoxNTk2NTIwMzA0NzI0fSwiOThvODRrbUgzNERBY2N1aSI6ey
JkaXNjdXNzaW9uSWQiOiJXU1BQcGxQYkg4dHBVNW83Iiwic3Vi
IjoiZ2g6NTExMTI2MTgiLCJ0ZXh0IjoiISBUaGlzIHNlY3Rpb2
4gbWF5IGNoYW5nZSAoaWYgZmFjdCBiZSBkZWxldGVkKSAgaW4g
cGFyYWxsZWwgcmVhbGl0eSB1bml2ZXJzZS4iLCJjcmVhdGVkIj
oxNTk2NTIwODY5NTYxfSwiaHFEbTFGU25GZU5qbllObCI6eyJk
aXNjdXNzaW9uSWQiOiI2bDdPRExlT2ZGRWhva241Iiwic3ViIj
oiZ2g6NTExMTI2MTgiLCJ0ZXh0IjoiRG9uZSBpbiB0aGUgbWVh
bnRpbWUsIG5vIGJhZCBzdXJwcmlzZXMiLCJjcmVhdGVkIjoxNT
k2NTIxMTExODk2fSwiNkFGbm1tTnoydW5HUlFGSiI6eyJkaXNj
dXNzaW9uSWQiOiIwOG1GN084NkY1R1FHZFprIiwic3ViIjoiZ2
g6NTExMTI2MTgiLCJ0ZXh0Ijoid2VsbCBhdCBsZWFzdCBhbiBp
bmRpY2F0aW9uIiwiY3JlYXRlZCI6MTU5NjUyMTI0MTUzMX0sIm
RjNmc4ZEJXd1lkTENFWVgiOnsiZGlzY3Vzc2lvbklkIjoiMFNW
OGJoS3AxY05yQ1M3RSIsInN1YiI6ImdoOjUxMTEyNjE4IiwidG
V4dCI6Imp1c3QgRlBDTWFuYSIsImNyZWF0ZWQiOjE1OTY1Mjk5
NzcxMTF9LCJZYVNCcnk4TlY0eG5VRXJTIjp7ImRpc2N1c3Npb2
5JZCI6IjBoRkRQYTNBRFYyQ1FQSjciLCJzdWIiOiJnaDo2ODI1
MDM1MCIsInRleHQiOiJUaGlzIHNlY3Rpb24gc2hvdWwgZWl0aG
VyIGJlIGF0IGJlIGJlZ2lubmluZyBvciBza2lwcGVkIGltby4g
VGhlIGRlcGVuZGVuY2llcyBzaG91bGQgdXNlIHRoZSBwcm9wZX
IgcmVmZXJlbmNlIHdoZW50IGhleSBhcHBlYXIuIiwiY3JlYXRl
ZCI6MTU5Nzc3ODQ0NDk4MH0sIjlqTlUyWjUyNlM3MzZReDciOn
siZGlzY3Vzc2lvbklkIjoiaWlWcmpnclJocUdTRUpUdSIsInN1
YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6IlRocmVzaG9sZCBvZi
B0aGUgcHJvcG9ydGlvbiBvZiBvcGluaW9ucyIsImNyZWF0ZWQi
OjE1OTc3Nzk0MzA5NjJ9LCJ2RUg4eDFmM2NOMWh4bWtwIjp7Im
Rpc2N1c3Npb25JZCI6Ijh2dWFBb2hKMDVYem1ydEYiLCJzdWIi
OiJnaDo2ODI1MDM1MCIsInRleHQiOiJEZWxldGUgdGhpcz8iLC
JjcmVhdGVkIjoxNTk3NzgyOTc3NzM0fSwiZ3pTODZjcGp3ZlBS
bzg0YSI6eyJkaXNjdXNzaW9uSWQiOiJqUkltYUlvNGZhNU1vNk
lZIiwic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZXh0IjoiTm90IENs
ZWFyIiwiY3JlYXRlZCI6MTU5Nzc4MzExNzY2OX0sIllYeW5vOU
h2OWdOUmExQ2YiOnsiZGlzY3Vzc2lvbklkIjoiSHRQVElZb01v
cTRXb0wwbyIsInN1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6Il
NvIHNob3VsZCB3ZSBhbGxvdyB0aGlzPyBJZiBub3Qgc2hvdWxk
IHRoaXMgYmUgc2FpZD8iLCJjcmVhdGVkIjoxNTk3NzgzMTcyNj
I0fSwiVXFsQUdaRUNqemg1MU1FRCI6eyJkaXNjdXNzaW9uSWQi
OiJiV3NMczlxSHZFTjNodWpFIiwic3ViIjoiZ2g6NjgyNTAzNT
AiLCJ0ZXh0IjoiSXMgdGhhdCB0aGUgYmVzdCB3b3JkIHRvIHVz
ZT8gQXMgYW4gZXhhbXBsZSBcIk9waW5pb25cIiBpcyBhIHJlbG
F0aW9uIGJldHdlZW4gbm9kZSBhbmQgVHJhbnNhY3Rpb24uIFRo
aXMgbWVhbnMgdGhlIG5vZGUgZG9udCBoYXZlIG9uZSBPcGluaW
9uLCBidXQgb25lIHBlciB0cmFuc2FjdGlvbi4iLCJjcmVhdGVk
IjoxNTk3NzgzOTUxODc4fSwiR25wOHEwMXVtZmlVdTd6TiI6ey
JkaXNjdXNzaW9uSWQiOiJUSDU0SXZSTkpyZ0JDMGZFIiwic3Vi
IjoiZ2g6NjgyNTAzNTAiLCJ0ZXh0IjoiU2hvdWxkIHRoaXMgYm
UgdXBkYXRlZCB3aXRoIHRoZSBraW5kIG9mIG1hbmE/IiwiY3Jl
YXRlZCI6MTU5Nzc4Mzk4Mzc3MH0sImt6d0J5ejRFRWt1Qm9pM0
ciOnsiZGlzY3Vzc2lvbklkIjoiSnJ3SWp1S2s5ZlBTWGhCcCIs
InN1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6Ikl0cyB0d2ljZS
BpbiB0aGUgbGlzdCIsImNyZWF0ZWQiOjE1OTc3ODM5OTc4NjN9
LCJib2Jla0FyNEN3RUo5TUppIjp7ImRpc2N1c3Npb25JZCI6Ik
daYUtFb0RDMHI5NnpCRTEiLCJzdWIiOiJnaDo2ODI1MDM1MCIs
InRleHQiOiJDb25mdXNpbmcgYXMgT250b2xvZ3kgaXMgbm90IG
RlZmluZWQiLCJjcmVhdGVkIjoxNTk3Nzg0MjA0ODgwfSwiY3V5
ZzlIZWcwR2NURFNBSiI6eyJkaXNjdXNzaW9uSWQiOiI4d3J1V0
o5YmJpZVVOVnozIiwic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZXh0
IjoiTGF5ZXIgaXMgbm90IHdlbGwgZGVmaW5lZCIsImNyZWF0ZW
QiOjE1OTc3OTU2NzA3Nzl9LCI1QWVCMlo5MHBEdXhkUE1tIjp7
ImRpc2N1c3Npb25JZCI6ImFDSks0b3Baa2FaZjRpTFciLCJzdW
IiOiJnaDo2ODI1MDM1MCIsInRleHQiOiJzeW1ib2xzIG5vdCBp
biBhY2NvcmRhbmNlIHRvIHRoZSBkZWZpbmVkIHBhcmFtZXRlcn
MiLCJjcmVhdGVkIjoxNTk3Nzk3NDMwNDY5fX0sImhpc3Rvcnki
OlstMjE0NjQ5NTc1MywtNDgyMjIxNDgsMTYwNTM2MDI3NywtMz
AyNjI4MzQzLDE2NDczOTE2NjgsLTQ1NjYyMzEyLDEzMDg0MjM1
NzUsMTAwMzk5OTU3NiwtMTU0MTI0NjEzNiw5NTkwMTIyMTMsMT
MzNzY0OTcwNCw1NDYxMTEwMTgsLTQzNzQ4NTMzNCw0MDYxNDQ5
NTUsNjIzMjQxNTUyLDEzNTYxNDg2OCw4NTAwMjM4MzcsLTEzMD
c2MjY2M119
-->