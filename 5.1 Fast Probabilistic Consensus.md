+ Feature name:  FPC specifications
+ Start date: 2020-03-16

# 5.1 FPC specification


The module presented in this specification, FPC, allows nodes to find consensus on whether a transaction is valid or not. 

The specification will be subdivided into the following subsections:

1. **The core FPC protocol:** our basic consensus protocol on binary opinions. It may be used on different layers and kinds of messages. 
2. **FPC on Tangle:** opinions on transaction of the tangle become dependent. This parts specifies monotonicity and consistency rules.
3. **Message compression:** reducing message complexity through message compression and reducing overhead of demanded nodes by gossiping of opinions.
4. **Gossiping:**
5. **Protocol monitoring:** information every node store for monitoring the main net.
6. **Testing:** This section discusses how the protocol is tested. It subdivides into two parts: testing the logic and test behavior in Byzantine infrastructure.
 

# 5.1.1 Motivation


# 5.1.2 Remarks
The FPC on tangle is essentially a consensus on "time". At various parts local clocks will be used and compared to timestamps of messages. There are general standing assumption on network latency and clock synchronizations. In a nutshell, they are that the differences in clocks are at least one order of magnitude lower than the network latency. 


# 5.1.3 The core FPC

The protocol tries to find consensus on the validity of a transaction `objectID`. Every node has an initial opinion `opinion`(boolean) on this transaction. These opinions are updated in rounds until the protocol terminates using a local stopping rule. 

## 5.1.3.1 Protocol variables

We define the type `Opinion`. 
```
Opinion: {
    DISLIKE: 0,
    LIKE: 1,
    NULL: NULL  #The node does not know about the object,
    NA : NA # a node does not receive an answer of the opinion of another node
}
```



* `FinalizationThreshold` integer - number of consecutive rounds before FPC auto-terminates
* `FinalizationThreshold2` integer - number of consecutive rounds with non-random threshold
* `FirstRoundThreshold`  double - threshold in first round
* `SubsequentRoundsLowerBoundThreshold` double -  lower random threshold bound in subsequent rounds
*  `SubsequentRoundsUpperBoundThreshold` double -  upper random threshold bound in subsequent rounds
* `maxRound` integer - maximal number of rounds before querying stops
* `querySize` integer - quorum size, number of nodes that are queries
* `roundLength` double - length (in sec) of a round, this has to be synchronized !? For instance, by the DRNG, maybe start with 10s, and FPC only uses DRNG every second round
* `timeOut` - somehow a timer that is updated periodically, connected to `roundLength` TBD

The above variables can in theory be chosen locally for each node. However, the security of the protocol depends on that they are chosen in a reasonable way. The best is if these variables are chosen the same for every node. The IF recommends to use the default values.

IF default/recommendation values are:

TO COME

## 5.1.3.2 Local variables

Every node has the following variables
* `opinion` Opinion
* `nodeList` list of all nodes
* `manaList` list of mana of nodes
* `mana` double - mana of node
* `opinion` boolean - transaction true or false
* `cnt` integer - counter that counts the number of consecutives rounds with unchanged opinion
* `queryStatus` boolean - status if actively querying
* `answerStatus` boolean - status if answerying queries, default value here is `TRUE`
* `round` integer - counts number of rounds in FPC
* `rn` double - random number from dRNG
* `rnCycle` double - random number instance (random numbers are produced at a certain period, this variable counts the current cycle) (-> connect to dRNG)
* `queryList`- list of nodes to query
* `opinionQuery` - list of opinion of nodes in `queryList`, nonreplies are encoded with `NA`
* `reachedMaxRound` boolean - indicating whether protocl reached `maxRound` before auto-termination, default calue `FALSE`
> [name=Sebastian Mueller] Present the above in a table?


## 5.1.3.3 Functions that are called
* `getIninitialOpinion` input: `objectID` output: opinion
* `getRN` input: `rnCycle` output: `rn`
* `getNodes` input:   output: `nodeList`
* `getMana` input: `nodeList` output: `manaList`
* `getSample` input: `querySize` `nodeList` `manaList` : output `queryList`
* `getOpinion` input: `objectID` `queryList` output: `opinionQuery`
* `checkQuerySuccessful` input: `queryList` `opinionQuery` output: `querySuccessful`: c*hecks whether `opinionQuery` from `getOpinion` contains enough answers*
*  `opinionUpdate` input: queryStatus output: `opinion` 
> [name=Sebastian Mueller] How do we write functions? Compare to https://hackmd.io/1oJWLLMPRmaA-GkgWJPi0Q.
## 5.1.3.4 Pseudocode 
 
Note: In the pseudocode at various places global variables are again used as input for the functions. 

### `getInitialOpinion`

This function depends on the ontology. 

### `getRN(layer, a, b, time)`
```
gets a uniform random number between (a,b),
to come, to be discussed with DRNG, 
Note: each layer may use a different random number

OUTPUT: randomThreshold, source of randomness
```

### `getNodes` 
This function should be defined somewhere in autopeering module?

### `getMana`

This function may be specified in Mana part


### `getSample(querySize, nodeList, manaList)`
```
queryList = empty
while (queryList does not contain querySize different element){
newSample:=Sample(nodeList, weight=mana, replacement=TRUE)
queryList = concat(queryList, newSample)
}
return queryList
```

### `getOpinion(queryList, timeOut)`

```
send queries to all nodes of queryList
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
return opinionQuery
```

### `checkQuerySuccessful(queryList, opinionQuery)`
```
# `manaMin` double - minimal mana of answers that have to arrive before new random number is issued  -> change to function
manaMin:=0.5 #at least 50% of the queried mana has to reply; this value may be changed
queriedMana := sum(manaList[queryList])
answerMana :=  sum(manaList[queryList[replied==TRUE]])/queriedMana
querySuccessful := ifElse( answerMana>= manaMin, TRUE, False)
return querySuccessful
```

### `sendOpinion(timeOut)`

```
answer queries that arrive before timeOut
```


### `opinionUpdate(layer, opinion, querySize, nodeList, manaList, FirstRoundThreshold, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)`
```
Sample :=getSample(querySize, nodeList, manaList)
opinionQuery := getOpinion(queryList, timeOut)
if (!checkQuerySuccessful(queryList, opinionQuery)){ #check if sufficiently many nodes replied in time
    newOpinion := opinion # if not keep old opinion 
}
else{ # otherwise update according to FPC rule
    etaStar := mean(opinionQuery, NA.remove=TRUE)
    totalMana := sum(listMana, NA.remove=TRUE) # remove nodes that did not answer
    eta := opinion*mana + etaStar*(totalMana-mana)/totalMana
    if (round == 1){ #first FPC round uses different threshold
        if (eta < FirstRoundThreshold){
            newOpinion <-0
        }
        else newOpinion <-1
    }
    else #the subsequent rounds (before the FinalizationThreshold2 confirming) use random threshold
        rn := getRN(layer, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, time)  # here we have to synchronize/wait for random number
        if (eta < rn){
            newOpinion <-0
        }
        else newOpinion <-1       
}

return newOpinion 
```


### `mainFPC(objectId, queryStatus)`
```
if (queryStatus turns TRUE ){ 
    opinion := getInitialOpinion(objectID)
    listMana := getMana()
    listNode := getNodes()
    cnt := 1
}
wait for new FPC round # next random number from dRNG
#start the first FPC round
round := 1 
opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, FirstRoundThreshold, ubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)
if (opinion==opinionNew) cnt++
else cnt:=0
opinion := opinionNew
round++

#continue FPC, subsequent rounds 
while queryStatus {
    if (cnt <= FinalizationThreshold-FinalizationThreshold2) # we use random threshold{
        opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, FirstRoundThreshold, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)
        if (opinion==opinionNew) cnt++
        else cnt:=0
        opinion := opinionNew
    }
    else {  # we use deterministic threshold for FinalizationThreshold2 "confirming" rounds
    opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, 0.5, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, 1, time)
        if (opinion==opinionNew) cnt++
        else cnt:=0
        opinion := opinionNew      
    }
    round++
    if (cnt==FinalizationThreshold) queryStatus:=FALSE
    if (round>=MaxRound) {
        queryStatus:=FALSE
        reachedMaxRound:=TRUE
    }
}
return(opinion)
```

## 5.1.3.5 Message/transaction layout


### Querying message

### Answering message
This is done in the next section.

# 5.1.4 FPC on tangle

In the tangle reality FPC may have to be applied to various messages simultaneously. Moreover, the tangle (the local view of every node) has to be monotone and consistent. We have to address the three following points:
* **Parallelity:** Many ongoing votings at the same time 
* **Consistency:** Layer should not contain contradicting messages
* **Monotonicity:** Liked  messages should not refer to disliked messages

## 5.1.4.1 Parallelity
At every round FPC decides on possibly several opinions. However, the every node will only query other nodes once (!). This is done for scalability. 

The local variable `opinions` records the vector of all opinions under vote. 

### `getInitialOpinions`

This function depends on the ontology and uses `getInitialOpinions` in a straightforward way.


### `getOpinions(queryList, timeOut)`
```
send queries to all nodes of queryList
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
return opinionsQuery
```
FPC is now applied for each opinion separately. This may not be optimal, but this is addressed in Section 3. It may that the outcome is not consistent or monotone. 


### single vs. multiple dRNG in each round

Discussion: using a different threshold for every opinion (e.g. hash(objectID) X hash(rn)) may lead to the following attack vector. If the number of votings is large then with high probability some of the will always have a random threshold close to 0.5, in other words for a random subset of tx there is no random threshold and hence the protocol is unsafe. 

Advantage of using the same random threshold is also that the two following functions have less to do, i.e., monotonicity and consistency is increased.

It may be good to use different random thresholds for the voting on different layers! (-> `getRN()`)

## 5.1.4.2 Consistency and Monotonicity

### `applyMonotonicityRule()`
```
functions that make temporary ledger state monoton, past cone of liked tx are like, future cones of disliked tx dislike, generalize these rules to level of knowledge -> Billy
```

### `applyConsistencyRule()`
```
functions that make temporary ledger state consistent
if two contradiction transaction are liked, choose the one with the higher mana (?)/ the previous favorite/ hash?
```
## 5.1.4.3 Data layer
FPC is used in the data layer to decide on the validity of the timestamp of a message. We can use here a symmetric range of the random threshold, `a=beta, b=1-beta`



## 5.1.4.4 Value layer
FPC decides in particular between two conflicting transaction, thresholds below 0.5 may lead to liking both transaction after voting. TO DISCUSS: asymmetric random threshold `a=0.5, b=1-beta`. Since there are no simulations yet, it lay be good to run some to check performances. 


# 5.1.5 Message compression of FPC


## 5.1.5.1 Compression in query messages
**Query:** reduce message identifier, e.g., Prefix trie or Cuckoo filter
**Answer:** Bitmask, respond in same order with 1bit per message

# 5.1.6 Gossiping
High mana nodes will be queried too often. They have the possibility to gossip their opinion. However, it is yet not clear who will  be allowed to gossip. 

### Everybody can gossip
This solution follows the idea that IOTA is all but freedom. Every node can decide on his own whether to gossip or not. Nevertheless, IF has to propose a reference implementation.

Advantages:
* if not in place, high mana nodes may be spammed by querries. But is this a reasonable concern for Coordicide 1.0?

Disadvantages: 
* local optimum may not be global optimum
* if all nodes gossip, network may reach congestion. But is this a reasonable concern for Coordicide 1.0?

### Threshold for gossiping

There is a global threshold, like the 100 top mana holders can gossip, the others are querying. However, mana perception is local and hence the threshold can't be sharp. 


### Proposal
TO DISCUSS
* every node is free to gossip
* nodes who gossip, close the port corresponding to queries, this allows other nodes to see whether this node gossips, 
* in IF reference implementation: if own mana perception is above a certain threshold, that would lead to overquery, then gossip

### Changes in the FPC protocol

Warning: the code may depend on the above decision who is going to gossip their opinion. 
### `getOpinions(queryList, timeOut)`
```
send queries to all nodes of queryList that do not gossip
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
read opinions from tangle of all to all nodes of queryList that do gossip

return opinionsQuery
```
Edge cases: what happens if gossiping node is queried? (Angelo: not reply at all, you even don t listen (close ports), Seb: be kind if possible).

If node has to gossip but is not?

# 5.1.7  Protocol monitoring




# 5.1.8 Testing

## 5.1.8.1 Edge cases

## 5.1.8.2 Spamming

## 5.1.8.3 Adversarial strategies

<!--stackedit_data:
eyJkaXNjdXNzaW9ucyI6eyIwU1Y4YmhLcDFjTnJDUzdFIjp7In
RleHQiOiJNYW5hICh0byBvYnRhaW4gbGlzdCBvZiBtYW5hKSIs
InN0YXJ0Ijo5OTQsImVuZCI6OTk0fSwiV1NQUHBsUGJIOHRwVT
VvNyI6eyJ0ZXh0IjoiIyA1LjEuNSBGUEMgb24gdGFuZ2xlIiwi
c3RhcnQiOjkyNTAsImVuZCI6OTI3MX0sIjZsN09ETGVPZkZFaG
9rbjUiOnsidGV4dCI6IlNpbmNlIHRoZXJlIGFyZSBubyBzaW11
bGF0aW9ucyB5ZXQsIGl0IGxheSBiZSBnb29kIHRvIHJ1biBzb2
1lIHRvIGNoZWNrIHBlcmZvcm3igKYiLCJzdGFydCI6MTIwNDUs
ImVuZCI6MTIxMzB9LCIwOG1GN084NkY1R1FHZFprIjp7InRleH
QiOiJub2RlIGdvc3NpcHMsIiwic3RhcnQiOjEzMzg4LCJlbmQi
OjEzNDAxfSwiMGhGRFBhM0FEVjJDUVBKNyI6eyJ0ZXh0IjoiIy
A1LjEuMiBEZXBlbmRlbmNpZXMiLCJzdGFydCI6OTk0LCJlbmQi
Ojk5NH0sIklKemk4eDBIMERvMHFjaEgiOnsidGV4dCI6IkZQQy
BvbiB0YW5nbGUgaXMgZXNzZW50aWFsbHkgYSBjb25zZW5zdXMg
b24gXCJ0aW1lXCIuIEF0IHZhcmlvdXMgcGFydHMgbG9jYWwgY2
xvY+KApiIsInN0YXJ0IjoxMDE1LCJlbmQiOjEzNTd9LCJpaVZy
amdyUmhxR1NFSlR1Ijp7InRleHQiOiJ0aHJlc2hvbGQiLCJzdG
FydCI6MjEwNywiZW5kIjoyMTE2fSwiOHZ1YUFvaEowNVh6bXJ0
RiI6eyJ0ZXh0IjoidGhpcyBoYXMgdG8gYmUgc3luY2hyb25pem
VkICE/IEZvciBpbnN0YW5jZSwgYnkgdGhlIERSTkcsIG1heWJl
IHN0YXJ0IHdpdGggMTBzLOKApiIsInN0YXJ0IjoyNTI2LCJlbm
QiOjI2NDd9LCJqUkltYUlvNGZhNU1vNklZIjp7InRleHQiOiJz
b21laG93IGEgdGltZXIgdGhhdCBpcyB1cGRhdGVkIHBlcmlvZG
ljYWxseSwgY29ubmVjdGVkIHRvIGByb3VuZExlbmd0aGAgVEJE
Iiwic3RhcnQiOjI2NjIsImVuZCI6MjczOH0sIkh0UFRJWW9Nb3
E0V29MMG8iOnsidGV4dCI6IlRoZSBhYm92ZSB2YXJpYWJsZXMg
Y2FuIGluIHRoZW9yeSBiZSBjaG9zZW4gbG9jYWxseSBmb3IgZW
FjaCBub2RlLiBIb3dldmVyLCB0aGXigKYiLCJzdGFydCI6Mjc0
MCwiZW5kIjoyOTYzfSwiYldzTHM5cUh2RU4zaHVqRSI6eyJ0ZX
h0IjoidmFyaWFibGVzIiwic3RhcnQiOjMxMTYsImVuZCI6MzEy
NX0sIlRINTRJdlJOSnJnQkMwZkUiOnsidGV4dCI6IiogYG1hbm
FMaXN0YCBsaXN0IG9mIG1hbmEgb2Ygbm9kZXNcbiogYG1hbmFg
IGRvdWJsZSAtIG1hbmEgb2Ygbm9kZSIsInN0YXJ0IjozMTc3LC
JlbmQiOjMyNDJ9LCJKcndJanVLazlmUFNYaEJwIjp7InRleHQi
OiJib29sZWFuIC0gdHJhbnNhY3Rpb24gdHJ1ZSBvciBmYWxzZS
IsInN0YXJ0IjozMjU1LCJlbmQiOjMyOTB9LCJHWmFLRW9EQzBy
OTZ6QkUxIjp7InRleHQiOiJUaGlzIGZ1bmN0aW9uIGRlcGVuZH
Mgb24gdGhlIG9udG9sb2d5LiIsInN0YXJ0Ijo0OTMyLCJlbmQi
OjQ5NzB9LCI4d3J1V0o5YmJpZVVOVnozIjp7InRleHQiOiJOb3
RlOiBlYWNoIGxheWVyIiwic3RhcnQiOjUwODksImVuZCI6NTEw
NX0sImFDSks0b3Baa2FaZjRpTFciOnsidGV4dCI6ImBhPTAuNS
wgYj0xLWJldGFgIiwic3RhcnQiOjEyMDI2LCJlbmQiOjEyMDQz
fX0sImNvbW1lbnRzIjp7IjRoblJqT09XNEhpS01OdmoiOnsiZG
lzY3Vzc2lvbklkIjoiMFNWOGJoS3AxY05yQ1M3RSIsInN1YiI6
ImdoOjUxMTEyNjE4IiwidGV4dCI6InNuYXBzaG90dGVkIG1hbm
EgdnMgYWx0ZXJuYXRpdmVzIiwiY3JlYXRlZCI6MTU5NjUyMDMw
NDcyNH0sIjk4bzg0a21IMzREQWNjdWkiOnsiZGlzY3Vzc2lvbk
lkIjoiV1NQUHBsUGJIOHRwVTVvNyIsInN1YiI6ImdoOjUxMTEy
NjE4IiwidGV4dCI6IiEgVGhpcyBzZWN0aW9uIG1heSBjaGFuZ2
UgKGlmIGZhY3QgYmUgZGVsZXRlZCkgIGluIHBhcmFsbGVsIHJl
YWxpdHkgdW5pdmVyc2UuIiwiY3JlYXRlZCI6MTU5NjUyMDg2OT
U2MX0sImhxRG0xRlNuRmVOam5ZTmwiOnsiZGlzY3Vzc2lvbklk
IjoiNmw3T0RMZU9mRkVob2tuNSIsInN1YiI6ImdoOjUxMTEyNj
E4IiwidGV4dCI6IkRvbmUgaW4gdGhlIG1lYW50aW1lLCBubyBi
YWQgc3VycHJpc2VzIiwiY3JlYXRlZCI6MTU5NjUyMTExMTg5Nn
0sIjZBRm5tbU56MnVuR1JRRkoiOnsiZGlzY3Vzc2lvbklkIjoi
MDhtRjdPODZGNUdRR2RaayIsInN1YiI6ImdoOjUxMTEyNjE4Ii
widGV4dCI6IndlbGwgYXQgbGVhc3QgYW4gaW5kaWNhdGlvbiIs
ImNyZWF0ZWQiOjE1OTY1MjEyNDE1MzF9LCJkYzZnOGRCV3dZZE
xDRVlYIjp7ImRpc2N1c3Npb25JZCI6IjBTVjhiaEtwMWNOckNT
N0UiLCJzdWIiOiJnaDo1MTExMjYxOCIsInRleHQiOiJqdXN0IE
ZQQ01hbmEiLCJjcmVhdGVkIjoxNTk2NTI5OTc3MTExfSwiWWFT
QnJ5OE5WNHhuVUVyUyI6eyJkaXNjdXNzaW9uSWQiOiIwaEZEUG
EzQURWMkNRUEo3Iiwic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZXh0
IjoiVGhpcyBzZWN0aW9uIHNob3VsIGVpdGhlciBiZSBhdCBiZS
BiZWdpbm5pbmcgb3Igc2tpcHBlZCBpbW8uIFRoZSBkZXBlbmRl
bmNpZXMgc2hvdWxkIHVzZSB0aGUgcHJvcGVyIHJlZmVyZW5jZS
B3aGVudCBoZXkgYXBwZWFyLiIsImNyZWF0ZWQiOjE1OTc3Nzg0
NDQ5ODB9LCJBT1dQaEI0eFFlODYxUEtDIjp7ImRpc2N1c3Npb2
5JZCI6IklKemk4eDBIMERvMHFjaEgiLCJzdWIiOiJnaDo2ODI1
MDM1MCIsInRleHQiOiJTaG91bGQgd2Ugc2F5IHNvbXRoaW5nIG
Fib3V0IHN5bmNocm9ub3VzIHZzIEFzeW5jaHJvbm91cz8iLCJj
cmVhdGVkIjoxNTk3Nzc4NTMzMjIxfSwiOWpOVTJaNTI2UzczNl
F4NyI6eyJkaXNjdXNzaW9uSWQiOiJpaVZyamdyUmhxR1NFSlR1
Iiwic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZXh0IjoiVGhyZXNob2
xkIG9mIHRoZSBwcm9wb3J0aW9uIG9mIG9waW5pb25zIiwiY3Jl
YXRlZCI6MTU5Nzc3OTQzMDk2Mn0sInZFSDh4MWYzY04xaHhta3
AiOnsiZGlzY3Vzc2lvbklkIjoiOHZ1YUFvaEowNVh6bXJ0RiIs
InN1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6IkRlbGV0ZSB0aG
lzPyIsImNyZWF0ZWQiOjE1OTc3ODI5Nzc3MzR9LCJnelM4NmNw
andmUFJvODRhIjp7ImRpc2N1c3Npb25JZCI6ImpSSW1hSW80Zm
E1TW82SVkiLCJzdWIiOiJnaDo2ODI1MDM1MCIsInRleHQiOiJO
b3QgQ2xlYXIiLCJjcmVhdGVkIjoxNTk3NzgzMTE3NjY5fSwiWV
h5bm85SHY5Z05SYTFDZiI6eyJkaXNjdXNzaW9uSWQiOiJIdFBU
SVlvTW9xNFdvTDBvIiwic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZX
h0IjoiU28gc2hvdWxkIHdlIGFsbG93IHRoaXM/IElmIG5vdCBz
aG91bGQgdGhpcyBiZSBzYWlkPyIsImNyZWF0ZWQiOjE1OTc3OD
MxNzI2MjR9LCJVcWxBR1pFQ2p6aDUxTUVEIjp7ImRpc2N1c3Np
b25JZCI6ImJXc0xzOXFIdkVOM2h1akUiLCJzdWIiOiJnaDo2OD
I1MDM1MCIsInRleHQiOiJJcyB0aGF0IHRoZSBiZXN0IHdvcmQg
dG8gdXNlPyBBcyBhbiBleGFtcGxlIFwiT3BpbmlvblwiIGlzIG
EgcmVsYXRpb24gYmV0d2VlbiBub2RlIGFuZCBUcmFuc2FjdGlv
bi4gVGhpcyBtZWFucyB0aGUgbm9kZSBkb250IGhhdmUgb25lIE
9waW5pb24sIGJ1dCBvbmUgcGVyIHRyYW5zYWN0aW9uLiIsImNy
ZWF0ZWQiOjE1OTc3ODM5NTE4Nzh9LCJHbnA4cTAxdW1maVV1N3
pOIjp7ImRpc2N1c3Npb25JZCI6IlRINTRJdlJOSnJnQkMwZkUi
LCJzdWIiOiJnaDo2ODI1MDM1MCIsInRleHQiOiJTaG91bGQgdG
hpcyBiZSB1cGRhdGVkIHdpdGggdGhlIGtpbmQgb2YgbWFuYT8i
LCJjcmVhdGVkIjoxNTk3NzgzOTgzNzcwfSwia3p3Qnl6NEVFa3
VCb2kzRyI6eyJkaXNjdXNzaW9uSWQiOiJKcndJanVLazlmUFNY
aEJwIiwic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZXh0IjoiSXRzIH
R3aWNlIGluIHRoZSBsaXN0IiwiY3JlYXRlZCI6MTU5Nzc4Mzk5
Nzg2M30sImJvYmVrQXI0Q3dFSjlNSmkiOnsiZGlzY3Vzc2lvbk
lkIjoiR1phS0VvREMwcjk2ekJFMSIsInN1YiI6ImdoOjY4MjUw
MzUwIiwidGV4dCI6IkNvbmZ1c2luZyBhcyBPbnRvbG9neSBpcy
Bub3QgZGVmaW5lZCIsImNyZWF0ZWQiOjE1OTc3ODQyMDQ4ODB9
LCJjdXlnOUhlZzBHY1REU0FKIjp7ImRpc2N1c3Npb25JZCI6Ij
h3cnVXSjliYmllVU5WejMiLCJzdWIiOiJnaDo2ODI1MDM1MCIs
InRleHQiOiJMYXllciBpcyBub3Qgd2VsbCBkZWZpbmVkIiwiY3
JlYXRlZCI6MTU5Nzc5NTY3MDc3OX0sIjVBZUIyWjkwcER1eGRQ
TW0iOnsiZGlzY3Vzc2lvbklkIjoiYUNKSzRvcFprYVpmNGlMVy
IsInN1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6InN5bWJvbHMg
bm90IGluIGFjY29yZGFuY2UgdG8gdGhlIGRlZmluZWQgcGFyYW
1ldGVycyIsImNyZWF0ZWQiOjE1OTc3OTc0MzA0Njl9fSwiaGlz
dG9yeSI6Wy0zODgyNzM2MSwtNDgyMjIxNDgsMTYwNTM2MDI3Ny
wtMzAyNjI4MzQzLDE2NDczOTE2NjgsLTQ1NjYyMzEyLDEzMDg0
MjM1NzUsMTAwMzk5OTU3NiwtMTU0MTI0NjEzNiw5NTkwMTIyMT
MsMTMzNzY0OTcwNCw1NDYxMTEwMTgsLTQzNzQ4NTMzNCw0MDYx
NDQ5NTUsNjIzMjQxNTUyLDEzNTYxNDg2OCw4NTAwMjM4MzcsLT
EzMDc2MjY2M119
-->