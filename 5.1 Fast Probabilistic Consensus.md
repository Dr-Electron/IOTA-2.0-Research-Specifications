# 5.1 FPC specification


The module presented in this part of the specification allows nodes to find consensus on whether a given object is valid or not. The protocol, namely Fast Probabilistic Consensus (FPC), is triggered if the validity of an object is uncertain, we refer to Section 6.1. for more details. Once FPC is triggered every node decides on an initial opinions on the validity of the object, see  Section ?. The node then starts to query other nodes about their opinions on the given object and updates its opinion according to the rules specified below. 
This procedure stops locally if a node did not change its opinion over a certain period of time or if some maximal amount of rounds is reached. 

Unlike other voting-based consensus protocols, FPC uses a sequence of global random thresholds. This randomness makes FPC robust in Byzantine environment. We refer to [FPC-BI: Fast Probabilistic Consensus within Byzantine Infrastructures](https://arxiv.org/abs/1905.10895), [Robustness and efficiency of leaderless probabilistic consensus protocols within Byzantine infrastructures](https://arxiv.org/abs/1911.08787), and [Fast Probabilistic Consensus with Weighted Votes](https://link.springer.com/chapter/10.1007/978-3-030-63089-8_24) for more details on FPC.

# 5.1.1 FPC

The protocol tries to find consensus on the validity of an object `objectID`. Every node has an initial opinion `Opinion` on this object. These opinions are updated in rounds until the protocol terminates using a local stopping rule. 

## 5.1.1.1 FPC parameters
We give a list of all parameters needed for FPC.
| Name | Type |Description |
| -----| ------ | ----------- |
| `TotalRoundsFinalization` | integer | Number of consecutive rounds before FPC auto-terminates|
| `TotalRoundsFixedThreshold` | integer | Number of consecutive rounds with non-random threshold|
| `FirstRoundThreshold` | double | Threshold of the proportion of opinions in the first round|
| `SubsequentRoundsLowerBoundThreshold`| double |  Lower random threshold bound in subsequent rounds|
| `SubsequentRoundsUpperBoundThreshold` |double |  Upper random threshold bound in subsequent rounds|
| `EndingRoundsFixedThreshold` | double | Threshold for finalization phase|
| `MaxRound` | integer | Maximum number of rounds before querying stops|
|`QuerySize` | integer | Quorum size, number of nodes that are queried|
|`RoundLength` | double | Duration (in seconds) of a round|
|`TimeOut` | double  | maximal waiting time (in seconds) to receive answers for FPC queries|
|`MinManaProportion`| double | minimal amount of mana of received answers that allow to update opinion. If this amount is not reached the current round is not counted. 


The default values of the parameters are: 

| Parameter  |      Value     | 
|----------|:-------------:|
| `TotalRoundsFinalization` | 10  |
| `TotalRoundsFixedThreshold` |  3     |
| `FirstRoundThreshold` | 0.67|
| `EndingRoundsFixedThreshold` | 0.5 |
| `SubsequentRoundsLowerBoundThreshold` | 0.50 |
| `SubsequentRoundsLowerBoundThreshold`| 0.67|
| `MaxRound`|100 |
|` QuerySize` | 21|
| `RoundLength`| 10 * time.Seconds |
| `TimeOut` | 6500 * time.Millisecond |
| `MinManaProportion`| 0.50 |



## 5.1.1.2 Local variables

The opinion `Opinion` of a node on an object `objectID` of type string is described by the following type. 

```
Opinion: {
    DISLIKE: 0,
    LIKE: 1,
    NULL: NULL  #The node does not know about the object,
    NA : NA # a node does not receive an answer of the opinion of another node
}
```
If the eventual opinion of an object after FPC is `LIKE` the node must consider this object to be part of the tangle. 
>[Seb] We refer to Section Objects of Voting and Approval Switch for more details

Every node shall keep the following variables:
| Name | Type |Description |
| -----| ------ | ----------- |
| `nodeList` |list of nodeIDs | list of known nodes|
| `consensusManaList` | list of nodeIDs  | list of active consensus mana of known nodes|
| `ownMana`| double | active consensus mana of `ownNode`|
| `rn` |double | random number provided by dRNG module|
|`rnCycle`| double | random number instance (see X.X.X.X)|
| `queryList` | list of nodeIDs | list of nodes to query|
|`queryMax`| integer | maximal number of queries per round|
| `opinionQuery` | list of Opinions  | list of opinions of nodes in `queryList`, non-replies are encoded with `NA`|
| `objectIDs` | list of objectIDs | list of objectIDs that are under vote|

Note that `consensusManaList` is a list of active consensus mana of all known nodes. As this mana changes over time this list has to be updated over time. Such an update is expressed with the function `GetActiveConsensuMana(time)` that returns the list of active consensus mana at time `time`.

For each `objectID` that is under vote a node shall keep the following variables:
| Name | Type |Description |
| -----| ------ | ----------- |
| `opinion` | Opinion | opinion of the validity the `objectID`|
| `cnt` | integer | counter of the number of consecutive rounds with unchanged opinion|
| `queryStatus` | boolean | status if actively querying|
| `answerStatus` | boolean | `TRUE` if answering queries, otherwise `FALSE`|
| `round` | integer | counter for the number of rounds in FPC|
| `reachedMaxRound` | boolean | indicating whether protocol reached `MaxRound` before auto-termination, default value `FALSE`|


The `objectID`s of objects that are currently voted on are kept in a list `objectIDs`.

## 5.1.1.3 The protocol 

Let us first explain how FPC works for one `objectID`. Once FCP is triggered on the validitity of the object `objectID` a node establishes an initial opinion `opinion` on `objectID`, see Section 6.1.  The exchange and update of opinions must be done in rounds of length `RoundLength`. Rounds end and start at times (in seconds) that are multiple of `RoundLength`. At the beginning of each round a node must query a random sample of the other nodes and either send a query request or check the tangle if the sampled nodes published their opinions on the tangle. After `TimeOut` the node must calculate a weighted (by active consensus mana) mean of the received opinions. At the end of the round it must set a threshold. In the first round this threshold is `FirstRoundThreshold` while in the subsequent rounds a node must 
retreive a random threshold from the dRNG. If the weighted mean is below this obtained threshold it must set its opinion to `DISLIKE` and otherwise to `LIKE`. In case that the opinion did not change, the variable `cnt` must be incremented by 1, otherwise set to 0. If a node did not receive enough answers, i.e., the proportion of mana of the received opinions is less than `MinManaProportion`, the round is not counted, i.e., neither opinion nor `cnt` are changed. This continues until `cnt`=`TotalRoundsFinalization`-`TotalRoundsFixedThreshold`. FPC then enters in the "finalization phase" and continues for `TotalRoundsFixedThreshold` rounds using the `FixedThreshold` instead of the random threshold. If during this phase a node changes its opinions it must set `cnt`=0 and use the random threshold again. The node shall stop querying if `cnt`=`TotalRoundsFixedThreshold` or `cnt`=`reachedMaxRound`.
>[Seb] A node must set its final opinion to the ouctome of the FPC, see Section 6.?
 A node must reply to incoming queries for a given `objectID` up to `reachedMaxRound`*`RoundLength` after FPC was triggered for this `objectID`.

In case that `cnt`=`reachedMaxRound` a node must set the final opinion to `DISLIKE`. 

It is possible that there are more than one objects to vote on. In this case, a node shall sample once per round and obtain the opinions for all objects. Malicious or faulty nodes may not reply in a consistent way. In particular, in the case of a double spent, a  malicious node may reply `LIKE` for two or more conflicting objects. These malicious messages shall be filtered after having received the responses of the queries. Therefore, upon receival of the opinions, a node shall check for every sampled node if its answers are consistent, i.e., all liked objects must form a valid ledger state. Nodes that replied inconsistently shall be filtered out and their answer shall be considered as not received, i.e., they do not count for the mana of received opinions neither are used for the calculation of the weighted mean. 

High consensus mana nodes will be queried more often than nodes with low mana.  Every node is given the possibility to publish their opinions in a statement on the tangle. These message are called FPC statements. Nodes who decide to gossip may close the port reserved for FPC queries. A close port can therefore be an indication that a node decided to disseminate its opinions through statements. Every node shall keep a list of nodes that are not answering direct queries but publish their opinions on the tangle. If a node issues two or more conflicting FPC statements in a round, every other node shall not take these messages into account, i.e., they do not count for the mana of received opinions neither are used for the calculation of the weighted mean.

Note that since mana changes over time, it may well be that FPC may use different mana for different `objectID`s that are voted on at the same time. For an `objectID` FPC must use the mana list` consensusManaList` obtained by `GetActiveConsensuMana(timeObjectID)`, where  `timeObjectID` is the timestamp `ObjectID`.

In the following we present some pseudo-code for a better understanding of the details. We denote by `GetRN(a, b, time)` a function that retrieves a uniform random number between between a and b from the dRNG module.

>[Seb] to be discussed/related with DRNG, Be more precise on the source of randomness

In each round a node must query a random sample of other nodes. The random sample is obtained using weighted (by active consensus mana) sampling with replacement until `QuerySize` distinct elements are chosen. 


### `GetSample(QuerySize, nodeList, manaList)`
This function chooses a sample of nodeIDs for FPC queries.
```
queryList = []
WHILE (queryList does not contain QuerySize different elements)
    newSample:= SAMPLE(nodeList, weight=mana, replacement=TRUE)
    queryList = CONCAT(queryList, newSample)
RETURN queryList
```
Once the list `queryList` of nodes to query is chosen a node must obtain their opinions about the objects under vote. As there are two possibilities for nodes to communicate their opinions, via direct answers or via FPC statements, a node shall keep information on this behavior up to date. 


At the beginning of each round every node must prepare (in case that `queryList` contains a node that replies directly to requests) a query message and send it directly to the nodes. 

Query messages must follow the following layout. It is a concatenation of the elements of `objectIDs`:

### QueryRequest
| Name | Type | Description |
| -----|------ | ----------- |
|QueriesID | repeated string   | unlisted objectIDs |


The reply to a QueryRequest must take follow the following form 
### QueryReply

| Name | Type | Description |
| -----|------ | ----------- |
| repliedOpinions | repeated Opinion   | Opinions on queried objects in the same order as in QueryRequest |

Note that since the order of the opinions in QueryReply is important a node may have to produce different messages QueryReply for different querying nodes.  Both messages, QueryRequest and QueryReply, must be signed by the sending node. The communication channel for these messages is specified in the field "services" in the DiscoveryRequest, see Section 2.1 Peer Discovery. 



### `GetOpinion(objectIDs, queryList, TimeOut)`
This function sends queries to all nodes of `queryList` and obtains their opinion either through QueryReply messages of from FPC statements on the tangle. 
```
SEND QueryRequests messages
WAIT UNTIL TimeOut  
FOR (node in queryList)
    IF (node replied) 
        opinionQuery[node, objectIDs]=reply[node, objectIDs]
    ELSE IF (node publishes on tangle)
        opinionQuery[node, objectIDs]=getOpinionFromTangle[node, objectID]
    ELSE opinionQuery[node, objectIDs]= NA
RETURN (opinionQuery)
``` 
A node must receive a sufficient amount of replies to validate a given round; otherwise the ongoing FPC round is skipped. More precisely, the mana of the received opinions must be larger than `MinManaProportion` times the sum of the mana of the sampled nodes. 

### `CheckQuerySuccessful(opinionID, queryList, opinionQuery, MinManaProportion)`
This function checks if a node received sufficiently many answers such that the ongoing round can be considered.
```
manaList = GetActiveConsensusMana(timeObjectID)
queriedMana = SUM(manaList[queryList])
answerMana = 0
FOR node in queryList
    IF opinionQuery[node, objectID] != NA
        answerMana += manaList[node]
IF answerMana>= MinManaProportion * queriedMana
   querySuccessful = TRUE
ELSE
    querySuccessful = FALSE
RETURN querySuccessful
```

Once a node receives a FPC query it must prepare a response message as specified above, and shall sent the reply as soon as possible. If a node decides to publish its opinions on the tangle, it must create a so-called FP statement message and issue it on the tangle at the beginning of each round. 

In each round after the `TimeOut` and if `CheckQuerySuccessful` a node must update its opinion at the end of the round. The node must calculate the mana weighted mean of the obtained opinion and compare it to a certain threshold. The value of the threshold depends on the phase FPC is in. In the first round a node must use `FirstRoundThreshold` as threshold, while in the subsequent rounds the node must use a random threshold obtained by `GetRN()`. Moreover, if `cnt`>`TotalRoundsFinalization`-`TotalRoundsFixedThreshold` the node must use `EndingRoundsFixedThreshold` for the threshold. 
The following pseudo-code describes the update of the opinion of one given `objectID`. It uses `queryList` and `opinionQuery` that may be obtained by the functions `GetSample` and `GetOpinion()`. The variable `opinion` describes the current opinion on `objectID`.

### `OpinionUpdate(objectID, opinion, queryList, opinionQuery, round)`
This function updates the opinion of a node on `objectID`.
```
manaList = GetActiveConsensusMana(timeObjectID)
IF !CheckQuerySuccessful(queryList, opinionQuery))
    newOpinion = opinion # 
ELSE 
    answerMana = 0
    etaStar = 0
    FOR node in queryList
        IF opinionQuery[node, objectID] != NA
        answerMana += manaList[node]
        IF  opinionQuery[node, objectID] = LIKE
            etaStar += manaList[node]
        IF opinionQuery[node, objectID] = DISLIKE
            etaStar -= manaList[node]
    eta = (opinion*ownMana + etaStar*(answerMana-ownMana))/answerMana 
    WAIT until next ongoing round ends
    IF round == 1  
        threshold = FirstRoundThreshold
    ELSE IF round <= TotalRoundsFinalization-TotalRoundsFixedThreshold 
        threshold = getRN(SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, currentTime)  
    ELSE 
        threshold = EndingRoundsFixedThreshold
    IF (eta < threshold)
        newOpinion = DISLIKE
    ELSE
        newOpinion = LIKE
RETURN newOpinion 
```
The next function describes the FPC for one `objectID`. It is triggered once  `queryStatus` of an object is set to `TRUE`.

>[Seb] Check details with Objects of Voting spec

### `mainFPC(objectId, queryStatus)`
This function describes the FPC protocol for a node and a given `objectID`
```
IF queryStatus == TRUE  
    opinion = GetInitialOpinion(objectID)
    cnt = 0
}
WAIT until next round starts
round = 1 
queryList = GetSample(QuerySize, nodeList, manaList)
opinionQuery = GetOpinion(objectID, queryList, TimeOut)
opinionNew = OpinionUpdate(objectID, opinion, queryList, opinionQuery, round)
IF opinion == opinionNew 
    cnt++
ELSE
    cnt=0
opinion = opinionNew
round++
WHILE queryStatus
    queryList = GetSample(QuerySize, nodeList, manaList)
    opinionQuery = GetOpinion(objectID, queryList, TimeOut) 
    opinionNew = OpinionUpdate(objectID, opinion, queryList, opinionQuery, round)
    IF opinion == opinionNew 
        cnt++
    ELSE 
        cnt=1
    opinion = opinionNew
    round++
    IF cnt == TotalRoundsFinalization 
        queryStatus =FALSE
    IF round >= MaxRound 
        queryStatus =FALSE
        opinion = 1

RETURN opinion
```



# 5.1.5 Possible Optimizations
The design given above encorporates all necessary ingredients of FPC.
There are several possible ways to optimize the performance. For instance:
- FPC exposes the public IP of all the IOTA nodes. This can be limited by publishing statements on tangle. However, if all nodes decide to publish their statement this may have a negative effect on the scalability of the protocol. We refer to [Fast Probabilistic Consensus with Weighted Votes](https://link.springer.com/chapter/10.1007/978-3-030-63089-8_24) for more discussions on how to optmize the message overhead.
- Monotoncity and and consistency rules could be applied  to reduce the sizes of the messages.
- In the case that FPC is used on validity of messages we can use a symmetric range of the random threshold, `SubsequentRoundsLowerBoundThreshold=beta, SubsequentRoundsLowerBoundThreshold=1-beta` for some `beta`. This may allow to increase the support of the random threshold (and hence robustness against an attacker) without endangering the liveness of honest messages. 
- The choice of the FPC parameters could be optimized. In particular, an optimal choice depends on the actual mana distribution and network latency. 
