+ Feature name:  FPC specifications
+ Start date: 2020-03-16

# 5.1 FPC specification


The module presented in this specification, FPC, allows nodes to find consensus on whether a transaction is valid or not. 

The specification will be subdivided into the following subsections:

1. **The core FPC protocol:** our basic consensus protocol on binary opinions. It may be used on different layers and kinds of messages. 
2. **FPC on Tangle:** opinions on transaction of the tangle become dependent. This parts specifies monotonicity and consistency rules.
3. **Message compression:** reducing message complexity through message compression and reducing overhead of demanded nodes by gossiping of opinions.
4. **Gossiping:**
5. **Protocol monitoring:** information every node store for monitoring the main net.
6. **Testing:** This section discusses how the protocol is tested. It subdivides into two parts: testing the logic and test behavior in Byzantine infrastructure.
 
 The FPC on tangle is essentially a consensus mechanism on a time variable. At various parts local clocks will be used and compared to timestamps of messages. There are general standing assumption on network latency and clock synchronisations, in a nutshell, we consider that the differences in clocks are at least one order of magnitude lower than the network latency. 



# 5.1.1 The core FPC

The protocol tries to find consensus on the validity of a transaction `objectID`. Every node has an initial opinion `Opinion`(boolean) on this transaction. These opinions are updated in rounds until the protocol terminates using a local stopping rule. 

## 5.1.1.1 Protocol variables

We define the type `Opinion`. 
```
Opinion: {
    DISLIKE: 0,
    LIKE: 1,
    NULL: NULL  #The node does not know about the object,
    NA : NA # a node does not receive an answer of the opinion of another node
}
```

* `FinalizationThreshold` integer - Number of consecutive rounds before FPC auto-terminates;
* `FinalizationThreshold2` integer - Number of consecutive rounds with non-random threshold;
* `FirstRoundThreshold`  double - Threshold of the proportion of opinions in the first round;
* `SubsequentRoundsLowerBoundThreshold` double -  Lower random threshold bound in subsequent rounds;
*  `SubsequentRoundsUpperBoundThreshold` double -  Upper random threshold bound in subsequent rounds;
* `maxRound` integer - Maximum number of rounds before querying stops;
* `querySize` integer - Quorum size, number of nodes that are queried;
* `roundLength` double - Duration (in seconds) of a round;
* `timeOut` - A timer that is updated periodically, connected to `roundLength`.

IF default/recommendation values are:

TO COME

## 5.1.3.2 Local variables

Every node has the following variables
* `opinion` Opinion
* `nodeList` list of all nodes
* `manaList` list of mana values of nodes
* `mana` double - mana of node
* `cnt` integer - counter of the the number of consecutive rounds with unchanged opinion
* `queryStatus` boolean - status if actively querying
* `answerStatus` boolean - status if answerying queries, default value here is `TRUE`
* `round` integer - counts number of rounds in FPC
* `rn` double - random number from dRNG
* `rnCycle` double - random number instance (random numbers are produced at a certain period, this variable counts the current cycle) (-> connect to dRNG)
* `queryList`- list of nodes to query
* `opinionQuery` - list of opinion of nodes in `queryList`, nonreplies are encoded with `NA`
* `reachedMaxRound` boolean - indicating whether protocl reached `maxRound` before auto-termination, default calue `FALSE`
> [name=Sebastian Mueller] Present the above in a table?


## 5.1.3.3 Functions that are called
* `getIninitialOpinion` input: `objectID` output: opinion
* `getRN` input: `rnCycle` output: `rn`
* `getNodes` input:   output: `nodeList`
* `getMana` input: `nodeList` output: `manaList`
* `getSample` input: `querySize` `nodeList` `manaList` : output `queryList`
* `getOpinion` input: `objectID` `queryList` output: `opinionQuery`
* `checkQuerySuccessful` input: `queryList` `opinionQuery` output: `querySuccessful`: c*hecks whether `opinionQuery` from `getOpinion` contains enough answers*
*  `opinionUpdate` input: queryStatus output: `opinion` 
> [name=Sebastian Mueller] How do we write functions? Compare to https://hackmd.io/1oJWLLMPRmaA-GkgWJPi0Q.
## 5.1.3.4 Pseudocode 
 
Note: In the pseudocode at various places global variables are again used as input for the functions. 

### `getInitialOpinion`

This function depends on the ontology. 

### `getRN(layer, a, b, time)`
```
gets a uniform random number between (a,b),
to come, to be discussed with DRNG, 
Note: each layer may use a different random number

OUTPUT: randomThreshold, source of randomness
```

### `getNodes` 
This function should be defined somewhere in autopeering module?

### `getMana`

This function may be specified in Mana part


### `getSample(querySize, nodeList, manaList)`
```
queryList = empty
while (queryList does not contain querySize different element){
newSample:=Sample(nodeList, weight=mana, replacement=TRUE)
queryList = concat(queryList, newSample)
}
return queryList
```

### `getOpinion(queryList, timeOut)`

```
send queries to all nodes of queryList
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
return opinionQuery
```

### `checkQuerySuccessful(queryList, opinionQuery)`
```
# `manaMin` double - minimal mana of answers that have to arrive before new random number is issued  -> change to function
manaMin:=0.5 #at least 50% of the queried mana has to reply; this value may be changed
queriedMana := sum(manaList[queryList])
answerMana :=  sum(manaList[queryList[replied==TRUE]])/queriedMana
querySuccessful := ifElse( answerMana>= manaMin, TRUE, False)
return querySuccessful
```

### `sendOpinion(timeOut)`

```
answer queries that arrive before timeOut
```


### `opinionUpdate(layer, opinion, querySize, nodeList, manaList, FirstRoundThreshold, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)`
```
Sample :=getSample(querySize, nodeList, manaList)
opinionQuery := getOpinion(queryList, timeOut)
if (!checkQuerySuccessful(queryList, opinionQuery)){ #check if sufficiently many nodes replied in time
    newOpinion := opinion # if not keep old opinion 
}
else{ # otherwise update according to FPC rule
    etaStar := mean(opinionQuery, NA.remove=TRUE)
    totalMana := sum(listMana, NA.remove=TRUE) # remove nodes that did not answer
    eta := opinion*mana + etaStar*(totalMana-mana)/totalMana
    if (round == 1){ #first FPC round uses different threshold
        if (eta < FirstRoundThreshold){
            newOpinion <-0
        }
        else newOpinion <-1
    }
    else #the subsequent rounds (before the FinalizationThreshold2 confirming) use random threshold
        rn := getRN(layer, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, time)  # here we have to synchronize/wait for random number
        if (eta < rn){
            newOpinion <-0
        }
        else newOpinion <-1       
}

return newOpinion 
```


### `mainFPC(objectId, queryStatus)`
```
if (queryStatus turns TRUE ){ 
    opinion := getInitialOpinion(objectID)
    listMana := getMana()
    listNode := getNodes()
    cnt := 1
}
wait for new FPC round # next random number from dRNG
#start the first FPC round
round := 1 
opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, FirstRoundThreshold, ubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)
if (opinion==opinionNew) cnt++
else cnt:=0
opinion := opinionNew
round++

#continue FPC, subsequent rounds 
while queryStatus {
    if (cnt <= FinalizationThreshold-FinalizationThreshold2) # we use random threshold{
        opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, FirstRoundThreshold, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)
        if (opinion==opinionNew) cnt++
        else cnt:=0
        opinion := opinionNew
    }
    else {  # we use deterministic threshold for FinalizationThreshold2 "confirming" rounds
    opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, 0.5, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, 1, time)
        if (opinion==opinionNew) cnt++
        else cnt:=0
        opinion := opinionNew      
    }
    round++
    if (cnt==FinalizationThreshold) queryStatus:=FALSE
    if (round>=MaxRound) {
        queryStatus:=FALSE
        reachedMaxRound:=TRUE
    }
}
return(opinion)
```

## 5.1.3.5 Message/transaction layout


### Querying message

### Answering message
This is done in the next section.

# 5.1.4 FPC on tangle

In the tangle reality FPC may have to be applied to various messages simultaneously. Moreover, the tangle (the local view of every node) has to be monotone and consistent. We have to address the three following points:
* **Parallelity:** Many ongoing votings at the same time 
* **Consistency:** Layer should not contain contradicting messages
* **Monotonicity:** Liked  messages should not refer to disliked messages

## 5.1.4.1 Parallelity
At every round FPC decides on possibly several opinions. However, the every node will only query other nodes once (!). This is done for scalability. 

The local variable `opinions` records the vector of all opinions under vote. 

### `getInitialOpinions`

This function depends on the ontology and uses `getInitialOpinions` in a straightforward way.


### `getOpinions(queryList, timeOut)`
```
send queries to all nodes of queryList
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
return opinionsQuery
```
FPC is now applied for each opinion separately. This may not be optimal, but this is addressed in Section 3. It may that the outcome is not consistent or monotone. 


### single vs. multiple dRNG in each round

Discussion: using a different threshold for every opinion (e.g. hash(objectID) X hash(rn)) may lead to the following attack vector. If the number of votings is large then with high probability some of the will always have a random threshold close to 0.5, in other words for a random subset of tx there is no random threshold and hence the protocol is unsafe. 

Advantage of using the same random threshold is also that the two following functions have less to do, i.e., monotonicity and consistency is increased.

It may be good to use different random thresholds for the voting on different layers! (-> `getRN()`)

## 5.1.4.2 Consistency and Monotonicity

### `applyMonotonicityRule()`
```
functions that make temporary ledger state monoton, past cone of liked tx are like, future cones of disliked tx dislike, generalize these rules to level of knowledge -> Billy
```

### `applyConsistencyRule()`
```
functions that make temporary ledger state consistent
if two contradiction transaction are liked, choose the one with the higher mana (?)/ the previous favorite/ hash?
```
## 5.1.4.3 Data layer
FPC is used in the data layer to decide on the validity of the timestamp of a message. We can use here a symmetric range of the random threshold, `a=beta, b=1-beta`



## 5.1.4.4 Value layer
FPC decides in particular between two conflicting transaction, thresholds below 0.5 may lead to liking both transaction after voting. TO DISCUSS: asymmetric random threshold `a=0.5, b=1-beta`. Since there are no simulations yet, it lay be good to run some to check performances. 


# 5.1.5 Message compression of FPC


## 5.1.5.1 Compression in query messages
**Query:** reduce message identifier, e.g., Prefix trie or Cuckoo filter
**Answer:** Bitmask, respond in same order with 1bit per message

# 5.1.6 Gossiping
High mana nodes will be queried too often. They have the possibility to gossip their opinion. However, it is yet not clear who will  be allowed to gossip. 

### Everybody can gossip
This solution follows the idea that IOTA is all but freedom. Every node can decide on his own whether to gossip or not. Nevertheless, IF has to propose a reference implementation.

Advantages:
* if not in place, high mana nodes may be spammed by querries. But is this a reasonable concern for Coordicide 1.0?

Disadvantages: 
* local optimum may not be global optimum
* if all nodes gossip, network may reach congestion. But is this a reasonable concern for Coordicide 1.0?

### Threshold for gossiping

There is a global threshold, like the 100 top mana holders can gossip, the others are querying. However, mana perception is local and hence the threshold can't be sharp. 


### Proposal
TO DISCUSS
* every node is free to gossip
* nodes who gossip, close the port corresponding to queries, this allows other nodes to see whether this node gossips, 
* in IF reference implementation: if own mana perception is above a certain threshold, that would lead to overquery, then gossip

### Changes in the FPC protocol

Warning: the code may depend on the above decision who is going to gossip their opinion. 
### `getOpinions(queryList, timeOut)`
```
send queries to all nodes of queryList that do not gossip
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
read opinions from tangle of all to all nodes of queryList that do gossip

return opinionsQuery
```
Edge cases: what happens if gossiping node is queried? (Angelo: not reply at all, you even don t listen (close ports), Seb: be kind if possible).

If node has to gossip but is not?

# 5.1.7  Protocol monitoring




# 5.1.8 Testing

## 5.1.8.1 Edge cases

## 5.1.8.2 Spamming

## 5.1.8.3 Adversarial strategies

<!--stackedit_data:
eyJkaXNjdXNzaW9ucyI6eyIwU1Y4YmhLcDFjTnJDUzdFIjp7In
RleHQiOiJNYW5hICh0byBvYnRhaW4gbGlzdCBvZiBtYW5hKSIs
InN0YXJ0IjoxMzQ1LCJlbmQiOjEzNDV9LCJXU1BQcGxQYkg4dH
BVNW83Ijp7InRleHQiOiIjIDUuMS41IEZQQyBvbiB0YW5nbGUi
LCJzdGFydCI6ODgzMCwiZW5kIjo4ODUxfSwiNmw3T0RMZU9mRk
Vob2tuNSI6eyJ0ZXh0IjoiU2luY2UgdGhlcmUgYXJlIG5vIHNp
bXVsYXRpb25zIHlldCwgaXQgbGF5IGJlIGdvb2QgdG8gcnVuIH
NvbWUgdG8gY2hlY2sgcGVyZm9ybeKApiIsInN0YXJ0IjoxMTYy
NSwiZW5kIjoxMTcxMH0sIjA4bUY3Tzg2RjVHUUdkWmsiOnsidG
V4dCI6Im5vZGUgZ29zc2lwcywiLCJzdGFydCI6MTI5NjgsImVu
ZCI6MTI5ODF9LCIwaEZEUGEzQURWMkNRUEo3Ijp7InRleHQiOi
IjIDUuMS4yIERlcGVuZGVuY2llcyIsInN0YXJ0IjoxMzQ1LCJl
bmQiOjEzNDV9LCJIdFBUSVlvTW9xNFdvTDBvIjp7InRleHQiOi
JUaGUgYWJvdmUgdmFyaWFibGVzIGNhbiBpbiB0aGVvcnkgYmUg
Y2hvc2VuIGxvY2FsbHkgZm9yIGVhY2ggbm9kZS4gSG93ZXZlci
wgdGhl4oCmIiwic3RhcnQiOjI2MzgsImVuZCI6MjYzOH0sImJX
c0xzOXFIdkVOM2h1akUiOnsidGV4dCI6InZhcmlhYmxlcyIsIn
N0YXJ0IjoyNzQzLCJlbmQiOjI3NTJ9LCJUSDU0SXZSTkpyZ0JD
MGZFIjp7InRleHQiOiIqIGBtYW5hTGlzdGAgbGlzdCBvZiBtYW
5hIG9mIG5vZGVzXG4qIGBtYW5hYCBkb3VibGUgLSBtYW5hIG9m
IG5vZGUiLCJzdGFydCI6MjgwNCwiZW5kIjoyODc2fSwiSnJ3SW
p1S2s5ZlBTWGhCcCI6eyJ0ZXh0IjoiYm9vbGVhbiAtIHRyYW5z
YWN0aW9uIHRydWUgb3IgZmFsc2UiLCJzdGFydCI6Mjg3NywiZW
5kIjoyODc3fSwiR1phS0VvREMwcjk2ekJFMSI6eyJ0ZXh0Ijoi
VGhpcyBmdW5jdGlvbiBkZXBlbmRzIG9uIHRoZSBvbnRvbG9neS
4iLCJzdGFydCI6NDUxMiwiZW5kIjo0NTUwfSwiOHdydVdKOWJi
aWVVTlZ6MyI6eyJ0ZXh0IjoiTm90ZTogZWFjaCBsYXllciIsIn
N0YXJ0Ijo0NjY5LCJlbmQiOjQ2ODV9LCJhQ0pLNG9wWmthWmY0
aUxXIjp7InRleHQiOiJgYT0wLjUsIGI9MS1iZXRhYCIsInN0YX
J0IjoxMTYwNiwiZW5kIjoxMTYyM319LCJjb21tZW50cyI6eyI0
aG5Sak9PVzRIaUtNTnZqIjp7ImRpc2N1c3Npb25JZCI6IjBTVj
hiaEtwMWNOckNTN0UiLCJzdWIiOiJnaDo1MTExMjYxOCIsInRl
eHQiOiJzbmFwc2hvdHRlZCBtYW5hIHZzIGFsdGVybmF0aXZlcy
IsImNyZWF0ZWQiOjE1OTY1MjAzMDQ3MjR9LCI5OG84NGttSDM0
REFjY3VpIjp7ImRpc2N1c3Npb25JZCI6IldTUFBwbFBiSDh0cF
U1bzciLCJzdWIiOiJnaDo1MTExMjYxOCIsInRleHQiOiIhIFRo
aXMgc2VjdGlvbiBtYXkgY2hhbmdlIChpZiBmYWN0IGJlIGRlbG
V0ZWQpICBpbiBwYXJhbGxlbCByZWFsaXR5IHVuaXZlcnNlLiIs
ImNyZWF0ZWQiOjE1OTY1MjA4Njk1NjF9LCJocURtMUZTbkZlTm
puWU5sIjp7ImRpc2N1c3Npb25JZCI6IjZsN09ETGVPZkZFaG9r
bjUiLCJzdWIiOiJnaDo1MTExMjYxOCIsInRleHQiOiJEb25lIG
luIHRoZSBtZWFudGltZSwgbm8gYmFkIHN1cnByaXNlcyIsImNy
ZWF0ZWQiOjE1OTY1MjExMTE4OTZ9LCI2QUZubW1OejJ1bkdSUU
ZKIjp7ImRpc2N1c3Npb25JZCI6IjA4bUY3Tzg2RjVHUUdkWmsi
LCJzdWIiOiJnaDo1MTExMjYxOCIsInRleHQiOiJ3ZWxsIGF0IG
xlYXN0IGFuIGluZGljYXRpb24iLCJjcmVhdGVkIjoxNTk2NTIx
MjQxNTMxfSwiZGM2ZzhkQld3WWRMQ0VZWCI6eyJkaXNjdXNzaW
9uSWQiOiIwU1Y4YmhLcDFjTnJDUzdFIiwic3ViIjoiZ2g6NTEx
MTI2MTgiLCJ0ZXh0IjoianVzdCBGUENNYW5hIiwiY3JlYXRlZC
I6MTU5NjUyOTk3NzExMX0sIllhU0JyeThOVjR4blVFclMiOnsi
ZGlzY3Vzc2lvbklkIjoiMGhGRFBhM0FEVjJDUVBKNyIsInN1Yi
I6ImdoOjY4MjUwMzUwIiwidGV4dCI6IlRoaXMgc2VjdGlvbiBz
aG91bCBlaXRoZXIgYmUgYXQgYmUgYmVnaW5uaW5nIG9yIHNraX
BwZWQgaW1vLiBUaGUgZGVwZW5kZW5jaWVzIHNob3VsZCB1c2Ug
dGhlIHByb3BlciByZWZlcmVuY2Ugd2hlbnQgaGV5IGFwcGVhci
4iLCJjcmVhdGVkIjoxNTk3Nzc4NDQ0OTgwfSwiWVh5bm85SHY5
Z05SYTFDZiI6eyJkaXNjdXNzaW9uSWQiOiJIdFBUSVlvTW9xNF
dvTDBvIiwic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZXh0IjoiU28g
c2hvdWxkIHdlIGFsbG93IHRoaXM/IElmIG5vdCBzaG91bGQgdG
hpcyBiZSBzYWlkPyIsImNyZWF0ZWQiOjE1OTc3ODMxNzI2MjR9
LCJVcWxBR1pFQ2p6aDUxTUVEIjp7ImRpc2N1c3Npb25JZCI6Im
JXc0xzOXFIdkVOM2h1akUiLCJzdWIiOiJnaDo2ODI1MDM1MCIs
InRleHQiOiJJcyB0aGF0IHRoZSBiZXN0IHdvcmQgdG8gdXNlPy
BBcyBhbiBleGFtcGxlIFwiT3BpbmlvblwiIGlzIGEgcmVsYXRp
b24gYmV0d2VlbiBub2RlIGFuZCBUcmFuc2FjdGlvbi4gVGhpcy
BtZWFucyB0aGUgbm9kZSBkb250IGhhdmUgb25lIE9waW5pb24s
IGJ1dCBvbmUgcGVyIHRyYW5zYWN0aW9uLiIsImNyZWF0ZWQiOj
E1OTc3ODM5NTE4Nzh9LCJHbnA4cTAxdW1maVV1N3pOIjp7ImRp
c2N1c3Npb25JZCI6IlRINTRJdlJOSnJnQkMwZkUiLCJzdWIiOi
JnaDo2ODI1MDM1MCIsInRleHQiOiJTaG91bGQgdGhpcyBiZSB1
cGRhdGVkIHdpdGggdGhlIGtpbmQgb2YgbWFuYT8iLCJjcmVhdG
VkIjoxNTk3NzgzOTgzNzcwfSwia3p3Qnl6NEVFa3VCb2kzRyI6
eyJkaXNjdXNzaW9uSWQiOiJKcndJanVLazlmUFNYaEJwIiwic3
ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZXh0IjoiSXRzIHR3aWNlIGlu
IHRoZSBsaXN0IiwiY3JlYXRlZCI6MTU5Nzc4Mzk5Nzg2M30sIm
JvYmVrQXI0Q3dFSjlNSmkiOnsiZGlzY3Vzc2lvbklkIjoiR1ph
S0VvREMwcjk2ekJFMSIsInN1YiI6ImdoOjY4MjUwMzUwIiwidG
V4dCI6IkNvbmZ1c2luZyBhcyBPbnRvbG9neSBpcyBub3QgZGVm
aW5lZCIsImNyZWF0ZWQiOjE1OTc3ODQyMDQ4ODB9LCJjdXlnOU
hlZzBHY1REU0FKIjp7ImRpc2N1c3Npb25JZCI6Ijh3cnVXSjli
YmllVU5WejMiLCJzdWIiOiJnaDo2ODI1MDM1MCIsInRleHQiOi
JMYXllciBpcyBub3Qgd2VsbCBkZWZpbmVkIiwiY3JlYXRlZCI6
MTU5Nzc5NTY3MDc3OX0sIjVBZUIyWjkwcER1eGRQTW0iOnsiZG
lzY3Vzc2lvbklkIjoiYUNKSzRvcFprYVpmNGlMVyIsInN1YiI6
ImdoOjY4MjUwMzUwIiwidGV4dCI6InN5bWJvbHMgbm90IGluIG
FjY29yZGFuY2UgdG8gdGhlIGRlZmluZWQgcGFyYW1ldGVycyIs
ImNyZWF0ZWQiOjE1OTc3OTc0MzA0Njl9fSwiaGlzdG9yeSI6Wz
Q2NzgxMTEzLC00ODIyMjE0OCwxNjA1MzYwMjc3LC0zMDI2Mjgz
NDMsMTY0NzM5MTY2OCwtNDU2NjIzMTIsMTMwODQyMzU3NSwxMD
AzOTk5NTc2LC0xNTQxMjQ2MTM2LDk1OTAxMjIxMywxMzM3NjQ5
NzA0LDU0NjExMTAxOCwtNDM3NDg1MzM0LDQwNjE0NDk1NSw2Mj
MyNDE1NTIsMTM1NjE0ODY4LDg1MDAyMzgzNywtMTMwNzYyNjYz
XX0=
-->