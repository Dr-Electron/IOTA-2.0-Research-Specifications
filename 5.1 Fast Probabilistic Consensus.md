+ Feature name:  FPC specifications
+ Start date: 2020-03-16

# 5.1 FPC specification


The module presented in this specification, FPC, allows nodes to find consensus on whether a transaction is valid or not. 

The specification will be subdivided into the following subsections:

1. The core FPC protocol: our basic consensus protocol on binary opinions. It may serve on various ontologies as consensus protocol. 
2. FPC on tangle: opinions on transaction of the tangle become dependent. This parts specifies monotonicity and consistency rules.
3. message compression of FPC: reducing message complexity through message compression and gossiping of opinions for high mana nodes. This part has to be updated and revised due to the parallel reality approach.
4. protocol interface: data layer and value layer. This part specifies when FPC is started; it defines how the variables `queryStatus` and `answerStatus` are set. Also function`getInitialOpinion`has to be specified.  -> This part should essentially be covered by Billy.
5. Resynchronization interface: if protocol does not auto-terminate -> resynchronization
6. Berserk detection: mechanism that allows the detection of Berserk behavior. This part may be integrated later on. This depends on how we do proceed with reporting malicious behavior etc.
7. Protocol monitoring: information every node saves for testing of the protocol (in test net, finding optimal parameter sets) and for monitoring in main net
8. Testing: This section discusses how the protocol is tested. It subdivides into two parts: testing the logic and test behavior in Byzantine infrastructure.
9. 

# 5.1.1 Motivation

# 5.1.2 Dependencies
The FPC module depends on the following other modules:
> [name=Sebastian MuFinalizationThresholder, time=Fri, Jun 19, 2020 10:42 AM] wait until respecive specs are available then synronize

 - 4.3 Mana (to obtain list of mana)
 - 5.3 dRNG (to obtain random number)
  - 5.4 Resynchronization  
  - 3.2 Finality
  - 1.2 Communication Specifications  Payloads and Ontologies 
  - 4.2 UTXO and Realities calculations
  - 2.1 Autopeering (to obtain a list of nodes)  Rate control (gossiping of high mana nodes, do FPC messages need to pass rate control?)

# 5.1.3 Remarks
FPC on tangle is essentially a consensus on "time". At various parts local clocks will be used and compared to timestamps of messages. There are general standing assumption on network latency and clock synchronizations. In a nutshell, they are that the differences in clocks are at least one order of magnitude lower than the network latency. 


# 5.1.4 The core FPC

The protocol tries to find consensus on the validity of a transaction `objectID`. Every node has an initial opinion `opinion`(boolean) on this transaction. These opinions are updated in rounds until the protocol terminates using a local stopping rule. 

## 5.1.4.1 Protocol variables

We define the type `Opinion`. 
```
Opinion: {
    DISLIKE: 0,
    LIKE: 1,
    NULL: NULL  #The node does not know about the object,
    NA : NA # a node does not receive an answer of the opinion of another node
}
```



* `FinalizationThreshold` integer - number of consecutive rounds before FPC auto-terminates
* `FinalizationThreshold2` integer - number of consecutive rounds with non-random threshold
* `FirstRoundThreshold`  double - threshold in first round
* `SubsequentRoundsLowerBoundThreshold` double -  lower random threshold bound in subsequent rounds
*  `SubsequentRoundsUpperBoundThreshold` double -  upper random threshold bound in subsequent rounds
* `maxRound` integer - maximal number of rounds before querying stops
* `querySize` integer - quorum size, number of nodes that are queries
* `roundLength` double - length (in sec) of a round, this has to be synchronized !? For instance, by the DRNG, maybe start with 10s, and FPC only uses DRNG every second round
* `timeOut` - somehow a timer that is updated periodically, connected to `roundLength` TBD

The above variables can in theory be chosen locally for each node. However, the security of the protocol depends on that they are chosen in a reasonable way. The best is if these variables are chosen the same for every node. The IF recommends to use the default values.

IF default/recommendation values are:

TO COME

## 5.1.4.2 Local variables

Every node has the following variables
* `opinion` Opinion
* `nodeList` list of all nodes
* `manaList` list of mana of nodes
* `mana` double - mana of node
* `opinion` boolean - transaction true or false
* `cnt` integer - counter that counts the number of consecutives rounds with unchanged opinion
* `queryStatus` boolean - status if actively querying
* `answerStatus` boolean - status if answerying queries, default value here is `TRUE`
* `round` integer - counts number of rounds in FPC
* `rn` double - random number from dRNG
* `rnCycle` double - random number instance (random numbers are produced at a certain period, this variable counts the current cycle) (-> connect to dRNG)
* `queryList`- list of nodes to query
* `opinionQuery` - list of opinion of nodes in `queryList`, nonreplies are encoded with `NA`
* `reachedMaxRound` boolean - indicating whether protocl reached `maxRound` before auto-termination, default calue `FALSE`
> [name=Sebastian Mueller] Present the above in a table?


## 5.1.4.3 Functions that are called
* `getIninitialOpinion` input: `objectID` output: opinion
* `getRN` input: `rnCycle` output: `rn`
* `getNodes` input:   output: `nodeList`
* `getMana` input: `nodeList` output: `manaList`
* `getSample` input: `querySize` `nodeList` `manaList` : output `queryList`
* `getOpinion` input: `objectID` `queryList` output: `opinionQuery`
* `checkQuerySuccessful` input: `queryList` `opinionQuery` output: `querySuccessful`: c*hecks whether `opinionQuery` from `getOpinion` contains enough answers*
*  `opinionUpdate` input: queryStatus output: `opinion` 
> [name=Sebastian Mueller] How do we write functions? Compare to https://hackmd.io/1oJWLLMPRmaA-GkgWJPi0Q.
## 5.1.4.4 Pseudocode 
 
Note: In the pseudocode at various places global variables are again used as input for the functions. 

### `getInitialOpinion`

This function depends on the ontology. 

### `getRN(layer, a, b, time)`
```
gets a uniform random number between (a,b),
to come, to be discussed with DRNG, 
Note: each layer may use a different random number

OUTPUT: randomThreshold, source of randomness
```

### `getNodes` 
This function should be defined somewhere in autopeering module?

### `getMana`

This function may be specified in Mana part


### `getSample(querySize, nodeList, manaList)`
```
queryList = empty
while (queryList does not contain querySize different element){
newSample:=Sample(nodeList, weight=mana, replacement=TRUE)
queryList = concat(queryList, newSample)
}
return queryList
```

### `getOpinion(queryList, timeOut)`

```
send queries to all nodes of queryList
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
return opinionQuery
```

### `checkQuerySuccessful(queryList, opinionQuery)`
```
# `manaMin` double - minimal mana of answers that have to arrive before new random number is issued  -> change to function
manaMin:=0.5 #at least 50% of the queried mana has to reply; this value may be changed
queriedMana := sum(manaList[queryList])
answerMana :=  sum(manaList[queryList[replied==TRUE]])/queriedMana
querySuccessful := ifElse( answerMana>= manaMin, TRUE, False)
return querySuccessful
```

### `sendOpinion(timeOut)`

```
answer queries that arrive before timeOut
```


### `opinionUpdate(layer, opinion, querySize, nodeList, manaList, FirstRoundThreshold, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)`
```
Sample :=getSample(querySize, nodeList, manaList)
opinionQuery := getOpinion(queryList, timeOut)
if (!checkQuerySuccessful(queryList, opinionQuery)){ #check if sufficiently many nodes replied in time
    newOpinion := opinion # if not keep old opinion 
}
else{ # otherwise update according to FPC rule
    etaStar := mean(opinionQuery, NA.remove=TRUE)
    totalMana := sum(listMana, NA.remove=TRUE) # remove nodes that did not answer
    eta := opinion*mana + etaStar*(totalMana-mana)/totalMana
    if (round == 1){ #first FPC round uses different threshold
        if (eta < FirstRoundThreshold){
            newOpinion <-0
        }
        else newOpinion <-1
    }
    else #the subsequent rounds (before the FinalizationThreshold2 confirming) use random threshold
        rn := getRN(layer, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, time)  # here we have to synchronize/wait for random number
        if (eta < rn){
            newOpinion <-0
        }
        else newOpinion <-1       
}

return newOpinion 
```


### `mainFPC(objectId, queryStatus)`
```
if (queryStatus turns TRUE ){ 
    opinion := getInitialOpinion(objectID)
    listMana := getMana()
    listNode := getNodes()
    cnt := 1
}
wait for new FPC round # next random number from dRNG
#start the first FPC round
round := 1 
opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, FirstRoundThreshold, ubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)
if (opinion==opinionNew) cnt++
else cnt:=0
opinion := opinionNew
round++

#continue FPC, subsequent rounds 
while queryStatus {
    if (cnt <= FinalizationThreshold-FinalizationThreshold2) # we use random threshold{
        opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, FirstRoundThreshold, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)
        if (opinion==opinionNew) cnt++
        else cnt:=0
        opinion := opinionNew
    }
    else {  # we use deterministic threshold for FinalizationThreshold2 "confirming" rounds
    opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, 0.5, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, 1, time)
        if (opinion==opinionNew) cnt++
        else cnt:=0
        opinion := opinionNew      
    }
    round++
    if (cnt==FinalizationThreshold) queryStatus:=FALSE
    if (round>=MaxRound) {
        queryStatus:=FALSE
        reachedMaxRound:=TRUE
    }
}
return(opinion)
```

## 5.1.4.5 Message/transaction layout


### Querying message

### Answering message
This is done in the next section.

# 5.1.5 FPC on tangle

In the tangle reality FPC may have to be applied to various messages simultaneously. Moreover, the tangle (the local view of every node) has to be monotone and consistent. We have to address the three following points:
* **Parallelity:** Many ongoing votings at the same time 
* **Consistency:** Layer should not contain contradicting messages
* **Monotonicity:** Liked  messages should not refer to disliked messages

## 5.1.5.1 Parallelity
At every round FPC decides on possibly several opinions. However, the every node will only query other nodes once (!). This is done for scalability. 

The local variable `opinions` records the vector of all opinions under vote. 

### `getInitialOpinions`

This function depends on the ontology and uses `getInitialOpinions` in a straightforward way.


### `getOpinions(queryList, timeOut)`
```
send queries to all nodes of queryList
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
return opinionsQuery
```
FPC is now applied for each opinion separately. This may not be optimal, but this is addressed in Section 3. It may that the outcome is not consistent or monotone. 


### single vs. multiple dRNG in each round

Discussion: using a different threshold for every opinion (e.g. hash(objectID) X hash(rn)) may lead to the following attack vector. If the number of votings is large then with high probability some of the will always have a random threshold close to 0.5, in other words for a random subset of tx there is no random threshold and hence the protocol is unsafe. 

Advantage of using the same random threshold is also that the two following functions have less to do, i.e., monotonicity and consistency is increased.

It may be good to use different random thresholds for the voting on different layers! (-> `getRN()`)

## 5.1.5.2 Consistency and Monotonicity

### `applyMonotonicityRule()`
```
functions that make temporary ledger state monoton, past cone of liked tx are like, future cones of disliked tx dislike, generalize these rules to level of knowledge -> Billy
```

### `applyConsistencyRule()`
```
functions that make temporary ledger state consistent
if two contradiction transaction are liked, choose the one with the higher mana (?)/ the previous favorite/ hash?
```
## 5.1.5.3 Data layer
FPC is used in the data layer to decide on the validity of the timestamp of a message. We can use here a symmetric range of the random threshold, `a=beta, b=1-beta`



## 5.1.5.4 Value layer
FPC decides in particular between two conflicting transaction, thresholds below 0.5 may lead to liking both transaction after voting. TO DISCUSS: asymmetric random threshold `a=0.5, b=1-beta`. Since there are no simulations yet, it lay be good to run some to check performances. 


# 5.1.6 Message compression of FPC


## 5.1.6.1 Compression in query messages
**Query:** reduce message identifier, e.g., Prefix trie or Cuckoo filter
**Answer:** Bitmask, respond in same order with 1bit per message

# 5.1.7 Gossiping
High mana nodes will be queried too often. They have the possibility to gossip their opinion. However, it is yet not clear who will  be allowed to gossip. 

### Everybody can gossip
This solution follows the idea that IOTA is all but freedom. Every node can decide on his own whether to gossip or not. Nevertheless, IF has to propose a reference implementation.

Advantages:
* if not in place, high mana nodes may be spammed by querries. But is this a reasonable concern for Coordicide 1.0?

Disadvantages: 
* local optimum may not be global optimum
* if all nodes gossip, network may reach congestion. But is this a reasonable concern for Coordicide 1.0?

### Threshold for gossiping

There is a global threshold, like the 100 top mana holders can gossip, the others are querying. However, mana perception is local and hence the threshold can't be sharp. 


### Proposal
TO DISCUSS
* every node is free to gossip
* nodes who gossip, close the port corresponding to queries, this allows other nodes to see whether this node gossips, 
* in IF reference implementation: if own mana perception is above a certain threshold, that would lead to overquery, then gossip

### Changes in the FPC protocol

Warning: the code may depend on the above decision who is going to gossip their opinion. 
### `getOpinions(queryList, timeOut)`
```
send queries to all nodes of queryList that do not gossip
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
read opinions from tangle of all to all nodes of queryList that do gossip

return opinionsQuery
```
Edge cases: what happens if gossiping node is queried? (Angelo: not reply at all, you even don t listen (close ports), Seb: be kind if possible).

If node has to gossip but is not?

# 5.1.7  Protocol monitoring




# 5.1.8 Testing

## 5.1.8.1 Edge cases

## 5.1.8.2 Spamming

## 5.1.8.3 Adversarial strategies

<!--stackedit_data:
eyJkaXNjdXNzaW9ucyI6eyIwU1Y4YmhLcDFjTnJDUzdFIjp7In
RleHQiOiJNYW5hICh0byBvYnRhaW4gbGlzdCBvZiBtYW5hKSIs
InN0YXJ0IjoxODY3LCJlbmQiOjE4OTZ9LCJXU1BQcGxQYkg4dH
BVNW83Ijp7InRleHQiOiIjIDUuMS41IEZQQyBvbiB0YW5nbGUi
LCJzdGFydCI6MTA0NzIsImVuZCI6MTA0OTN9LCI2bDdPRExlT2
ZGRWhva241Ijp7InRleHQiOiJTaW5jZSB0aGVyZSBhcmUgbm8g
c2ltdWxhdGlvbnMgeWV0LCBpdCBsYXkgYmUgZ29vZCB0byBydW
4gc29tZSB0byBjaGVjayBwZXJmb3Jt4oCmIiwic3RhcnQiOjEz
MjY3LCJlbmQiOjEzMzUyfSwiMDhtRjdPODZGNUdRR2RaayI6ey
J0ZXh0Ijoibm9kZSBnb3NzaXBzLCIsInN0YXJ0IjoxNDYxMCwi
ZW5kIjoxNDYyM30sIjhGV2hZUDc3Wks2MGVwVUsiOnsidGV4dC
I6IlRoZSBjb250ZW50IG9mIHRoaXMgc3BlY2lmaWNhdGlvbiBp
cyBiYXNlZCBvbiBbRlBDIC0gc2ltdWxhdGlvbl0oaHR0cHM6Ly
9hcnhpdi7igKYiLCJzdGFydCI6MjEyLCJlbmQiOjIxNn0sImRm
UE40NjhVSWFEWlc1bWMiOnsidGV4dCI6InRoZSBmb2xsb3dpbm
cgc3Vic2VjdGlvbnM6Iiwic3RhcnQiOjI1NCwiZW5kIjoyODB9
LCJ4YWdMYnNyZkV6OFFKV3ZDIjp7InRleHQiOiJJdCBtYXkgc2
VydmUgb24gdmFyaW91cyBvbnRvbG9naWVzIGFzIGNvbnNlbnN1
cyBwcm90b2NvbC4iLCJzdGFydCI6MzU3LCJlbmQiOjQxNH0sIl
NHajVIUlV2Q2puRXBRb2YiOnsidGV4dCI6InRyYW5zYWN0aW9u
Iiwic3RhcnQiOjQ0NiwiZW5kIjo0NTd9LCJFN09JUnpVaG4yaW
xvdThBIjp7InRleHQiOiJtZXNzYWdlIGNvbXByZXNzaW9uIG9m
IEZQQzogcmVkdWNpbmcgbWVzc2FnZSBjb21wbGV4aXR5IHRocm
91Z2ggbWVzc2FnZSBjb21wcmVz4oCmIiwic3RhcnQiOjU1MCwi
ZW5kIjo3NTh9LCJXWVoxYVd4cUpVb0E2aWNVIjp7InRleHQiOi
I0LiBwcm90b2NvbCBpbnRlcmZhY2U6IGRhdGEgbGF5ZXIgYW5k
IHZhbHVlIGxheWVyLiBUaGlzIHBhcnQgc3BlY2lmaWVzIHdoZW
4gRlBD4oCmIiwic3RhcnQiOjc1OSwiZW5kIjoxMDI4fSwiQ0F5
RXVERk5JYlZrWENYMyI6eyJ0ZXh0IjoiUmVzeW5jaHJvbml6YX
Rpb24gaW50ZXJmYWNlOiBpZiBwcm90b2NvbCBkb2VzIG5vdCBh
dXRvLXRlcm1pbmF0ZSAtPiByZXN5bmNocm9uaeKApiIsInN0YX
J0IjoxMDMyLCJlbmQiOjExMTd9LCJmcnZqVVN5SmxLUGhLREQ4
Ijp7InRleHQiOiJCZXJzZXJrIGRldGVjdGlvbjogbWVjaGFuaX
NtIHRoYXQgYWxsb3dzIHRoZSBkZXRlY3Rpb24gb2YgQmVyc2Vy
ayBiZWhhdmlvci4gVGhp4oCmIiwic3RhcnQiOjExMjEsImVuZC
I6MTYyM30sIkVzeVNnSEh2Y2ZvaVpkVzUiOnsidGV4dCI6IiMg
NS4xLjEgTW90aXZhdGlvbiIsInN0YXJ0IjoxNjI5LCJlbmQiOj
E2NDd9LCIwaEZEUGEzQURWMkNRUEo3Ijp7InRleHQiOiIjIDUu
MS4yIERlcGVuZGVuY2llcyIsInN0YXJ0IjoxNjQ5LCJlbmQiOj
E2Njl9LCJJSnppOHgwSDBEbzBxY2hIIjp7InRleHQiOiJGUEMg
b24gdGFuZ2xlIGlzIGVzc2VudGlhbGx5IGEgY29uc2Vuc3VzIG
9uIFwidGltZVwiLiBBdCB2YXJpb3VzIHBhcnRzIGxvY2FsIGNs
b2PigKYiLCJzdGFydCI6MjIzNywiZW5kIjoyNTc5fSwiNzBhbm
VjMW5rUXVRcmpISiI6eyJ0ZXh0IjoiOS4iLCJzdGFydCI6MTYy
NCwiZW5kIjoxNjI2fSwiaWlWcmpnclJocUdTRUpUdSI6eyJ0ZX
h0IjoidGhyZXNob2xkIiwic3RhcnQiOjMzMjksImVuZCI6MzMz
OH0sIjh2dWFBb2hKMDVYem1ydEYiOnsidGV4dCI6InRoaXMgaG
FzIHRvIGJlIHN5bmNocm9uaXplZCAhPyBGb3IgaW5zdGFuY2Us
IGJ5IHRoZSBEUk5HLCBtYXliZSBzdGFydCB3aXRoIDEwcyzigK
YiLCJzdGFydCI6Mzc0OCwiZW5kIjozODY5fSwialJJbWFJbzRm
YTVNbzZJWSI6eyJ0ZXh0Ijoic29tZWhvdyBhIHRpbWVyIHRoYX
QgaXMgdXBkYXRlZCBwZXJpb2RpY2FsbHksIGNvbm5lY3RlZCB0
byBgcm91bmRMZW5ndGhgIFRCRCIsInN0YXJ0IjozODg0LCJlbm
QiOjM5NjB9LCJIdFBUSVlvTW9xNFdvTDBvIjp7InRleHQiOiJU
aGUgYWJvdmUgdmFyaWFibGVzIGNhbiBpbiB0aGVvcnkgYmUgY2
hvc2VuIGxvY2FsbHkgZm9yIGVhY2ggbm9kZS4gSG93ZXZlciwg
dGhl4oCmIiwic3RhcnQiOjM5NjIsImVuZCI6NDE4NX0sImJXc0
xzOXFIdkVOM2h1akUiOnsidGV4dCI6InZhcmlhYmxlcyIsInN0
YXJ0Ijo0MzM4LCJlbmQiOjQzNDd9LCJUSDU0SXZSTkpyZ0JDMG
ZFIjp7InRleHQiOiIqIGBtYW5hTGlzdGAgbGlzdCBvZiBtYW5h
IG9mIG5vZGVzXG4qIGBtYW5hYCBkb3VibGUgLSBtYW5hIG9mIG
5vZGUiLCJzdGFydCI6NDM5OSwiZW5kIjo0NDY0fSwiSnJ3SWp1
S2s5ZlBTWGhCcCI6eyJ0ZXh0IjoiYm9vbGVhbiAtIHRyYW5zYW
N0aW9uIHRydWUgb3IgZmFsc2UiLCJzdGFydCI6NDQ3NywiZW5k
Ijo0NTEyfSwiR1phS0VvREMwcjk2ekJFMSI6eyJ0ZXh0IjoiVG
hpcyBmdW5jdGlvbiBkZXBlbmRzIG9uIHRoZSBvbnRvbG9neS4i
LCJzdGFydCI6NjE1NCwiZW5kIjo2MTkyfSwiOHdydVdKOWJiaW
VVTlZ6MyI6eyJ0ZXh0IjoiTm90ZTogZWFjaCBsYXllciIsInN0
YXJ0Ijo2MzExLCJlbmQiOjYzMjd9LCJhQ0pLNG9wWmthWmY0aU
xXIjp7InRleHQiOiJgYT0wLjUsIGI9MS1iZXRhYCIsInN0YXJ0
IjoxMzI0OCwiZW5kIjoxMzI2NX19LCJjb21tZW50cyI6eyI0aG
5Sak9PVzRIaUtNTnZqIjp7ImRpc2N1c3Npb25JZCI6IjBTVjhi
aEtwMWNOckNTN0UiLCJzdWIiOiJnaDo1MTExMjYxOCIsInRleH
QiOiJzbmFwc2hvdHRlZCBtYW5hIHZzIGFsdGVybmF0aXZlcyIs
ImNyZWF0ZWQiOjE1OTY1MjAzMDQ3MjR9LCI5OG84NGttSDM0RE
FjY3VpIjp7ImRpc2N1c3Npb25JZCI6IldTUFBwbFBiSDh0cFU1
bzciLCJzdWIiOiJnaDo1MTExMjYxOCIsInRleHQiOiIhIFRoaX
Mgc2VjdGlvbiBtYXkgY2hhbmdlIChpZiBmYWN0IGJlIGRlbGV0
ZWQpICBpbiBwYXJhbGxlbCByZWFsaXR5IHVuaXZlcnNlLiIsIm
NyZWF0ZWQiOjE1OTY1MjA4Njk1NjF9LCJocURtMUZTbkZlTmpu
WU5sIjp7ImRpc2N1c3Npb25JZCI6IjZsN09ETGVPZkZFaG9rbj
UiLCJzdWIiOiJnaDo1MTExMjYxOCIsInRleHQiOiJEb25lIGlu
IHRoZSBtZWFudGltZSwgbm8gYmFkIHN1cnByaXNlcyIsImNyZW
F0ZWQiOjE1OTY1MjExMTE4OTZ9LCI2QUZubW1OejJ1bkdSUUZK
Ijp7ImRpc2N1c3Npb25JZCI6IjA4bUY3Tzg2RjVHUUdkWmsiLC
JzdWIiOiJnaDo1MTExMjYxOCIsInRleHQiOiJ3ZWxsIGF0IGxl
YXN0IGFuIGluZGljYXRpb24iLCJjcmVhdGVkIjoxNTk2NTIxMj
QxNTMxfSwiZGM2ZzhkQld3WWRMQ0VZWCI6eyJkaXNjdXNzaW9u
SWQiOiIwU1Y4YmhLcDFjTnJDUzdFIiwic3ViIjoiZ2g6NTExMT
I2MTgiLCJ0ZXh0IjoianVzdCBGUENNYW5hIiwiY3JlYXRlZCI6
MTU5NjUyOTk3NzExMX0sInBRTHBXeVdHUmNmZjU2MDEiOnsiZG
lzY3Vzc2lvbklkIjoiOEZXaFlQNzdaSzYwZXBVSyIsInN1YiI6
ImdoOjY4MjUwMzUwIiwidGV4dCI6IkluY29tcGxldGU/IE5lY2
Vzc2FyeT8iLCJjcmVhdGVkIjoxNTk3Nzc2NzkwMjU5fSwicXJ4
d1pSaXFzRUQwNE5nWiI6eyJkaXNjdXNzaW9uSWQiOiJkZlBOND
Y4VUlhRFpXNW1jIiwic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZXh0
IjoiYWRkZWQgYnkgbWUiLCJjcmVhdGVkIjoxNTk3Nzc2ODAxND
ExfSwialFLU1NmbFo5MnhHdk1EeiI6eyJkaXNjdXNzaW9uSWQi
OiJ4YWdMYnNyZkV6OFFKV3ZDIiwic3ViIjoiZ2g6NjgyNTAzNT
AiLCJ0ZXh0IjoiUmVtb3ZlIGFzIG9udG9sb2dpZXMgaW4gbmV2
ZXIgY2xlYXIiLCJjcmVhdGVkIjoxNTk3Nzc2OTI0NTQyfSwieW
0wNzJ4Um1LVXllUVpwRCI6eyJkaXNjdXNzaW9uSWQiOiJTR2o1
SFJVdkNqbkVwUW9mIiwic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZX
h0IjoiVHJhbnNhY3Rpb24gdnMgVmFsdWUgTWVzc2FnZT8iLCJj
cmVhdGVkIjoxNTk3Nzc3Mzg4MTQyfSwiQ1RQbEtGUGRWUmNPR0
VnaiI6eyJkaXNjdXNzaW9uSWQiOiJFN09JUnpVaG4yaWxvdThB
Iiwic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZXh0IjoiSW1jb21wbG
V0ZSIsImNyZWF0ZWQiOjE1OTc3NzgwMDkxMjB9LCI1eXVJeTZY
VlhOZTBMYTA1Ijp7ImRpc2N1c3Npb25JZCI6IldZWjFhV3hxSl
VvQTZpY1UiLCJzdWIiOiJnaDo2ODI1MDM1MCIsInRleHQiOiJJ
cyB0aGlzIDUuMj8iLCJjcmVhdGVkIjoxNTk3Nzc4MTU0MDkwfS
wiQnJid0ZUeHVCc2xBMzJJdSI6eyJkaXNjdXNzaW9uSWQiOiJD
QXlFdURGTkliVmtYQ1gzIiwic3ViIjoiZ2g6NjgyNTAzNTAiLC
J0ZXh0IjoiVGhpcyBpcyBub3QgY292ZXJlZCBoZXJlLCBzaG91
bGQgd2UgcmVmZXIgdG8gNS40PyIsImNyZWF0ZWQiOjE1OTc3Nz
gxOTkyNzh9LCJualJETTZSbU1yWUp2eEEyIjp7ImRpc2N1c3Np
b25JZCI6ImZydmpVU3lKbEtQaEtERDgiLCJzdWIiOiJnaDo2OD
I1MDM1MCIsInRleHQiOiJBbGwgb2YgdGhpcyBpcyBpbmNvbXBs
ZXRlIiwiY3JlYXRlZCI6MTU5Nzc3ODIxODgxN30sIjRnZGc1aW
lMcU90ZGFBNHgiOnsiZGlzY3Vzc2lvbklkIjoiRXN5U2dISHZj
Zm9pWmRXNSIsInN1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6Il
dpbGwgc29tZXRoaW5nIGJlIHdyaXR0ZW4gaGVyZT8iLCJjcmVh
dGVkIjoxNTk3Nzc4MjMzODU5fSwiWWFTQnJ5OE5WNHhuVUVyUy
I6eyJkaXNjdXNzaW9uSWQiOiIwaEZEUGEzQURWMkNRUEo3Iiwi
c3ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZXh0IjoiVGhpcyBzZWN0aW
9uIHNob3VsIGVpdGhlciBiZSBhdCBiZSBiZWdpbm5pbmcgb3Ig
c2tpcHBlZCBpbW8uIFRoZSBkZXBlbmRlbmNpZXMgc2hvdWxkIH
VzZSB0aGUgcHJvcGVyIHJlZmVyZW5jZSB3aGVudCBoZXkgYXBw
ZWFyLiIsImNyZWF0ZWQiOjE1OTc3Nzg0NDQ5ODB9LCJBT1dQaE
I0eFFlODYxUEtDIjp7ImRpc2N1c3Npb25JZCI6IklKemk4eDBI
MERvMHFjaEgiLCJzdWIiOiJnaDo2ODI1MDM1MCIsInRleHQiOi
JTaG91bGQgd2Ugc2F5IHNvbXRoaW5nIGFib3V0IHN5bmNocm9u
b3VzIHZzIEFzeW5jaHJvbm91cz8iLCJjcmVhdGVkIjoxNTk3Nz
c4NTMzMjIxfSwiTWdNQ29ZbXRoenpZeXZLUiI6eyJkaXNjdXNz
aW9uSWQiOiI3MGFuZWMxbmtRdVFyakhKIiwic3ViIjoiZ2g6Nj
gyNTAzNTAiLCJ0ZXh0IjoiR29zc2lwaW5nPyIsImNyZWF0ZWQi
OjE1OTc3Nzg1NjQ5NzN9LCI5ak5VMlo1MjZTNzM2UXg3Ijp7Im
Rpc2N1c3Npb25JZCI6ImlpVnJqZ3JSaHFHU0VKVHUiLCJzdWIi
OiJnaDo2ODI1MDM1MCIsInRleHQiOiJUaHJlc2hvbGQgb2YgdG
hlIHByb3BvcnRpb24gb2Ygb3BpbmlvbnMiLCJjcmVhdGVkIjox
NTk3Nzc5NDMwOTYyfSwidkVIOHgxZjNjTjFoeG1rcCI6eyJkaX
NjdXNzaW9uSWQiOiI4dnVhQW9oSjA1WHptcnRGIiwic3ViIjoi
Z2g6NjgyNTAzNTAiLCJ0ZXh0IjoiRGVsZXRlIHRoaXM/IiwiY3
JlYXRlZCI6MTU5Nzc4Mjk3NzczNH0sImd6Uzg2Y3Bqd2ZQUm84
NGEiOnsiZGlzY3Vzc2lvbklkIjoialJJbWFJbzRmYTVNbzZJWS
IsInN1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6Ik5vdCBDbGVh
ciIsImNyZWF0ZWQiOjE1OTc3ODMxMTc2Njl9LCJZWHlubzlIdj
lnTlJhMUNmIjp7ImRpc2N1c3Npb25JZCI6Ikh0UFRJWW9Nb3E0
V29MMG8iLCJzdWIiOiJnaDo2ODI1MDM1MCIsInRleHQiOiJTby
BzaG91bGQgd2UgYWxsb3cgdGhpcz8gSWYgbm90IHNob3VsZCB0
aGlzIGJlIHNhaWQ/IiwiY3JlYXRlZCI6MTU5Nzc4MzE3MjYyNH
0sIlVxbEFHWkVDanpoNTFNRUQiOnsiZGlzY3Vzc2lvbklkIjoi
YldzTHM5cUh2RU4zaHVqRSIsInN1YiI6ImdoOjY4MjUwMzUwIi
widGV4dCI6IklzIHRoYXQgdGhlIGJlc3Qgd29yZCB0byB1c2U/
IEFzIGFuIGV4YW1wbGUgXCJPcGluaW9uXCIgaXMgYSByZWxhdG
lvbiBiZXR3ZWVuIG5vZGUgYW5kIFRyYW5zYWN0aW9uLiBUaGlz
IG1lYW5zIHRoZSBub2RlIGRvbnQgaGF2ZSBvbmUgT3Bpbmlvbi
wgYnV0IG9uZSBwZXIgdHJhbnNhY3Rpb24uIiwiY3JlYXRlZCI6
MTU5Nzc4Mzk1MTg3OH0sIkducDhxMDF1bWZpVXU3ek4iOnsiZG
lzY3Vzc2lvbklkIjoiVEg1NEl2Uk5KcmdCQzBmRSIsInN1YiI6
ImdoOjY4MjUwMzUwIiwidGV4dCI6IlNob3VsZCB0aGlzIGJlIH
VwZGF0ZWQgd2l0aCB0aGUga2luZCBvZiBtYW5hPyIsImNyZWF0
ZWQiOjE1OTc3ODM5ODM3NzB9LCJrendCeXo0RUVrdUJvaTNHIj
p7ImRpc2N1c3Npb25JZCI6Ikpyd0lqdUtrOWZQU1hoQnAiLCJz
dWIiOiJnaDo2ODI1MDM1MCIsInRleHQiOiJJdHMgdHdpY2UgaW
4gdGhlIGxpc3QiLCJjcmVhdGVkIjoxNTk3NzgzOTk3ODYzfSwi
Ym9iZWtBcjRDd0VKOU1KaSI6eyJkaXNjdXNzaW9uSWQiOiJHWm
FLRW9EQzByOTZ6QkUxIiwic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0
ZXh0IjoiQ29uZnVzaW5nIGFzIE9udG9sb2d5IGlzIG5vdCBkZW
ZpbmVkIiwiY3JlYXRlZCI6MTU5Nzc4NDIwNDg4MH0sImN1eWc5
SGVnMEdjVERTQUoiOnsiZGlzY3Vzc2lvbklkIjoiOHdydVdKOW
JiaWVVTlZ6MyIsInN1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6
IkxheWVyIGlzIG5vdCB3ZWxsIGRlZmluZWQiLCJjcmVhdGVkIj
oxNTk3Nzk1NjcwNzc5fSwiNUFlQjJaOTBwRHV4ZFBNbSI6eyJk
aXNjdXNzaW9uSWQiOiJhQ0pLNG9wWmthWmY0aUxXIiwic3ViIj
oiZ2g6NjgyNTAzNTAiLCJ0ZXh0Ijoic3ltYm9scyBub3QgaW4g
YWNjb3JkYW5jZSB0byB0aGUgZGVmaW5lZCBwYXJhbWV0ZXJzIi
wiY3JlYXRlZCI6MTU5Nzc5NzQzMDQ2OX19LCJoaXN0b3J5Ijpb
LTY4NjEwNTc5NSwxNjA1MzYwMjc3LC0zMDI2MjgzNDMsMTY0Nz
M5MTY2OCwtNDU2NjIzMTIsMTMwODQyMzU3NSwxMDAzOTk5NTc2
LC0xNTQxMjQ2MTM2LDk1OTAxMjIxMywxMzM3NjQ5NzA0LDU0Nj
ExMTAxOCwtNDM3NDg1MzM0LDQwNjE0NDk1NSw2MjMyNDE1NTIs
MTM1NjE0ODY4LDg1MDAyMzgzNywtMTMwNzYyNjYzXX0=
-->