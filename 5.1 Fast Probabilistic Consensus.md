+ Feature name:  FPC specifications
+ Start date: 2020-03-16

# 5.1 FPC specification


The module presented in this specification, FPC, allows nodes to find consensus on whether a transaction is valid or not. 

The specification will be subdivided into the following subsections:

1. **The core FPC protocol: our basic consensus protocol on binary opinions. It may be used on different layers and kinds of messages. 
2. FPC on Tangle: opinions on transaction of the tangle become dependent. This parts specifies monotonicity and consistency rules.
3. Message compression: reducing message complexity through message compression and reducing overhead of demanded nodes by gossiping of opinions.
4. Gossiping:
5. Protocol monitoring: information every node store for monitoring the main net.
6. Testing: This section discusses how the protocol is tested. It subdivides into two parts: testing the logic and test behavior in Byzantine infrastructure.
 

# 5.1.1 Motivation

# 5.1.2 Dependencies
The FPC module depends on the following other modules:
> [name=Sebastian MuFinalizationThresholder, time=Fri, Jun 19, 2020 10:42 AM] wait until respecive specs are available then synronize

 - 4.3 Mana (to obtain list of mana)
 - 5.3 dRNG (to obtain random number)
  - 5.4 Resynchronization  
  - 3.2 Finality
  - 1.2 Communication Specifications  Payloads and Ontologies 
  - 4.2 UTXO and Realities calculations
  - 2.1 Autopeering (to obtain a list of nodes)  Rate control (gossiping of high mana nodes, do FPC messages need to pass rate control?)

# 5.1.3 Remarks
FPC on tangle is essentially a consensus on "time". At various parts local clocks will be used and compared to timestamps of messages. There are general standing assumption on network latency and clock synchronizations. In a nutshell, they are that the differences in clocks are at least one order of magnitude lower than the network latency. 


# 5.1.4 The core FPC

The protocol tries to find consensus on the validity of a transaction `objectID`. Every node has an initial opinion `opinion`(boolean) on this transaction. These opinions are updated in rounds until the protocol terminates using a local stopping rule. 

## 5.1.4.1 Protocol variables

We define the type `Opinion`. 
```
Opinion: {
    DISLIKE: 0,
    LIKE: 1,
    NULL: NULL  #The node does not know about the object,
    NA : NA # a node does not receive an answer of the opinion of another node
}
```



* `FinalizationThreshold` integer - number of consecutive rounds before FPC auto-terminates
* `FinalizationThreshold2` integer - number of consecutive rounds with non-random threshold
* `FirstRoundThreshold`  double - threshold in first round
* `SubsequentRoundsLowerBoundThreshold` double -  lower random threshold bound in subsequent rounds
*  `SubsequentRoundsUpperBoundThreshold` double -  upper random threshold bound in subsequent rounds
* `maxRound` integer - maximal number of rounds before querying stops
* `querySize` integer - quorum size, number of nodes that are queries
* `roundLength` double - length (in sec) of a round, this has to be synchronized !? For instance, by the DRNG, maybe start with 10s, and FPC only uses DRNG every second round
* `timeOut` - somehow a timer that is updated periodically, connected to `roundLength` TBD

The above variables can in theory be chosen locally for each node. However, the security of the protocol depends on that they are chosen in a reasonable way. The best is if these variables are chosen the same for every node. The IF recommends to use the default values.

IF default/recommendation values are:

TO COME

## 5.1.4.2 Local variables

Every node has the following variables
* `opinion` Opinion
* `nodeList` list of all nodes
* `manaList` list of mana of nodes
* `mana` double - mana of node
* `opinion` boolean - transaction true or false
* `cnt` integer - counter that counts the number of consecutives rounds with unchanged opinion
* `queryStatus` boolean - status if actively querying
* `answerStatus` boolean - status if answerying queries, default value here is `TRUE`
* `round` integer - counts number of rounds in FPC
* `rn` double - random number from dRNG
* `rnCycle` double - random number instance (random numbers are produced at a certain period, this variable counts the current cycle) (-> connect to dRNG)
* `queryList`- list of nodes to query
* `opinionQuery` - list of opinion of nodes in `queryList`, nonreplies are encoded with `NA`
* `reachedMaxRound` boolean - indicating whether protocl reached `maxRound` before auto-termination, default calue `FALSE`
> [name=Sebastian Mueller] Present the above in a table?


## 5.1.4.3 Functions that are called
* `getIninitialOpinion` input: `objectID` output: opinion
* `getRN` input: `rnCycle` output: `rn`
* `getNodes` input:   output: `nodeList`
* `getMana` input: `nodeList` output: `manaList`
* `getSample` input: `querySize` `nodeList` `manaList` : output `queryList`
* `getOpinion` input: `objectID` `queryList` output: `opinionQuery`
* `checkQuerySuccessful` input: `queryList` `opinionQuery` output: `querySuccessful`: c*hecks whether `opinionQuery` from `getOpinion` contains enough answers*
*  `opinionUpdate` input: queryStatus output: `opinion` 
> [name=Sebastian Mueller] How do we write functions? Compare to https://hackmd.io/1oJWLLMPRmaA-GkgWJPi0Q.
## 5.1.4.4 Pseudocode 
 
Note: In the pseudocode at various places global variables are again used as input for the functions. 

### `getInitialOpinion`

This function depends on the ontology. 

### `getRN(layer, a, b, time)`
```
gets a uniform random number between (a,b),
to come, to be discussed with DRNG, 
Note: each layer may use a different random number

OUTPUT: randomThreshold, source of randomness
```

### `getNodes` 
This function should be defined somewhere in autopeering module?

### `getMana`

This function may be specified in Mana part


### `getSample(querySize, nodeList, manaList)`
```
queryList = empty
while (queryList does not contain querySize different element){
newSample:=Sample(nodeList, weight=mana, replacement=TRUE)
queryList = concat(queryList, newSample)
}
return queryList
```

### `getOpinion(queryList, timeOut)`

```
send queries to all nodes of queryList
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
return opinionQuery
```

### `checkQuerySuccessful(queryList, opinionQuery)`
```
# `manaMin` double - minimal mana of answers that have to arrive before new random number is issued  -> change to function
manaMin:=0.5 #at least 50% of the queried mana has to reply; this value may be changed
queriedMana := sum(manaList[queryList])
answerMana :=  sum(manaList[queryList[replied==TRUE]])/queriedMana
querySuccessful := ifElse( answerMana>= manaMin, TRUE, False)
return querySuccessful
```

### `sendOpinion(timeOut)`

```
answer queries that arrive before timeOut
```


### `opinionUpdate(layer, opinion, querySize, nodeList, manaList, FirstRoundThreshold, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)`
```
Sample :=getSample(querySize, nodeList, manaList)
opinionQuery := getOpinion(queryList, timeOut)
if (!checkQuerySuccessful(queryList, opinionQuery)){ #check if sufficiently many nodes replied in time
    newOpinion := opinion # if not keep old opinion 
}
else{ # otherwise update according to FPC rule
    etaStar := mean(opinionQuery, NA.remove=TRUE)
    totalMana := sum(listMana, NA.remove=TRUE) # remove nodes that did not answer
    eta := opinion*mana + etaStar*(totalMana-mana)/totalMana
    if (round == 1){ #first FPC round uses different threshold
        if (eta < FirstRoundThreshold){
            newOpinion <-0
        }
        else newOpinion <-1
    }
    else #the subsequent rounds (before the FinalizationThreshold2 confirming) use random threshold
        rn := getRN(layer, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, time)  # here we have to synchronize/wait for random number
        if (eta < rn){
            newOpinion <-0
        }
        else newOpinion <-1       
}

return newOpinion 
```


### `mainFPC(objectId, queryStatus)`
```
if (queryStatus turns TRUE ){ 
    opinion := getInitialOpinion(objectID)
    listMana := getMana()
    listNode := getNodes()
    cnt := 1
}
wait for new FPC round # next random number from dRNG
#start the first FPC round
round := 1 
opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, FirstRoundThreshold, ubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)
if (opinion==opinionNew) cnt++
else cnt:=0
opinion := opinionNew
round++

#continue FPC, subsequent rounds 
while queryStatus {
    if (cnt <= FinalizationThreshold-FinalizationThreshold2) # we use random threshold{
        opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, FirstRoundThreshold, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)
        if (opinion==opinionNew) cnt++
        else cnt:=0
        opinion := opinionNew
    }
    else {  # we use deterministic threshold for FinalizationThreshold2 "confirming" rounds
    opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, 0.5, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, 1, time)
        if (opinion==opinionNew) cnt++
        else cnt:=0
        opinion := opinionNew      
    }
    round++
    if (cnt==FinalizationThreshold) queryStatus:=FALSE
    if (round>=MaxRound) {
        queryStatus:=FALSE
        reachedMaxRound:=TRUE
    }
}
return(opinion)
```

## 5.1.4.5 Message/transaction layout


### Querying message

### Answering message
This is done in the next section.

# 5.1.5 FPC on tangle

In the tangle reality FPC may have to be applied to various messages simultaneously. Moreover, the tangle (the local view of every node) has to be monotone and consistent. We have to address the three following points:
* **Parallelity:** Many ongoing votings at the same time 
* **Consistency:** Layer should not contain contradicting messages
* **Monotonicity:** Liked  messages should not refer to disliked messages

## 5.1.5.1 Parallelity
At every round FPC decides on possibly several opinions. However, the every node will only query other nodes once (!). This is done for scalability. 

The local variable `opinions` records the vector of all opinions under vote. 

### `getInitialOpinions`

This function depends on the ontology and uses `getInitialOpinions` in a straightforward way.


### `getOpinions(queryList, timeOut)`
```
send queries to all nodes of queryList
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
return opinionsQuery
```
FPC is now applied for each opinion separately. This may not be optimal, but this is addressed in Section 3. It may that the outcome is not consistent or monotone. 


### single vs. multiple dRNG in each round

Discussion: using a different threshold for every opinion (e.g. hash(objectID) X hash(rn)) may lead to the following attack vector. If the number of votings is large then with high probability some of the will always have a random threshold close to 0.5, in other words for a random subset of tx there is no random threshold and hence the protocol is unsafe. 

Advantage of using the same random threshold is also that the two following functions have less to do, i.e., monotonicity and consistency is increased.

It may be good to use different random thresholds for the voting on different layers! (-> `getRN()`)

## 5.1.5.2 Consistency and Monotonicity

### `applyMonotonicityRule()`
```
functions that make temporary ledger state monoton, past cone of liked tx are like, future cones of disliked tx dislike, generalize these rules to level of knowledge -> Billy
```

### `applyConsistencyRule()`
```
functions that make temporary ledger state consistent
if two contradiction transaction are liked, choose the one with the higher mana (?)/ the previous favorite/ hash?
```
## 5.1.5.3 Data layer
FPC is used in the data layer to decide on the validity of the timestamp of a message. We can use here a symmetric range of the random threshold, `a=beta, b=1-beta`



## 5.1.5.4 Value layer
FPC decides in particular between two conflicting transaction, thresholds below 0.5 may lead to liking both transaction after voting. TO DISCUSS: asymmetric random threshold `a=0.5, b=1-beta`. Since there are no simulations yet, it lay be good to run some to check performances. 


# 5.1.6 Message compression of FPC


## 5.1.6.1 Compression in query messages
**Query:** reduce message identifier, e.g., Prefix trie or Cuckoo filter
**Answer:** Bitmask, respond in same order with 1bit per message

# 5.1.7 Gossiping
High mana nodes will be queried too often. They have the possibility to gossip their opinion. However, it is yet not clear who will  be allowed to gossip. 

### Everybody can gossip
This solution follows the idea that IOTA is all but freedom. Every node can decide on his own whether to gossip or not. Nevertheless, IF has to propose a reference implementation.

Advantages:
* if not in place, high mana nodes may be spammed by querries. But is this a reasonable concern for Coordicide 1.0?

Disadvantages: 
* local optimum may not be global optimum
* if all nodes gossip, network may reach congestion. But is this a reasonable concern for Coordicide 1.0?

### Threshold for gossiping

There is a global threshold, like the 100 top mana holders can gossip, the others are querying. However, mana perception is local and hence the threshold can't be sharp. 


### Proposal
TO DISCUSS
* every node is free to gossip
* nodes who gossip, close the port corresponding to queries, this allows other nodes to see whether this node gossips, 
* in IF reference implementation: if own mana perception is above a certain threshold, that would lead to overquery, then gossip

### Changes in the FPC protocol

Warning: the code may depend on the above decision who is going to gossip their opinion. 
### `getOpinions(queryList, timeOut)`
```
send queries to all nodes of queryList that do not gossip
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
read opinions from tangle of all to all nodes of queryList that do gossip

return opinionsQuery
```
Edge cases: what happens if gossiping node is queried? (Angelo: not reply at all, you even don t listen (close ports), Seb: be kind if possible).

If node has to gossip but is not?

# 5.1.7  Protocol monitoring




# 5.1.8 Testing

## 5.1.8.1 Edge cases

## 5.1.8.2 Spamming

## 5.1.8.3 Adversarial strategies

<!--stackedit_data:
eyJkaXNjdXNzaW9ucyI6eyIwU1Y4YmhLcDFjTnJDUzdFIjp7In
RleHQiOiJNYW5hICh0byBvYnRhaW4gbGlzdCBvZiBtYW5hKSIs
InN0YXJ0IjoxMTkwLCJlbmQiOjEyMTl9LCJXU1BQcGxQYkg4dH
BVNW83Ijp7InRleHQiOiIjIDUuMS41IEZQQyBvbiB0YW5nbGUi
LCJzdGFydCI6OTc5NSwiZW5kIjo5ODE2fSwiNmw3T0RMZU9mRk
Vob2tuNSI6eyJ0ZXh0IjoiU2luY2UgdGhlcmUgYXJlIG5vIHNp
bXVsYXRpb25zIHlldCwgaXQgbGF5IGJlIGdvb2QgdG8gcnVuIH
NvbWUgdG8gY2hlY2sgcGVyZm9ybeKApiIsInN0YXJ0IjoxMjU5
MCwiZW5kIjoxMjY3NX0sIjA4bUY3Tzg2RjVHUUdkWmsiOnsidG
V4dCI6Im5vZGUgZ29zc2lwcywiLCJzdGFydCI6MTM5MzMsImVu
ZCI6MTM5NDZ9LCJ4YWdMYnNyZkV6OFFKV3ZDIjp7InRleHQiOi
JJdCBtYXkgc2VydmUgb24gdmFyaW91cyBvbnRvbG9naWVzIGFz
IGNvbnNlbnN1cyBwcm90b2NvbC4iLCJzdGFydCI6MzU5LCJlbm
QiOjM2MH0sIlNHajVIUlV2Q2puRXBRb2YiOnsidGV4dCI6InRy
YW5zYWN0aW9uIiwic3RhcnQiOjQ0OCwiZW5kIjo0NTl9LCJXWV
oxYVd4cUpVb0E2aWNVIjp7InRleHQiOiI0LiBwcm90b2NvbCBp
bnRlcmZhY2U6IGRhdGEgbGF5ZXIgYW5kIHZhbHVlIGxheWVyLi
BUaGlzIHBhcnQgc3BlY2lmaWVzIHdoZW4gRlBD4oCmIiwic3Rh
cnQiOjY5NiwiZW5kIjo2OTZ9LCJDQXlFdURGTkliVmtYQ1gzIj
p7InRleHQiOiJSZXN5bmNocm9uaXphdGlvbiBpbnRlcmZhY2U6
IGlmIHByb3RvY29sIGRvZXMgbm90IGF1dG8tdGVybWluYXRlIC
0+IHJlc3luY2hyb25p4oCmIiwic3RhcnQiOjY5NiwiZW5kIjo2
OTZ9LCJFc3lTZ0hIdmNmb2laZFc1Ijp7InRleHQiOiIjIDUuMS
4xIE1vdGl2YXRpb24iLCJzdGFydCI6OTUyLCJlbmQiOjk3MH0s
IjBoRkRQYTNBRFYyQ1FQSjciOnsidGV4dCI6IiMgNS4xLjIgRG
VwZW5kZW5jaWVzIiwic3RhcnQiOjk3MiwiZW5kIjo5OTJ9LCJJ
SnppOHgwSDBEbzBxY2hIIjp7InRleHQiOiJGUEMgb24gdGFuZ2
xlIGlzIGVzc2VudGlhbGx5IGEgY29uc2Vuc3VzIG9uIFwidGlt
ZVwiLiBBdCB2YXJpb3VzIHBhcnRzIGxvY2FsIGNsb2PigKYiLC
JzdGFydCI6MTU2MCwiZW5kIjoxOTAyfSwiNzBhbmVjMW5rUXVR
cmpISiI6eyJ0ZXh0IjoiOS4iLCJzdGFydCI6OTQ5LCJlbmQiOj
k0OX0sImlpVnJqZ3JSaHFHU0VKVHUiOnsidGV4dCI6InRocmVz
aG9sZCIsInN0YXJ0IjoyNjUyLCJlbmQiOjI2NjF9LCI4dnVhQW
9oSjA1WHptcnRGIjp7InRleHQiOiJ0aGlzIGhhcyB0byBiZSBz
eW5jaHJvbml6ZWQgIT8gRm9yIGluc3RhbmNlLCBieSB0aGUgRF
JORywgbWF5YmUgc3RhcnQgd2l0aCAxMHMs4oCmIiwic3RhcnQi
OjMwNzEsImVuZCI6MzE5Mn0sImpSSW1hSW80ZmE1TW82SVkiOn
sidGV4dCI6InNvbWVob3cgYSB0aW1lciB0aGF0IGlzIHVwZGF0
ZWQgcGVyaW9kaWNhbGx5LCBjb25uZWN0ZWQgdG8gYHJvdW5kTG
VuZ3RoYCBUQkQiLCJzdGFydCI6MzIwNywiZW5kIjozMjgzfSwi
SHRQVElZb01vcTRXb0wwbyI6eyJ0ZXh0IjoiVGhlIGFib3ZlIH
ZhcmlhYmxlcyBjYW4gaW4gdGhlb3J5IGJlIGNob3NlbiBsb2Nh
bGx5IGZvciBlYWNoIG5vZGUuIEhvd2V2ZXIsIHRoZeKApiIsIn
N0YXJ0IjozMjg1LCJlbmQiOjM1MDh9LCJiV3NMczlxSHZFTjNo
dWpFIjp7InRleHQiOiJ2YXJpYWJsZXMiLCJzdGFydCI6MzY2MS
wiZW5kIjozNjcwfSwiVEg1NEl2Uk5KcmdCQzBmRSI6eyJ0ZXh0
IjoiKiBgbWFuYUxpc3RgIGxpc3Qgb2YgbWFuYSBvZiBub2Rlc1
xuKiBgbWFuYWAgZG91YmxlIC0gbWFuYSBvZiBub2RlIiwic3Rh
cnQiOjM3MjIsImVuZCI6Mzc4N30sIkpyd0lqdUtrOWZQU1hoQn
AiOnsidGV4dCI6ImJvb2xlYW4gLSB0cmFuc2FjdGlvbiB0cnVl
IG9yIGZhbHNlIiwic3RhcnQiOjM4MDAsImVuZCI6MzgzNX0sIk
daYUtFb0RDMHI5NnpCRTEiOnsidGV4dCI6IlRoaXMgZnVuY3Rp
b24gZGVwZW5kcyBvbiB0aGUgb250b2xvZ3kuIiwic3RhcnQiOj
U0NzcsImVuZCI6NTUxNX0sIjh3cnVXSjliYmllVU5WejMiOnsi
dGV4dCI6Ik5vdGU6IGVhY2ggbGF5ZXIiLCJzdGFydCI6NTYzNC
wiZW5kIjo1NjUwfSwiYUNKSzRvcFprYVpmNGlMVyI6eyJ0ZXh0
IjoiYGE9MC41LCBiPTEtYmV0YWAiLCJzdGFydCI6MTI1NzEsIm
VuZCI6MTI1ODh9fSwiY29tbWVudHMiOnsiNGhuUmpPT1c0SGlL
TU52aiI6eyJkaXNjdXNzaW9uSWQiOiIwU1Y4YmhLcDFjTnJDUz
dFIiwic3ViIjoiZ2g6NTExMTI2MTgiLCJ0ZXh0Ijoic25hcHNo
b3R0ZWQgbWFuYSB2cyBhbHRlcm5hdGl2ZXMiLCJjcmVhdGVkIj
oxNTk2NTIwMzA0NzI0fSwiOThvODRrbUgzNERBY2N1aSI6eyJk
aXNjdXNzaW9uSWQiOiJXU1BQcGxQYkg4dHBVNW83Iiwic3ViIj
oiZ2g6NTExMTI2MTgiLCJ0ZXh0IjoiISBUaGlzIHNlY3Rpb24g
bWF5IGNoYW5nZSAoaWYgZmFjdCBiZSBkZWxldGVkKSAgaW4gcG
FyYWxsZWwgcmVhbGl0eSB1bml2ZXJzZS4iLCJjcmVhdGVkIjox
NTk2NTIwODY5NTYxfSwiaHFEbTFGU25GZU5qbllObCI6eyJkaX
NjdXNzaW9uSWQiOiI2bDdPRExlT2ZGRWhva241Iiwic3ViIjoi
Z2g6NTExMTI2MTgiLCJ0ZXh0IjoiRG9uZSBpbiB0aGUgbWVhbn
RpbWUsIG5vIGJhZCBzdXJwcmlzZXMiLCJjcmVhdGVkIjoxNTk2
NTIxMTExODk2fSwiNkFGbm1tTnoydW5HUlFGSiI6eyJkaXNjdX
NzaW9uSWQiOiIwOG1GN084NkY1R1FHZFprIiwic3ViIjoiZ2g6
NTExMTI2MTgiLCJ0ZXh0Ijoid2VsbCBhdCBsZWFzdCBhbiBpbm
RpY2F0aW9uIiwiY3JlYXRlZCI6MTU5NjUyMTI0MTUzMX0sImRj
Nmc4ZEJXd1lkTENFWVgiOnsiZGlzY3Vzc2lvbklkIjoiMFNWOG
JoS3AxY05yQ1M3RSIsInN1YiI6ImdoOjUxMTEyNjE4IiwidGV4
dCI6Imp1c3QgRlBDTWFuYSIsImNyZWF0ZWQiOjE1OTY1Mjk5Nz
cxMTF9LCJqUUtTU2ZsWjkyeEd2TUR6Ijp7ImRpc2N1c3Npb25J
ZCI6InhhZ0xic3JmRXo4UUpXdkMiLCJzdWIiOiJnaDo2ODI1MD
M1MCIsInRleHQiOiJSZW1vdmUgYXMgb250b2xvZ2llcyBpbiBu
ZXZlciBjbGVhciIsImNyZWF0ZWQiOjE1OTc3NzY5MjQ1NDJ9LC
J5bTA3MnhSbUtVeWVRWnBEIjp7ImRpc2N1c3Npb25JZCI6IlNH
ajVIUlV2Q2puRXBRb2YiLCJzdWIiOiJnaDo2ODI1MDM1MCIsIn
RleHQiOiJUcmFuc2FjdGlvbiB2cyBWYWx1ZSBNZXNzYWdlPyIs
ImNyZWF0ZWQiOjE1OTc3NzczODgxNDJ9LCI1eXVJeTZYVlhOZT
BMYTA1Ijp7ImRpc2N1c3Npb25JZCI6IldZWjFhV3hxSlVvQTZp
Y1UiLCJzdWIiOiJnaDo2ODI1MDM1MCIsInRleHQiOiJJcyB0aG
lzIDUuMj8iLCJjcmVhdGVkIjoxNTk3Nzc4MTU0MDkwfSwiQnJi
d0ZUeHVCc2xBMzJJdSI6eyJkaXNjdXNzaW9uSWQiOiJDQXlFdU
RGTkliVmtYQ1gzIiwic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZXh0
IjoiVGhpcyBpcyBub3QgY292ZXJlZCBoZXJlLCBzaG91bGQgd2
UgcmVmZXIgdG8gNS40PyIsImNyZWF0ZWQiOjE1OTc3NzgxOTky
Nzh9LCI0Z2RnNWlpTHFPdGRhQTR4Ijp7ImRpc2N1c3Npb25JZC
I6IkVzeVNnSEh2Y2ZvaVpkVzUiLCJzdWIiOiJnaDo2ODI1MDM1
MCIsInRleHQiOiJXaWxsIHNvbWV0aGluZyBiZSB3cml0dGVuIG
hlcmU/IiwiY3JlYXRlZCI6MTU5Nzc3ODIzMzg1OX0sIllhU0Jy
eThOVjR4blVFclMiOnsiZGlzY3Vzc2lvbklkIjoiMGhGRFBhM0
FEVjJDUVBKNyIsInN1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6
IlRoaXMgc2VjdGlvbiBzaG91bCBlaXRoZXIgYmUgYXQgYmUgYm
VnaW5uaW5nIG9yIHNraXBwZWQgaW1vLiBUaGUgZGVwZW5kZW5j
aWVzIHNob3VsZCB1c2UgdGhlIHByb3BlciByZWZlcmVuY2Ugd2
hlbnQgaGV5IGFwcGVhci4iLCJjcmVhdGVkIjoxNTk3Nzc4NDQ0
OTgwfSwiQU9XUGhCNHhRZTg2MVBLQyI6eyJkaXNjdXNzaW9uSW
QiOiJJSnppOHgwSDBEbzBxY2hIIiwic3ViIjoiZ2g6NjgyNTAz
NTAiLCJ0ZXh0IjoiU2hvdWxkIHdlIHNheSBzb210aGluZyBhYm
91dCBzeW5jaHJvbm91cyB2cyBBc3luY2hyb25vdXM/IiwiY3Jl
YXRlZCI6MTU5Nzc3ODUzMzIyMX0sIk1nTUNvWW10aHp6WXl2S1
IiOnsiZGlzY3Vzc2lvbklkIjoiNzBhbmVjMW5rUXVRcmpISiIs
InN1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6Ikdvc3NpcGluZz
8iLCJjcmVhdGVkIjoxNTk3Nzc4NTY0OTczfSwiOWpOVTJaNTI2
UzczNlF4NyI6eyJkaXNjdXNzaW9uSWQiOiJpaVZyamdyUmhxR1
NFSlR1Iiwic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZXh0IjoiVGhy
ZXNob2xkIG9mIHRoZSBwcm9wb3J0aW9uIG9mIG9waW5pb25zIi
wiY3JlYXRlZCI6MTU5Nzc3OTQzMDk2Mn0sInZFSDh4MWYzY04x
aHhta3AiOnsiZGlzY3Vzc2lvbklkIjoiOHZ1YUFvaEowNVh6bX
J0RiIsInN1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6IkRlbGV0
ZSB0aGlzPyIsImNyZWF0ZWQiOjE1OTc3ODI5Nzc3MzR9LCJnel
M4NmNwandmUFJvODRhIjp7ImRpc2N1c3Npb25JZCI6ImpSSW1h
SW80ZmE1TW82SVkiLCJzdWIiOiJnaDo2ODI1MDM1MCIsInRleH
QiOiJOb3QgQ2xlYXIiLCJjcmVhdGVkIjoxNTk3NzgzMTE3NjY5
fSwiWVh5bm85SHY5Z05SYTFDZiI6eyJkaXNjdXNzaW9uSWQiOi
JIdFBUSVlvTW9xNFdvTDBvIiwic3ViIjoiZ2g6NjgyNTAzNTAi
LCJ0ZXh0IjoiU28gc2hvdWxkIHdlIGFsbG93IHRoaXM/IElmIG
5vdCBzaG91bGQgdGhpcyBiZSBzYWlkPyIsImNyZWF0ZWQiOjE1
OTc3ODMxNzI2MjR9LCJVcWxBR1pFQ2p6aDUxTUVEIjp7ImRpc2
N1c3Npb25JZCI6ImJXc0xzOXFIdkVOM2h1akUiLCJzdWIiOiJn
aDo2ODI1MDM1MCIsInRleHQiOiJJcyB0aGF0IHRoZSBiZXN0IH
dvcmQgdG8gdXNlPyBBcyBhbiBleGFtcGxlIFwiT3Bpbmlvblwi
IGlzIGEgcmVsYXRpb24gYmV0d2VlbiBub2RlIGFuZCBUcmFuc2
FjdGlvbi4gVGhpcyBtZWFucyB0aGUgbm9kZSBkb250IGhhdmUg
b25lIE9waW5pb24sIGJ1dCBvbmUgcGVyIHRyYW5zYWN0aW9uLi
IsImNyZWF0ZWQiOjE1OTc3ODM5NTE4Nzh9LCJHbnA4cTAxdW1m
aVV1N3pOIjp7ImRpc2N1c3Npb25JZCI6IlRINTRJdlJOSnJnQk
MwZkUiLCJzdWIiOiJnaDo2ODI1MDM1MCIsInRleHQiOiJTaG91
bGQgdGhpcyBiZSB1cGRhdGVkIHdpdGggdGhlIGtpbmQgb2YgbW
FuYT8iLCJjcmVhdGVkIjoxNTk3NzgzOTgzNzcwfSwia3p3Qnl6
NEVFa3VCb2kzRyI6eyJkaXNjdXNzaW9uSWQiOiJKcndJanVLaz
lmUFNYaEJwIiwic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZXh0Ijoi
SXRzIHR3aWNlIGluIHRoZSBsaXN0IiwiY3JlYXRlZCI6MTU5Nz
c4Mzk5Nzg2M30sImJvYmVrQXI0Q3dFSjlNSmkiOnsiZGlzY3Vz
c2lvbklkIjoiR1phS0VvREMwcjk2ekJFMSIsInN1YiI6ImdoOj
Y4MjUwMzUwIiwidGV4dCI6IkNvbmZ1c2luZyBhcyBPbnRvbG9n
eSBpcyBub3QgZGVmaW5lZCIsImNyZWF0ZWQiOjE1OTc3ODQyMD
Q4ODB9LCJjdXlnOUhlZzBHY1REU0FKIjp7ImRpc2N1c3Npb25J
ZCI6Ijh3cnVXSjliYmllVU5WejMiLCJzdWIiOiJnaDo2ODI1MD
M1MCIsInRleHQiOiJMYXllciBpcyBub3Qgd2VsbCBkZWZpbmVk
IiwiY3JlYXRlZCI6MTU5Nzc5NTY3MDc3OX0sIjVBZUIyWjkwcE
R1eGRQTW0iOnsiZGlzY3Vzc2lvbklkIjoiYUNKSzRvcFprYVpm
NGlMVyIsInN1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6InN5bW
JvbHMgbm90IGluIGFjY29yZGFuY2UgdG8gdGhlIGRlZmluZWQg
cGFyYW1ldGVycyIsImNyZWF0ZWQiOjE1OTc3OTc0MzA0Njl9fS
wiaGlzdG9yeSI6WzE4Nzc4Njc3MDksLTQ4MjIyMTQ4LDE2MDUz
NjAyNzcsLTMwMjYyODM0MywxNjQ3MzkxNjY4LC00NTY2MjMxMi
wxMzA4NDIzNTc1LDEwMDM5OTk1NzYsLTE1NDEyNDYxMzYsOTU5
MDEyMjEzLDEzMzc2NDk3MDQsNTQ2MTExMDE4LC00Mzc0ODUzMz
QsNDA2MTQ0OTU1LDYyMzI0MTU1MiwxMzU2MTQ4NjgsODUwMDIz
ODM3LC0xMzA3NjI2NjNdfQ==
-->