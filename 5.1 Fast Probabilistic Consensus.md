+ Feature name:  FPC specifications
+ Start date: 2020-03-16

# 5.1 FPC specification


The module presented in this specification, FPC, allows nodes to find consensus on whether a transaction is valid or not. 

The specification will be subdivided into the following subsections:

1. The core FPC protocol: our basic consensus protocol on binary opinions. It may be used on di
2. FPC on tangle: opinions on transaction of the tangle become dependent. This parts specifies monotonicity and consistency rules.
3. message compression of FPC: reducing message complexity through message compression and gossiping of opinions for high mana nodes. This part has to be updated and revised due to the parallel reality approach.
4. protocol interface: data layer and value layer. This part specifies when FPC is started; it defines how the variables `queryStatus` and `answerStatus` are set. Also function`getInitialOpinion`has to be specified.  -> This part should essentially be covered by Billy.
5. Resynchronization interface: if protocol does not auto-terminate -> resynchronization
6. Berserk detection: mechanism that allows the detection of Berserk behavior. This part may be integrated later on. This depends on how we do proceed with reporting malicious behavior etc.
7. Protocol monitoring: information every node saves for testing of the protocol (in test net, finding optimal parameter sets) and for monitoring in main net
8. Testing: This section discusses how the protocol is tested. It subdivides into two parts: testing the logic and test behavior in Byzantine infrastructure.
9. 

# 5.1.1 Motivation

# 5.1.2 Dependencies
The FPC module depends on the following other modules:
> [name=Sebastian MuFinalizationThresholder, time=Fri, Jun 19, 2020 10:42 AM] wait until respecive specs are available then synronize

 - 4.3 Mana (to obtain list of mana)
 - 5.3 dRNG (to obtain random number)
  - 5.4 Resynchronization  
  - 3.2 Finality
  - 1.2 Communication Specifications  Payloads and Ontologies 
  - 4.2 UTXO and Realities calculations
  - 2.1 Autopeering (to obtain a list of nodes)  Rate control (gossiping of high mana nodes, do FPC messages need to pass rate control?)

# 5.1.3 Remarks
FPC on tangle is essentially a consensus on "time". At various parts local clocks will be used and compared to timestamps of messages. There are general standing assumption on network latency and clock synchronizations. In a nutshell, they are that the differences in clocks are at least one order of magnitude lower than the network latency. 


# 5.1.4 The core FPC

The protocol tries to find consensus on the validity of a transaction `objectID`. Every node has an initial opinion `opinion`(boolean) on this transaction. These opinions are updated in rounds until the protocol terminates using a local stopping rule. 

## 5.1.4.1 Protocol variables

We define the type `Opinion`. 
```
Opinion: {
    DISLIKE: 0,
    LIKE: 1,
    NULL: NULL  #The node does not know about the object,
    NA : NA # a node does not receive an answer of the opinion of another node
}
```



* `FinalizationThreshold` integer - number of consecutive rounds before FPC auto-terminates
* `FinalizationThreshold2` integer - number of consecutive rounds with non-random threshold
* `FirstRoundThreshold`  double - threshold in first round
* `SubsequentRoundsLowerBoundThreshold` double -  lower random threshold bound in subsequent rounds
*  `SubsequentRoundsUpperBoundThreshold` double -  upper random threshold bound in subsequent rounds
* `maxRound` integer - maximal number of rounds before querying stops
* `querySize` integer - quorum size, number of nodes that are queries
* `roundLength` double - length (in sec) of a round, this has to be synchronized !? For instance, by the DRNG, maybe start with 10s, and FPC only uses DRNG every second round
* `timeOut` - somehow a timer that is updated periodically, connected to `roundLength` TBD

The above variables can in theory be chosen locally for each node. However, the security of the protocol depends on that they are chosen in a reasonable way. The best is if these variables are chosen the same for every node. The IF recommends to use the default values.

IF default/recommendation values are:

TO COME

## 5.1.4.2 Local variables

Every node has the following variables
* `opinion` Opinion
* `nodeList` list of all nodes
* `manaList` list of mana of nodes
* `mana` double - mana of node
* `opinion` boolean - transaction true or false
* `cnt` integer - counter that counts the number of consecutives rounds with unchanged opinion
* `queryStatus` boolean - status if actively querying
* `answerStatus` boolean - status if answerying queries, default value here is `TRUE`
* `round` integer - counts number of rounds in FPC
* `rn` double - random number from dRNG
* `rnCycle` double - random number instance (random numbers are produced at a certain period, this variable counts the current cycle) (-> connect to dRNG)
* `queryList`- list of nodes to query
* `opinionQuery` - list of opinion of nodes in `queryList`, nonreplies are encoded with `NA`
* `reachedMaxRound` boolean - indicating whether protocl reached `maxRound` before auto-termination, default calue `FALSE`
> [name=Sebastian Mueller] Present the above in a table?


## 5.1.4.3 Functions that are called
* `getIninitialOpinion` input: `objectID` output: opinion
* `getRN` input: `rnCycle` output: `rn`
* `getNodes` input:   output: `nodeList`
* `getMana` input: `nodeList` output: `manaList`
* `getSample` input: `querySize` `nodeList` `manaList` : output `queryList`
* `getOpinion` input: `objectID` `queryList` output: `opinionQuery`
* `checkQuerySuccessful` input: `queryList` `opinionQuery` output: `querySuccessful`: c*hecks whether `opinionQuery` from `getOpinion` contains enough answers*
*  `opinionUpdate` input: queryStatus output: `opinion` 
> [name=Sebastian Mueller] How do we write functions? Compare to https://hackmd.io/1oJWLLMPRmaA-GkgWJPi0Q.
## 5.1.4.4 Pseudocode 
 
Note: In the pseudocode at various places global variables are again used as input for the functions. 

### `getInitialOpinion`

This function depends on the ontology. 

### `getRN(layer, a, b, time)`
```
gets a uniform random number between (a,b),
to come, to be discussed with DRNG, 
Note: each layer may use a different random number

OUTPUT: randomThreshold, source of randomness
```

### `getNodes` 
This function should be defined somewhere in autopeering module?

### `getMana`

This function may be specified in Mana part


### `getSample(querySize, nodeList, manaList)`
```
queryList = empty
while (queryList does not contain querySize different element){
newSample:=Sample(nodeList, weight=mana, replacement=TRUE)
queryList = concat(queryList, newSample)
}
return queryList
```

### `getOpinion(queryList, timeOut)`

```
send queries to all nodes of queryList
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
return opinionQuery
```

### `checkQuerySuccessful(queryList, opinionQuery)`
```
# `manaMin` double - minimal mana of answers that have to arrive before new random number is issued  -> change to function
manaMin:=0.5 #at least 50% of the queried mana has to reply; this value may be changed
queriedMana := sum(manaList[queryList])
answerMana :=  sum(manaList[queryList[replied==TRUE]])/queriedMana
querySuccessful := ifElse( answerMana>= manaMin, TRUE, False)
return querySuccessful
```

### `sendOpinion(timeOut)`

```
answer queries that arrive before timeOut
```


### `opinionUpdate(layer, opinion, querySize, nodeList, manaList, FirstRoundThreshold, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)`
```
Sample :=getSample(querySize, nodeList, manaList)
opinionQuery := getOpinion(queryList, timeOut)
if (!checkQuerySuccessful(queryList, opinionQuery)){ #check if sufficiently many nodes replied in time
    newOpinion := opinion # if not keep old opinion 
}
else{ # otherwise update according to FPC rule
    etaStar := mean(opinionQuery, NA.remove=TRUE)
    totalMana := sum(listMana, NA.remove=TRUE) # remove nodes that did not answer
    eta := opinion*mana + etaStar*(totalMana-mana)/totalMana
    if (round == 1){ #first FPC round uses different threshold
        if (eta < FirstRoundThreshold){
            newOpinion <-0
        }
        else newOpinion <-1
    }
    else #the subsequent rounds (before the FinalizationThreshold2 confirming) use random threshold
        rn := getRN(layer, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, time)  # here we have to synchronize/wait for random number
        if (eta < rn){
            newOpinion <-0
        }
        else newOpinion <-1       
}

return newOpinion 
```


### `mainFPC(objectId, queryStatus)`
```
if (queryStatus turns TRUE ){ 
    opinion := getInitialOpinion(objectID)
    listMana := getMana()
    listNode := getNodes()
    cnt := 1
}
wait for new FPC round # next random number from dRNG
#start the first FPC round
round := 1 
opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, FirstRoundThreshold, ubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)
if (opinion==opinionNew) cnt++
else cnt:=0
opinion := opinionNew
round++

#continue FPC, subsequent rounds 
while queryStatus {
    if (cnt <= FinalizationThreshold-FinalizationThreshold2) # we use random threshold{
        opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, FirstRoundThreshold, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)
        if (opinion==opinionNew) cnt++
        else cnt:=0
        opinion := opinionNew
    }
    else {  # we use deterministic threshold for FinalizationThreshold2 "confirming" rounds
    opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, 0.5, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, 1, time)
        if (opinion==opinionNew) cnt++
        else cnt:=0
        opinion := opinionNew      
    }
    round++
    if (cnt==FinalizationThreshold) queryStatus:=FALSE
    if (round>=MaxRound) {
        queryStatus:=FALSE
        reachedMaxRound:=TRUE
    }
}
return(opinion)
```

## 5.1.4.5 Message/transaction layout


### Querying message

### Answering message
This is done in the next section.

# 5.1.5 FPC on tangle

In the tangle reality FPC may have to be applied to various messages simultaneously. Moreover, the tangle (the local view of every node) has to be monotone and consistent. We have to address the three following points:
* **Parallelity:** Many ongoing votings at the same time 
* **Consistency:** Layer should not contain contradicting messages
* **Monotonicity:** Liked  messages should not refer to disliked messages

## 5.1.5.1 Parallelity
At every round FPC decides on possibly several opinions. However, the every node will only query other nodes once (!). This is done for scalability. 

The local variable `opinions` records the vector of all opinions under vote. 

### `getInitialOpinions`

This function depends on the ontology and uses `getInitialOpinions` in a straightforward way.


### `getOpinions(queryList, timeOut)`
```
send queries to all nodes of queryList
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
return opinionsQuery
```
FPC is now applied for each opinion separately. This may not be optimal, but this is addressed in Section 3. It may that the outcome is not consistent or monotone. 


### single vs. multiple dRNG in each round

Discussion: using a different threshold for every opinion (e.g. hash(objectID) X hash(rn)) may lead to the following attack vector. If the number of votings is large then with high probability some of the will always have a random threshold close to 0.5, in other words for a random subset of tx there is no random threshold and hence the protocol is unsafe. 

Advantage of using the same random threshold is also that the two following functions have less to do, i.e., monotonicity and consistency is increased.

It may be good to use different random thresholds for the voting on different layers! (-> `getRN()`)

## 5.1.5.2 Consistency and Monotonicity

### `applyMonotonicityRule()`
```
functions that make temporary ledger state monoton, past cone of liked tx are like, future cones of disliked tx dislike, generalize these rules to level of knowledge -> Billy
```

### `applyConsistencyRule()`
```
functions that make temporary ledger state consistent
if two contradiction transaction are liked, choose the one with the higher mana (?)/ the previous favorite/ hash?
```
## 5.1.5.3 Data layer
FPC is used in the data layer to decide on the validity of the timestamp of a message. We can use here a symmetric range of the random threshold, `a=beta, b=1-beta`



## 5.1.5.4 Value layer
FPC decides in particular between two conflicting transaction, thresholds below 0.5 may lead to liking both transaction after voting. TO DISCUSS: asymmetric random threshold `a=0.5, b=1-beta`. Since there are no simulations yet, it lay be good to run some to check performances. 


# 5.1.6 Message compression of FPC


## 5.1.6.1 Compression in query messages
**Query:** reduce message identifier, e.g., Prefix trie or Cuckoo filter
**Answer:** Bitmask, respond in same order with 1bit per message

# 5.1.7 Gossiping
High mana nodes will be queried too often. They have the possibility to gossip their opinion. However, it is yet not clear who will  be allowed to gossip. 

### Everybody can gossip
This solution follows the idea that IOTA is all but freedom. Every node can decide on his own whether to gossip or not. Nevertheless, IF has to propose a reference implementation.

Advantages:
* if not in place, high mana nodes may be spammed by querries. But is this a reasonable concern for Coordicide 1.0?

Disadvantages: 
* local optimum may not be global optimum
* if all nodes gossip, network may reach congestion. But is this a reasonable concern for Coordicide 1.0?

### Threshold for gossiping

There is a global threshold, like the 100 top mana holders can gossip, the others are querying. However, mana perception is local and hence the threshold can't be sharp. 


### Proposal
TO DISCUSS
* every node is free to gossip
* nodes who gossip, close the port corresponding to queries, this allows other nodes to see whether this node gossips, 
* in IF reference implementation: if own mana perception is above a certain threshold, that would lead to overquery, then gossip

### Changes in the FPC protocol

Warning: the code may depend on the above decision who is going to gossip their opinion. 
### `getOpinions(queryList, timeOut)`
```
send queries to all nodes of queryList that do not gossip
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
read opinions from tangle of all to all nodes of queryList that do gossip

return opinionsQuery
```
Edge cases: what happens if gossiping node is queried? (Angelo: not reply at all, you even don t listen (close ports), Seb: be kind if possible).

If node has to gossip but is not?

# 5.1.7  Protocol monitoring




# 5.1.8 Testing

## 5.1.8.1 Edge cases

## 5.1.8.2 Spamming

## 5.1.8.3 Adversarial strategies

<!--stackedit_data:
eyJkaXNjdXNzaW9ucyI6eyIwU1Y4YmhLcDFjTnJDUzdFIjp7In
RleHQiOiJNYW5hICh0byBvYnRhaW4gbGlzdCBvZiBtYW5hKSIs
InN0YXJ0IjoxODI5LCJlbmQiOjE4NTh9LCJXU1BQcGxQYkg4dH
BVNW83Ijp7InRleHQiOiIjIDUuMS41IEZQQyBvbiB0YW5nbGUi
LCJzdGFydCI6MTA0MzQsImVuZCI6MTA0NTV9LCI2bDdPRExlT2
ZGRWhva241Ijp7InRleHQiOiJTaW5jZSB0aGVyZSBhcmUgbm8g
c2ltdWxhdGlvbnMgeWV0LCBpdCBsYXkgYmUgZ29vZCB0byBydW
4gc29tZSB0byBjaGVjayBwZXJmb3Jt4oCmIiwic3RhcnQiOjEz
MjI5LCJlbmQiOjEzMzE0fSwiMDhtRjdPODZGNUdRR2RaayI6ey
J0ZXh0Ijoibm9kZSBnb3NzaXBzLCIsInN0YXJ0IjoxNDU3Miwi
ZW5kIjoxNDU4NX0sInhhZ0xic3JmRXo4UUpXdkMiOnsidGV4dC
I6Ikl0IG1heSBzZXJ2ZSBvbiB2YXJpb3VzIG9udG9sb2dpZXMg
YXMgY29uc2Vuc3VzIHByb3RvY29sLiIsInN0YXJ0IjozNTcsIm
VuZCI6MzU4fSwiU0dqNUhSVXZDam5FcFFvZiI6eyJ0ZXh0Ijoi
dHJhbnNhY3Rpb24iLCJzdGFydCI6NDA4LCJlbmQiOjQxOX0sIk
U3T0lSelVobjJpbG91OEEiOnsidGV4dCI6Im1lc3NhZ2UgY29t
cHJlc3Npb24gb2YgRlBDOiByZWR1Y2luZyBtZXNzYWdlIGNvbX
BsZXhpdHkgdGhyb3VnaCBtZXNzYWdlIGNvbXByZXPigKYiLCJz
dGFydCI6NTEyLCJlbmQiOjcyMH0sIldZWjFhV3hxSlVvQTZpY1
UiOnsidGV4dCI6IjQuIHByb3RvY29sIGludGVyZmFjZTogZGF0
YSBsYXllciBhbmQgdmFsdWUgbGF5ZXIuIFRoaXMgcGFydCBzcG
VjaWZpZXMgd2hlbiBGUEPigKYiLCJzdGFydCI6NzIxLCJlbmQi
Ojk5MH0sIkNBeUV1REZOSWJWa1hDWDMiOnsidGV4dCI6IlJlc3
luY2hyb25pemF0aW9uIGludGVyZmFjZTogaWYgcHJvdG9jb2wg
ZG9lcyBub3QgYXV0by10ZXJtaW5hdGUgLT4gcmVzeW5jaHJvbm
nigKYiLCJzdGFydCI6OTk0LCJlbmQiOjEwNzl9LCJmcnZqVVN5
SmxLUGhLREQ4Ijp7InRleHQiOiJCZXJzZXJrIGRldGVjdGlvbj
ogbWVjaGFuaXNtIHRoYXQgYWxsb3dzIHRoZSBkZXRlY3Rpb24g
b2YgQmVyc2VyayBiZWhhdmlvci4gVGhp4oCmIiwic3RhcnQiOj
EwODMsImVuZCI6MTU4NX0sIkVzeVNnSEh2Y2ZvaVpkVzUiOnsi
dGV4dCI6IiMgNS4xLjEgTW90aXZhdGlvbiIsInN0YXJ0IjoxNT
kxLCJlbmQiOjE2MDl9LCIwaEZEUGEzQURWMkNRUEo3Ijp7InRl
eHQiOiIjIDUuMS4yIERlcGVuZGVuY2llcyIsInN0YXJ0IjoxNj
ExLCJlbmQiOjE2MzF9LCJJSnppOHgwSDBEbzBxY2hIIjp7InRl
eHQiOiJGUEMgb24gdGFuZ2xlIGlzIGVzc2VudGlhbGx5IGEgY2
9uc2Vuc3VzIG9uIFwidGltZVwiLiBBdCB2YXJpb3VzIHBhcnRz
IGxvY2FsIGNsb2PigKYiLCJzdGFydCI6MjE5OSwiZW5kIjoyNT
QxfSwiNzBhbmVjMW5rUXVRcmpISiI6eyJ0ZXh0IjoiOS4iLCJz
dGFydCI6MTU4NiwiZW5kIjoxNTg4fSwiaWlWcmpnclJocUdTRU
pUdSI6eyJ0ZXh0IjoidGhyZXNob2xkIiwic3RhcnQiOjMyOTEs
ImVuZCI6MzMwMH0sIjh2dWFBb2hKMDVYem1ydEYiOnsidGV4dC
I6InRoaXMgaGFzIHRvIGJlIHN5bmNocm9uaXplZCAhPyBGb3Ig
aW5zdGFuY2UsIGJ5IHRoZSBEUk5HLCBtYXliZSBzdGFydCB3aX
RoIDEwcyzigKYiLCJzdGFydCI6MzcxMCwiZW5kIjozODMxfSwi
alJJbWFJbzRmYTVNbzZJWSI6eyJ0ZXh0Ijoic29tZWhvdyBhIH
RpbWVyIHRoYXQgaXMgdXBkYXRlZCBwZXJpb2RpY2FsbHksIGNv
bm5lY3RlZCB0byBgcm91bmRMZW5ndGhgIFRCRCIsInN0YXJ0Ij
ozODQ2LCJlbmQiOjM5MjJ9LCJIdFBUSVlvTW9xNFdvTDBvIjp7
InRleHQiOiJUaGUgYWJvdmUgdmFyaWFibGVzIGNhbiBpbiB0aG
VvcnkgYmUgY2hvc2VuIGxvY2FsbHkgZm9yIGVhY2ggbm9kZS4g
SG93ZXZlciwgdGhl4oCmIiwic3RhcnQiOjM5MjQsImVuZCI6ND
E0N30sImJXc0xzOXFIdkVOM2h1akUiOnsidGV4dCI6InZhcmlh
YmxlcyIsInN0YXJ0Ijo0MzAwLCJlbmQiOjQzMDl9LCJUSDU0SX
ZSTkpyZ0JDMGZFIjp7InRleHQiOiIqIGBtYW5hTGlzdGAgbGlz
dCBvZiBtYW5hIG9mIG5vZGVzXG4qIGBtYW5hYCBkb3VibGUgLS
BtYW5hIG9mIG5vZGUiLCJzdGFydCI6NDM2MSwiZW5kIjo0NDI2
fSwiSnJ3SWp1S2s5ZlBTWGhCcCI6eyJ0ZXh0IjoiYm9vbGVhbi
AtIHRyYW5zYWN0aW9uIHRydWUgb3IgZmFsc2UiLCJzdGFydCI6
NDQzOSwiZW5kIjo0NDc0fSwiR1phS0VvREMwcjk2ekJFMSI6ey
J0ZXh0IjoiVGhpcyBmdW5jdGlvbiBkZXBlbmRzIG9uIHRoZSBv
bnRvbG9neS4iLCJzdGFydCI6NjExNiwiZW5kIjo2MTU0fSwiOH
dydVdKOWJiaWVVTlZ6MyI6eyJ0ZXh0IjoiTm90ZTogZWFjaCBs
YXllciIsInN0YXJ0Ijo2MjczLCJlbmQiOjYyODl9LCJhQ0pLNG
9wWmthWmY0aUxXIjp7InRleHQiOiJgYT0wLjUsIGI9MS1iZXRh
YCIsInN0YXJ0IjoxMzIxMCwiZW5kIjoxMzIyN319LCJjb21tZW
50cyI6eyI0aG5Sak9PVzRIaUtNTnZqIjp7ImRpc2N1c3Npb25J
ZCI6IjBTVjhiaEtwMWNOckNTN0UiLCJzdWIiOiJnaDo1MTExMj
YxOCIsInRleHQiOiJzbmFwc2hvdHRlZCBtYW5hIHZzIGFsdGVy
bmF0aXZlcyIsImNyZWF0ZWQiOjE1OTY1MjAzMDQ3MjR9LCI5OG
84NGttSDM0REFjY3VpIjp7ImRpc2N1c3Npb25JZCI6IldTUFBw
bFBiSDh0cFU1bzciLCJzdWIiOiJnaDo1MTExMjYxOCIsInRleH
QiOiIhIFRoaXMgc2VjdGlvbiBtYXkgY2hhbmdlIChpZiBmYWN0
IGJlIGRlbGV0ZWQpICBpbiBwYXJhbGxlbCByZWFsaXR5IHVuaX
ZlcnNlLiIsImNyZWF0ZWQiOjE1OTY1MjA4Njk1NjF9LCJocURt
MUZTbkZlTmpuWU5sIjp7ImRpc2N1c3Npb25JZCI6IjZsN09ETG
VPZkZFaG9rbjUiLCJzdWIiOiJnaDo1MTExMjYxOCIsInRleHQi
OiJEb25lIGluIHRoZSBtZWFudGltZSwgbm8gYmFkIHN1cnByaX
NlcyIsImNyZWF0ZWQiOjE1OTY1MjExMTE4OTZ9LCI2QUZubW1O
ejJ1bkdSUUZKIjp7ImRpc2N1c3Npb25JZCI6IjA4bUY3Tzg2Rj
VHUUdkWmsiLCJzdWIiOiJnaDo1MTExMjYxOCIsInRleHQiOiJ3
ZWxsIGF0IGxlYXN0IGFuIGluZGljYXRpb24iLCJjcmVhdGVkIj
oxNTk2NTIxMjQxNTMxfSwiZGM2ZzhkQld3WWRMQ0VZWCI6eyJk
aXNjdXNzaW9uSWQiOiIwU1Y4YmhLcDFjTnJDUzdFIiwic3ViIj
oiZ2g6NTExMTI2MTgiLCJ0ZXh0IjoianVzdCBGUENNYW5hIiwi
Y3JlYXRlZCI6MTU5NjUyOTk3NzExMX0sImpRS1NTZmxaOTJ4R3
ZNRHoiOnsiZGlzY3Vzc2lvbklkIjoieGFnTGJzcmZFejhRSld2
QyIsInN1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6IlJlbW92ZS
BhcyBvbnRvbG9naWVzIGluIG5ldmVyIGNsZWFyIiwiY3JlYXRl
ZCI6MTU5Nzc3NjkyNDU0Mn0sInltMDcyeFJtS1V5ZVFacEQiOn
siZGlzY3Vzc2lvbklkIjoiU0dqNUhSVXZDam5FcFFvZiIsInN1
YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6IlRyYW5zYWN0aW9uIH
ZzIFZhbHVlIE1lc3NhZ2U/IiwiY3JlYXRlZCI6MTU5Nzc3NzM4
ODE0Mn0sIkNUUGxLRlBkVlJjT0dFZ2oiOnsiZGlzY3Vzc2lvbk
lkIjoiRTdPSVJ6VWhuMmlsb3U4QSIsInN1YiI6ImdoOjY4MjUw
MzUwIiwidGV4dCI6IkltY29tcGxldGUiLCJjcmVhdGVkIjoxNT
k3Nzc4MDA5MTIwfSwiNXl1SXk2WFZYTmUwTGEwNSI6eyJkaXNj
dXNzaW9uSWQiOiJXWVoxYVd4cUpVb0E2aWNVIiwic3ViIjoiZ2
g6NjgyNTAzNTAiLCJ0ZXh0IjoiSXMgdGhpcyA1LjI/IiwiY3Jl
YXRlZCI6MTU5Nzc3ODE1NDA5MH0sIkJyYndGVHh1QnNsQTMySX
UiOnsiZGlzY3Vzc2lvbklkIjoiQ0F5RXVERk5JYlZrWENYMyIs
InN1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6IlRoaXMgaXMgbm
90IGNvdmVyZWQgaGVyZSwgc2hvdWxkIHdlIHJlZmVyIHRvIDUu
ND8iLCJjcmVhdGVkIjoxNTk3Nzc4MTk5Mjc4fSwibmpSRE02Um
1NcllKdnhBMiI6eyJkaXNjdXNzaW9uSWQiOiJmcnZqVVN5SmxL
UGhLREQ4Iiwic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0ZXh0IjoiQW
xsIG9mIHRoaXMgaXMgaW5jb21wbGV0ZSIsImNyZWF0ZWQiOjE1
OTc3NzgyMTg4MTd9LCI0Z2RnNWlpTHFPdGRhQTR4Ijp7ImRpc2
N1c3Npb25JZCI6IkVzeVNnSEh2Y2ZvaVpkVzUiLCJzdWIiOiJn
aDo2ODI1MDM1MCIsInRleHQiOiJXaWxsIHNvbWV0aGluZyBiZS
B3cml0dGVuIGhlcmU/IiwiY3JlYXRlZCI6MTU5Nzc3ODIzMzg1
OX0sIllhU0JyeThOVjR4blVFclMiOnsiZGlzY3Vzc2lvbklkIj
oiMGhGRFBhM0FEVjJDUVBKNyIsInN1YiI6ImdoOjY4MjUwMzUw
IiwidGV4dCI6IlRoaXMgc2VjdGlvbiBzaG91bCBlaXRoZXIgYm
UgYXQgYmUgYmVnaW5uaW5nIG9yIHNraXBwZWQgaW1vLiBUaGUg
ZGVwZW5kZW5jaWVzIHNob3VsZCB1c2UgdGhlIHByb3BlciByZW
ZlcmVuY2Ugd2hlbnQgaGV5IGFwcGVhci4iLCJjcmVhdGVkIjox
NTk3Nzc4NDQ0OTgwfSwiQU9XUGhCNHhRZTg2MVBLQyI6eyJkaX
NjdXNzaW9uSWQiOiJJSnppOHgwSDBEbzBxY2hIIiwic3ViIjoi
Z2g6NjgyNTAzNTAiLCJ0ZXh0IjoiU2hvdWxkIHdlIHNheSBzb2
10aGluZyBhYm91dCBzeW5jaHJvbm91cyB2cyBBc3luY2hyb25v
dXM/IiwiY3JlYXRlZCI6MTU5Nzc3ODUzMzIyMX0sIk1nTUNvWW
10aHp6WXl2S1IiOnsiZGlzY3Vzc2lvbklkIjoiNzBhbmVjMW5r
UXVRcmpISiIsInN1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6Ik
dvc3NpcGluZz8iLCJjcmVhdGVkIjoxNTk3Nzc4NTY0OTczfSwi
OWpOVTJaNTI2UzczNlF4NyI6eyJkaXNjdXNzaW9uSWQiOiJpaV
ZyamdyUmhxR1NFSlR1Iiwic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0
ZXh0IjoiVGhyZXNob2xkIG9mIHRoZSBwcm9wb3J0aW9uIG9mIG
9waW5pb25zIiwiY3JlYXRlZCI6MTU5Nzc3OTQzMDk2Mn0sInZF
SDh4MWYzY04xaHhta3AiOnsiZGlzY3Vzc2lvbklkIjoiOHZ1YU
FvaEowNVh6bXJ0RiIsInN1YiI6ImdoOjY4MjUwMzUwIiwidGV4
dCI6IkRlbGV0ZSB0aGlzPyIsImNyZWF0ZWQiOjE1OTc3ODI5Nz
c3MzR9LCJnelM4NmNwandmUFJvODRhIjp7ImRpc2N1c3Npb25J
ZCI6ImpSSW1hSW80ZmE1TW82SVkiLCJzdWIiOiJnaDo2ODI1MD
M1MCIsInRleHQiOiJOb3QgQ2xlYXIiLCJjcmVhdGVkIjoxNTk3
NzgzMTE3NjY5fSwiWVh5bm85SHY5Z05SYTFDZiI6eyJkaXNjdX
NzaW9uSWQiOiJIdFBUSVlvTW9xNFdvTDBvIiwic3ViIjoiZ2g6
NjgyNTAzNTAiLCJ0ZXh0IjoiU28gc2hvdWxkIHdlIGFsbG93IH
RoaXM/IElmIG5vdCBzaG91bGQgdGhpcyBiZSBzYWlkPyIsImNy
ZWF0ZWQiOjE1OTc3ODMxNzI2MjR9LCJVcWxBR1pFQ2p6aDUxTU
VEIjp7ImRpc2N1c3Npb25JZCI6ImJXc0xzOXFIdkVOM2h1akUi
LCJzdWIiOiJnaDo2ODI1MDM1MCIsInRleHQiOiJJcyB0aGF0IH
RoZSBiZXN0IHdvcmQgdG8gdXNlPyBBcyBhbiBleGFtcGxlIFwi
T3BpbmlvblwiIGlzIGEgcmVsYXRpb24gYmV0d2VlbiBub2RlIG
FuZCBUcmFuc2FjdGlvbi4gVGhpcyBtZWFucyB0aGUgbm9kZSBk
b250IGhhdmUgb25lIE9waW5pb24sIGJ1dCBvbmUgcGVyIHRyYW
5zYWN0aW9uLiIsImNyZWF0ZWQiOjE1OTc3ODM5NTE4Nzh9LCJH
bnA4cTAxdW1maVV1N3pOIjp7ImRpc2N1c3Npb25JZCI6IlRINT
RJdlJOSnJnQkMwZkUiLCJzdWIiOiJnaDo2ODI1MDM1MCIsInRl
eHQiOiJTaG91bGQgdGhpcyBiZSB1cGRhdGVkIHdpdGggdGhlIG
tpbmQgb2YgbWFuYT8iLCJjcmVhdGVkIjoxNTk3NzgzOTgzNzcw
fSwia3p3Qnl6NEVFa3VCb2kzRyI6eyJkaXNjdXNzaW9uSWQiOi
JKcndJanVLazlmUFNYaEJwIiwic3ViIjoiZ2g6NjgyNTAzNTAi
LCJ0ZXh0IjoiSXRzIHR3aWNlIGluIHRoZSBsaXN0IiwiY3JlYX
RlZCI6MTU5Nzc4Mzk5Nzg2M30sImJvYmVrQXI0Q3dFSjlNSmki
OnsiZGlzY3Vzc2lvbklkIjoiR1phS0VvREMwcjk2ekJFMSIsIn
N1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6IkNvbmZ1c2luZyBh
cyBPbnRvbG9neSBpcyBub3QgZGVmaW5lZCIsImNyZWF0ZWQiOj
E1OTc3ODQyMDQ4ODB9LCJjdXlnOUhlZzBHY1REU0FKIjp7ImRp
c2N1c3Npb25JZCI6Ijh3cnVXSjliYmllVU5WejMiLCJzdWIiOi
JnaDo2ODI1MDM1MCIsInRleHQiOiJMYXllciBpcyBub3Qgd2Vs
bCBkZWZpbmVkIiwiY3JlYXRlZCI6MTU5Nzc5NTY3MDc3OX0sIj
VBZUIyWjkwcER1eGRQTW0iOnsiZGlzY3Vzc2lvbklkIjoiYUNK
SzRvcFprYVpmNGlMVyIsInN1YiI6ImdoOjY4MjUwMzUwIiwidG
V4dCI6InN5bWJvbHMgbm90IGluIGFjY29yZGFuY2UgdG8gdGhl
IGRlZmluZWQgcGFyYW1ldGVycyIsImNyZWF0ZWQiOjE1OTc3OT
c0MzA0Njl9fSwiaGlzdG9yeSI6WzExNTAwNTg2MjUsMTYwNTM2
MDI3NywtMzAyNjI4MzQzLDE2NDczOTE2NjgsLTQ1NjYyMzEyLD
EzMDg0MjM1NzUsMTAwMzk5OTU3NiwtMTU0MTI0NjEzNiw5NTkw
MTIyMTMsMTMzNzY0OTcwNCw1NDYxMTEwMTgsLTQzNzQ4NTMzNC
w0MDYxNDQ5NTUsNjIzMjQxNTUyLDEzNTYxNDg2OCw4NTAwMjM4
MzcsLTEzMDc2MjY2M119
-->