+ Feature name:  FPC specifications
+ Start date: 2020-03-16

# 5.1 FPC specification


> [name=Sebastian Mu] some  comments by Bill Acha are here:https://hackmd.io/1oJWLLMPRmaA-GkgWJPi0Q and might still to be included



This specification is part of [Coordicide](https://coordicide.iota.org/).

The feature/module presented in this specification, FPC, allows nodes to find consensus on whether a transaction is valid or not. 

The content of this specification is based on [FPC - simulation](https://arxiv.org/abs/1911.08787), [manaFPC-simulation](https://www.overleaf.com/project/5e3a96c9ebfeb20001821bb5) and...

The specification will be subdivided into the following subsections:

1. The core FPC protocol: our basic consensus protocol on binary opinions. It may serve on various ontologies as consensus protocol. 
2. FPC on tangle: opinions on transaction of the tangle become dependent. This parts specifies monotonicity and consistency rules.
3. message compression of FPC: reducing message complexity through message compression and gossiping of opinions for high mana nodes. This part has to be updated and revised due to the parallel reality approach.
4. protocol interface: data layer and value layer. This part specifies when FPC is started; it defines how the variables `queryStatus` and `answerStatus` are set. Also function`getInitialOpinion`has to be specified.  -> This part should essentially be covered by Billy.
5. Resynchronization interface: if protocol does not auto-terminate -> resynchronization
6. Berserk detection: mechanism that allows the detection of Berserk behavior. This part may be integrated later on. This depends on how we do proceed with reporting malicious behavior etc.
7. Protocol monitoring: information every node saves for testing of the protocol (in test net, finding optimal parameter sets) and for monitoring in main net
8. Testing: This section discusses how the protocol is tested. It subdivides into two parts: testing the logic and test behavior in Byzantine infrastructure.
9. 

# 5.1.1 Motivation

# 5.1.2 Dependencies
The FPC module depends on the following other modules:
> [name=Sebastian MuFinalizationThresholder, time=Fri, Jun 19, 2020 10:42 AM] wait until respecive specs are available then synronize

 - 4.3 Mana (to obtain list of mana)
 - 5.3 dRNG (to obtain random number)
  - 5.4 Resynchronization  
  - 3.2 Finality
  - 1.2 Communication Specifications  Payloads and Ontologies 
  - 4.2 UTXO and Realities calculations
  - 2.1 Autopeering (to obtain a list of nodes)  Rate control (gossiping of high mana nodes, do FPC messages need to pass rate control?)

# 5.1.3 Remarks
FPC on tangle is essentially a consensus on "time". At various parts local clocks will be used and compared to timestamps of messages. There are general standing assumption on network latency and clock synchronizations. In a nutshell, they are that the differences in clocks are at least one order of magnitude lower than the network latency. 


# 5.1.4 The core FPC

The protocol tries to find consensus on the validity of a transaction `objectID`. Every node has an initial opinion `opinion`(boolean) on this transaction. These opinions are updated in rounds until the protocol terminates using a local stopping rule. 

## 5.1.4.1 Protocol variables

We define the type `Opinion`. 
```
Opinion: {
    DISLIKE: 0,
    LIKE: 1,
    NULL: NULL  #The node does not know about the object,
    NA : NA # a node does not receive an answer of the opinion of another node
}
```



* `FinalizationThreshold` integer - number of consecutive rounds before FPC auto-terminates
* `FinalizationThreshold2` integer - number of consecutive rounds with non-random threshold
* `FirstRoundThreshold`  double - threshold in first round
* `SubsequentRoundsLowerBoundThreshold` double -  lower random threshold bound in subsequent rounds
*  `SubsequentRoundsUpperBoundThreshold` double -  upper random threshold bound in subsequent rounds
* `maxRound` integer - maximal number of rounds before querying stops
* `querySize` integer - quorum size, number of nodes that are queries
* `roundLength` double - length (in sec) of a round, this has to be synchronized !? For instance, by the DRNG, maybe start with 10s, and FPC only uses DRNG every second round
* `timeOut` - somehow a timer that is updated periodically, connected to `roundLength` TBD

The above variables can in theory be chosen locally for each node. However, the security of the protocol depends on that they are chosen in a reasonable way. The best is if these variables are chosen the same for every node. The IF recommends to use the default values.

IF default/recommendation values are:

TO COME

## 5.1.4.2 Local variables

Every node has the following variables
* `opinion` Opinion
* `nodeList` list of all nodes
* `manaList` list of mana of nodes
* `mana` double - mana of node
* `opinion` boolean - transaction true or false
* `cnt` integer - counter that counts the number of consecutives rounds with unchanged opinion
* `queryStatus` boolean - status if actively querying
* `answerStatus` boolean - status if answerying queries, default value here is `TRUE`
* `round` integer - counts number of rounds in FPC
* `rn` double - random number from dRNG
* `rnCycle` double - random number instance (random numbers are produced at a certain period, this variable counts the current cycle) (-> connect to dRNG)
* `queryList`- list of nodes to query
* `opinionQuery` - list of opinion of nodes in `queryList`, nonreplies are encoded with `NA`
* `reachedMaxRound` boolean - indicating whether protocl reached `maxRound` before auto-termination, default calue `FALSE`
> [name=Sebastian Mueller] Present the above in a table?


## 5.1.4.3 Functions that are called
* `getIninitialOpinion` input: `objectID` output: opinion
* `getRN` input: `rnCycle` output: `rn`
* `getNodes` input:   output: `nodeList`
* `getMana` input: `nodeList` output: `manaList`
* `getSample` input: `querySize` `nodeList` `manaList` : output `queryList`
* `getOpinion` input: `objectID` `queryList` output: `opinionQuery`
* `checkQuerySuccessful` input: `queryList` `opinionQuery` output: `querySuccessful`: c*hecks whether `opinionQuery` from `getOpinion` contains enough answers*
*  `opinionUpdate` input: queryStatus output: `opinion` 
> [name=Sebastian Mueller] How do we write functions? Compare to https://hackmd.io/1oJWLLMPRmaA-GkgWJPi0Q.
## 5.1.4.4 Pseudocode 
 
Note: In the pseudocode at various places global variables are again used as input for the functions. 

### `getInitialOpinion`

This function depends on the ontology. 

### `getRN(layer, a, b, time)`
```
gets a uniform random number between (a,b),
to come, to be discussed with DRNG, 
Note: each layer may use a different random number

OUTPUT: randomThreshold, source of randomness
```

### `getNodes` 
This function should be defined somewhere in autopeering module?

### `getMana`

This function may be specified in Mana part


### `getSample(querySize, nodeList, manaList)`
```
queryList = empty
while (queryList does not contain querySize different element){
newSample:=Sample(nodeList, weight=mana, replacement=TRUE)
queryList = concat(queryList, newSample)
}
return queryList
```

### `getOpinion(queryList, timeOut)`

```
send queries to all nodes of queryList
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
return opinionQuery
```

### `checkQuerySuccessful(queryList, opinionQuery)`
```
# `manaMin` double - minimal mana of answers that have to arrive before new random number is issued  -> change to function
manaMin:=0.5 #at least 50% of the queried mana has to reply; this value may be changed
queriedMana := sum(manaList[queryList])
answerMana :=  sum(manaList[queryList[replied==TRUE]])/queriedMana
querySuccessful := ifElse( answerMana>= manaMin, TRUE, False)
return querySuccessful
```

### `sendOpinion(timeOut)`

```
answer queries that arrive before timeOut
```


### `opinionUpdate(layer, opinion, querySize, nodeList, manaList, FirstRoundThreshold, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)`
```
Sample :=getSample(querySize, nodeList, manaList)
opinionQuery := getOpinion(queryList, timeOut)
if (!checkQuerySuccessful(queryList, opinionQuery)){ #check if sufficiently many nodes replied in time
    newOpinion := opinion # if not keep old opinion 
}
else{ # otherwise update according to FPC rule
    etaStar := mean(opinionQuery, NA.remove=TRUE)
    totalMana := sum(listMana, NA.remove=TRUE) # remove nodes that did not answer
    eta := opinion*mana + etaStar*(totalMana-mana)/totalMana
    if (round == 1){ #first FPC round uses different threshold
        if (eta < FirstRoundThreshold){
            newOpinion <-0
        }
        else newOpinion <-1
    }
    else #the subsequent rounds (before the FinalizationThreshold2 confirming) use random threshold
        rn := getRN(layer, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, time)  # here we have to synchronize/wait for random number
        if (eta < rn){
            newOpinion <-0
        }
        else newOpinion <-1       
}

return newOpinion 
```


### `mainFPC(objectId, queryStatus)`
```
if (queryStatus turns TRUE ){ 
    opinion := getInitialOpinion(objectID)
    listMana := getMana()
    listNode := getNodes()
    cnt := 1
}
wait for new FPC round # next random number from dRNG
#start the first FPC round
round := 1 
opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, FirstRoundThreshold, ubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)
if (opinion==opinionNew) cnt++
else cnt:=0
opinion := opinionNew
round++

#continue FPC, subsequent rounds 
while queryStatus {
    if (cnt <= FinalizationThreshold-FinalizationThreshold2) # we use random threshold{
        opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, FirstRoundThreshold, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)
        if (opinion==opinionNew) cnt++
        else cnt:=0
        opinion := opinionNew
    }
    else {  # we use deterministic threshold for FinalizationThreshold2 "confirming" rounds
    opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, 0.5, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, 1, time)
        if (opinion==opinionNew) cnt++
        else cnt:=0
        opinion := opinionNew      
    }
    round++
    if (cnt==FinalizationThreshold) queryStatus:=FALSE
    if (round>=MaxRound) {
        queryStatus:=FALSE
        reachedMaxRound:=TRUE
    }
}
return(opinion)
```

## 5.1.4.5 Message/transaction layout


### Querying message

### Answering message
This is done in the next section.

# 5.1.5 FPC on tangle

In the tangle reality FPC may have to be applied to various messages simultaneously. Moreover, the tangle (the local view of every node) has to be monotone and consistent. We have to address the three following points:
* **Parallelity:** Many ongoing votings at the same time 
* **Consistency:** Layer should not contain contradicting messages
* **Monotonicity:** Liked  messages should not refer to disliked messages

## 5.1.5.1 Parallelity
At every round FPC decides on possibly several opinions. However, the every node will only query other nodes once (!). This is done for scalability. 

The local variable `opinions` records the vector of all opinions under vote. 

### `getInitialOpinions`

This function depends on the ontology and uses `getInitialOpinions` in a straightforward way.


### `getOpinions(queryList, timeOut)`
```
send queries to all nodes of queryList
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
return opinionsQuery
```
FPC is now applied for each opinion separately. This may not be optimal, but this is addressed in Section 3. It may that the outcome is not consistent or monotone. 


### single vs. multiple dRNG in each round

Discussion: using a different threshold for every opinion (e.g. hash(objectID) X hash(rn)) may lead to the following attack vector. If the number of votings is large then with high probability some of the will always have a random threshold close to 0.5, in other words for a random subset of tx there is no random threshold and hence the protocol is unsafe. 

Advantage of using the same random threshold is also that the two following functions have less to do, i.e., monotonicity and consistency is increased.

It may be good to use different random thresholds for the voting on different layers! (-> `getRN()`)

## 5.1.5.2 Consistency and Monotonicity

### `applyMonotonicityRule()`
```
functions that make temporary ledger state monoton, past cone of liked tx are like, future cones of disliked tx dislike, generalize these rules to level of knowledge -> Billy
```

### `applyConsistencyRule()`
```
functions that make temporary ledger state consistent
if two contradiction transaction are liked, choose the one with the higher mana (?)/ the previous favorite/ hash?
```
## 5.1.5.3 Data layer
FPC is used in the data layer to decide on the validity of the timestamp of a message. We can use here a symmetric range of the random threshold, `a=beta, b=1-beta`



## 5.1.5.4 Value layer
FPC decides in particular between two conflicting transaction, thresholds below 0.5 may lead to liking both transaction after voting. TO DISCUSS: asymmetric random threshold `a=0.5, b=1-beta`. Since there are no simulations yet, it lay be good to run some to check performances. 


# 5.1.6 Message compression of FPC


## 5.1.6.1 Compression in query messages
**Query:** reduce message identifier, e.g., Prefix trie or Cuckoo filter
**Answer:** Bitmask, respond in same order with 1bit per message

# 5.1.7 Gossiping
High mana nodes will be queried too often. They have the possibility to gossip their opinion. However, it is yet not clear who will  be allowed to gossip. 

### Everybody can gossip
This solution follows the idea that IOTA is all but freedom. Every node can decide on his own whether to gossip or not. Nevertheless, IF has to propose a reference implementation.

Advantages:
* if not in place, high mana nodes may be spammed by querries. But is this a reasonable concern for Coordicide 1.0?

Disadvantages: 
* local optimum may not be global optimum
* if all nodes gossip, network may reach congestion. But is this a reasonable concern for Coordicide 1.0?

### Threshold for gossiping

There is a global threshold, like the 100 top mana holders can gossip, the others are querying. However, mana perception is local and hence the threshold can't be sharp. 


### Proposal
TO DISCUSS
* every node is free to gossip
* nodes who gossip, close the port corresponding to queries, this allows other nodes to see whether this node gossips, 
* in IF reference implementation: if own mana perception is above a certain threshold, that would lead to overquery, then gossip

### Changes in the FPC protocol

Warning: the code may depend on the above decision who is going to gossip their opinion. 
### `getOpinions(queryList, timeOut)`
```
send queries to all nodes of queryList that do not gossip
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
read opinions from tangle of all to all nodes of queryList that do gossip

return opinionsQuery
```
Edge cases: what happens if gossiping node is queried? (Angelo: not reply at all, you even don t listen (close ports), Seb: be kind if possible).

If node has to gossip but is not?

# 5.1.7  Protocol monitoring




# 5.1.8 Testing

## 5.1.8.1 Edge cases

## 5.1.8.2 Spamming

## 5.1.8.3 Adversarial strategies

<!--stackedit_data:
eyJkaXNjdXNzaW9ucyI6eyIwU1Y4YmhLcDFjTnJDUzdFIjp7In
RleHQiOiJNYW5hICh0byBvYnRhaW4gbGlzdCBvZiBtYW5hKSIs
InN0YXJ0IjoyMjcyLCJlbmQiOjIzMDF9LCJXU1BQcGxQYkg4dH
BVNW83Ijp7InRleHQiOiIjIDUuMS41IEZQQyBvbiB0YW5nbGUi
LCJzdGFydCI6MTA4NzcsImVuZCI6MTA4OTh9LCI2bDdPRExlT2
ZGRWhva241Ijp7InRleHQiOiJTaW5jZSB0aGVyZSBhcmUgbm8g
c2ltdWxhdGlvbnMgeWV0LCBpdCBsYXkgYmUgZ29vZCB0byBydW
4gc29tZSB0byBjaGVjayBwZXJmb3Jt4oCmIiwic3RhcnQiOjEz
NjcyLCJlbmQiOjEzNzU3fSwiMDhtRjdPODZGNUdRR2RaayI6ey
J0ZXh0Ijoibm9kZSBnb3NzaXBzLCIsInN0YXJ0IjoxNTAxNSwi
ZW5kIjoxNTAyOH0sIjhGV2hZUDc3Wks2MGVwVUsiOnsic3Rhcn
QiOjQyOSwiZW5kIjo2MTUsInRleHQiOiJUaGUgY29udGVudCBv
ZiB0aGlzIHNwZWNpZmljYXRpb24gaXMgYmFzZWQgb24gW0ZQQy
AtIHNpbXVsYXRpb25dKGh0dHBzOi8vYXJ4aXYu4oCmIn0sImRm
UE40NjhVSWFEWlc1bWMiOnsic3RhcnQiOjY1OSwiZW5kIjo2OD
UsInRleHQiOiJ0aGUgZm9sbG93aW5nIHN1YnNlY3Rpb25zOiJ9
LCJ4YWdMYnNyZkV6OFFKV3ZDIjp7InN0YXJ0Ijo3NjIsImVuZC
I6ODE5LCJ0ZXh0IjoiSXQgbWF5IHNlcnZlIG9uIHZhcmlvdXMg
b250b2xvZ2llcyBhcyBjb25zZW5zdXMgcHJvdG9jb2wuIn0sIl
NHajVIUlV2Q2puRXBRb2YiOnsic3RhcnQiOjg1MSwiZW5kIjo4
NjIsInRleHQiOiJ0cmFuc2FjdGlvbiJ9LCJFN09JUnpVaG4yaW
xvdThBIjp7InN0YXJ0Ijo5NTUsImVuZCI6MTE2MywidGV4dCI6
Im1lc3NhZ2UgY29tcHJlc3Npb24gb2YgRlBDOiByZWR1Y2luZy
BtZXNzYWdlIGNvbXBsZXhpdHkgdGhyb3VnaCBtZXNzYWdlIGNv
bXByZXPigKYifSwiV1laMWFXeHFKVW9BNmljVSI6eyJzdGFydC
I6MTE2NCwiZW5kIjoxNDMzLCJ0ZXh0IjoiNC4gcHJvdG9jb2wg
aW50ZXJmYWNlOiBkYXRhIGxheWVyIGFuZCB2YWx1ZSBsYXllci
4gVGhpcyBwYXJ0IHNwZWNpZmllcyB3aGVuIEZQQ+KApiJ9LCJD
QXlFdURGTkliVmtYQ1gzIjp7InN0YXJ0IjoxNDM3LCJlbmQiOj
E1MjIsInRleHQiOiJSZXN5bmNocm9uaXphdGlvbiBpbnRlcmZh
Y2U6IGlmIHByb3RvY29sIGRvZXMgbm90IGF1dG8tdGVybWluYX
RlIC0+IHJlc3luY2hyb25p4oCmIn0sImZydmpVU3lKbEtQaEtE
RDgiOnsic3RhcnQiOjE1MjYsImVuZCI6MjAyOCwidGV4dCI6Ik
JlcnNlcmsgZGV0ZWN0aW9uOiBtZWNoYW5pc20gdGhhdCBhbGxv
d3MgdGhlIGRldGVjdGlvbiBvZiBCZXJzZXJrIGJlaGF2aW9yLi
BUaGnigKYifSwiRXN5U2dISHZjZm9pWmRXNSI6eyJzdGFydCI6
MjAzNCwiZW5kIjoyMDUyLCJ0ZXh0IjoiIyA1LjEuMSBNb3Rpdm
F0aW9uIn0sIjBoRkRQYTNBRFYyQ1FQSjciOnsic3RhcnQiOjIw
NTQsImVuZCI6MjA3NCwidGV4dCI6IiMgNS4xLjIgRGVwZW5kZW
5jaWVzIn0sIklKemk4eDBIMERvMHFjaEgiOnsic3RhcnQiOjI2
NDIsImVuZCI6Mjk4NCwidGV4dCI6IkZQQyBvbiB0YW5nbGUgaX
MgZXNzZW50aWFsbHkgYSBjb25zZW5zdXMgb24gXCJ0aW1lXCIu
IEF0IHZhcmlvdXMgcGFydHMgbG9jYWwgY2xvY+KApiJ9LCI3MG
FuZWMxbmtRdVFyakhKIjp7InN0YXJ0IjoyMDI5LCJlbmQiOjIw
MzEsInRleHQiOiI5LiJ9LCJpaVZyamdyUmhxR1NFSlR1Ijp7In
N0YXJ0IjozNzM0LCJlbmQiOjM3NDMsInRleHQiOiJ0aHJlc2hv
bGQifX0sImNvbW1lbnRzIjp7IjRoblJqT09XNEhpS01OdmoiOn
siZGlzY3Vzc2lvbklkIjoiMFNWOGJoS3AxY05yQ1M3RSIsInN1
YiI6ImdoOjUxMTEyNjE4IiwidGV4dCI6InNuYXBzaG90dGVkIG
1hbmEgdnMgYWx0ZXJuYXRpdmVzIiwiY3JlYXRlZCI6MTU5NjUy
MDMwNDcyNH0sIjk4bzg0a21IMzREQWNjdWkiOnsiZGlzY3Vzc2
lvbklkIjoiV1NQUHBsUGJIOHRwVTVvNyIsInN1YiI6ImdoOjUx
MTEyNjE4IiwidGV4dCI6IiEgVGhpcyBzZWN0aW9uIG1heSBjaG
FuZ2UgKGlmIGZhY3QgYmUgZGVsZXRlZCkgIGluIHBhcmFsbGVs
IHJlYWxpdHkgdW5pdmVyc2UuIiwiY3JlYXRlZCI6MTU5NjUyMD
g2OTU2MX0sImhxRG0xRlNuRmVOam5ZTmwiOnsiZGlzY3Vzc2lv
bklkIjoiNmw3T0RMZU9mRkVob2tuNSIsInN1YiI6ImdoOjUxMT
EyNjE4IiwidGV4dCI6IkRvbmUgaW4gdGhlIG1lYW50aW1lLCBu
byBiYWQgc3VycHJpc2VzIiwiY3JlYXRlZCI6MTU5NjUyMTExMT
g5Nn0sIjZBRm5tbU56MnVuR1JRRkoiOnsiZGlzY3Vzc2lvbklk
IjoiMDhtRjdPODZGNUdRR2RaayIsInN1YiI6ImdoOjUxMTEyNj
E4IiwidGV4dCI6IndlbGwgYXQgbGVhc3QgYW4gaW5kaWNhdGlv
biIsImNyZWF0ZWQiOjE1OTY1MjEyNDE1MzF9LCJkYzZnOGRCV3
dZZExDRVlYIjp7ImRpc2N1c3Npb25JZCI6IjBTVjhiaEtwMWNO
ckNTN0UiLCJzdWIiOiJnaDo1MTExMjYxOCIsInRleHQiOiJqdX
N0IEZQQ01hbmEiLCJjcmVhdGVkIjoxNTk2NTI5OTc3MTExfSwi
cFFMcFd5V0dSY2ZmNTYwMSI6eyJkaXNjdXNzaW9uSWQiOiI4Rl
doWVA3N1pLNjBlcFVLIiwic3ViIjoiZ2g6NjgyNTAzNTAiLCJ0
ZXh0IjoiSW5jb21wbGV0ZT8gTmVjZXNzYXJ5PyIsImNyZWF0ZW
QiOjE1OTc3NzY3OTAyNTl9LCJxcnh3WlJpcXNFRDA0TmdaIjp7
ImRpc2N1c3Npb25JZCI6ImRmUE40NjhVSWFEWlc1bWMiLCJzdW
IiOiJnaDo2ODI1MDM1MCIsInRleHQiOiJhZGRlZCBieSBtZSIs
ImNyZWF0ZWQiOjE1OTc3NzY4MDE0MTF9LCJqUUtTU2ZsWjkyeE
d2TUR6Ijp7ImRpc2N1c3Npb25JZCI6InhhZ0xic3JmRXo4UUpX
dkMiLCJzdWIiOiJnaDo2ODI1MDM1MCIsInRleHQiOiJSZW1vdm
UgYXMgb250b2xvZ2llcyBpbiBuZXZlciBjbGVhciIsImNyZWF0
ZWQiOjE1OTc3NzY5MjQ1NDJ9LCJ5bTA3MnhSbUtVeWVRWnBEIj
p7ImRpc2N1c3Npb25JZCI6IlNHajVIUlV2Q2puRXBRb2YiLCJz
dWIiOiJnaDo2ODI1MDM1MCIsInRleHQiOiJUcmFuc2FjdGlvbi
B2cyBWYWx1ZSBNZXNzYWdlPyIsImNyZWF0ZWQiOjE1OTc3Nzcz
ODgxNDJ9LCJDVFBsS0ZQZFZSY09HRWdqIjp7ImRpc2N1c3Npb2
5JZCI6IkU3T0lSelVobjJpbG91OEEiLCJzdWIiOiJnaDo2ODI1
MDM1MCIsInRleHQiOiJJbWNvbXBsZXRlIiwiY3JlYXRlZCI6MT
U5Nzc3ODAwOTEyMH0sIjV5dUl5NlhWWE5lMExhMDUiOnsiZGlz
Y3Vzc2lvbklkIjoiV1laMWFXeHFKVW9BNmljVSIsInN1YiI6Im
doOjY4MjUwMzUwIiwidGV4dCI6IklzIHRoaXMgNS4yPyIsImNy
ZWF0ZWQiOjE1OTc3NzgxNTQwOTB9LCJCcmJ3RlR4dUJzbEEzMk
l1Ijp7ImRpc2N1c3Npb25JZCI6IkNBeUV1REZOSWJWa1hDWDMi
LCJzdWIiOiJnaDo2ODI1MDM1MCIsInRleHQiOiJUaGlzIGlzIG
5vdCBjb3ZlcmVkIGhlcmUsIHNob3VsZCB3ZSByZWZlciB0byA1
LjQ/IiwiY3JlYXRlZCI6MTU5Nzc3ODE5OTI3OH0sIm5qUkRNNl
JtTXJZSnZ4QTIiOnsiZGlzY3Vzc2lvbklkIjoiZnJ2alVTeUps
S1BoS0REOCIsInN1YiI6ImdoOjY4MjUwMzUwIiwidGV4dCI6Ik
FsbCBvZiB0aGlzIGlzIGluY29tcGxldGUiLCJjcmVhdGVkIjox
NTk3Nzc4MjE4ODE3fSwiNGdkZzVpaUxxT3RkYUE0eCI6eyJkaX
NjdXNzaW9uSWQiOiJFc3lTZ0hIdmNmb2laZFc1Iiwic3ViIjoi
Z2g6NjgyNTAzNTAiLCJ0ZXh0IjoiV2lsbCBzb21ldGhpbmcgYm
Ugd3JpdHRlbiBoZXJlPyIsImNyZWF0ZWQiOjE1OTc3NzgyMzM4
NTl9LCJZYVNCcnk4TlY0eG5VRXJTIjp7ImRpc2N1c3Npb25JZC
I6IjBoRkRQYTNBRFYyQ1FQSjciLCJzdWIiOiJnaDo2ODI1MDM1
MCIsInRleHQiOiJUaGlzIHNlY3Rpb24gc2hvdWwgZWl0aGVyIG
JlIGF0IGJlIGJlZ2lubmluZyBvciBza2lwcGVkIGltby4gVGhl
IGRlcGVuZGVuY2llcyBzaG91bGQgdXNlIHRoZSBwcm9wZXIgcm
VmZXJlbmNlIHdoZW50IGhleSBhcHBlYXIuIiwiY3JlYXRlZCI6
MTU5Nzc3ODQ0NDk4MH0sIkFPV1BoQjR4UWU4NjFQS0MiOnsiZG
lzY3Vzc2lvbklkIjoiSUp6aTh4MEgwRG8wcWNoSCIsInN1YiI6
ImdoOjY4MjUwMzUwIiwidGV4dCI6IlNob3VsZCB3ZSBzYXkgc2
9tdGhpbmcgYWJvdXQgc3luY2hyb25vdXMgdnMgQXN5bmNocm9u
b3VzPyIsImNyZWF0ZWQiOjE1OTc3Nzg1MzMyMjF9LCJNZ01Db1
ltdGh6ell5dktSIjp7ImRpc2N1c3Npb25JZCI6IjcwYW5lYzFu
a1F1UXJqSEoiLCJzdWIiOiJnaDo2ODI1MDM1MCIsInRleHQiOi
JHb3NzaXBpbmc/IiwiY3JlYXRlZCI6MTU5Nzc3ODU2NDk3M30s
IjlqTlUyWjUyNlM3MzZReDciOnsiZGlzY3Vzc2lvbklkIjoiaW
lWcmpnclJocUdTRUpUdSIsInN1YiI6ImdoOjY4MjUwMzUwIiwi
dGV4dCI6IlRocmVzaG9sZCBvZiB0aGUgcHJvcG9ydGlvbiBvZi
BvcGluaW9ucyIsImNyZWF0ZWQiOjE1OTc3Nzk0MzA5NjJ9fSwi
aGlzdG9yeSI6Wy0xNTQxMjQ2MTM2LDk1OTAxMjIxMywxMzM3Nj
Q5NzA0LDU0NjExMTAxOCwtNDM3NDg1MzM0LDQwNjE0NDk1NSw2
MjMyNDE1NTIsMTM1NjE0ODY4LDg1MDAyMzgzNywtMTMwNzYyNj
YzXX0=
-->