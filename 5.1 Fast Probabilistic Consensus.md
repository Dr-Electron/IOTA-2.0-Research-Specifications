+ Feature name:  FPC specifications
+ Start date: 2020-03-16
+ Start revision: 2021-03-03

# 5.1 FPC specification


The module presented in this specification, FPC, allows nodes to find consensus on whether a transaction is valid or not. 

FPC is a voting based consensus protocol. If the validity of a transaction is uncertain, REFER TO LEVEL OF KNOWLEDGE, nodes query each other to find consensus. FPC is divided into rounds. At every round each node queries a random sample of other nodes and updates it opinion according to the rules specified below. This procedure stops locally if a node did not change its opinion over a certain period of time or if some maximal amount of rounds is reached. 

FPC is different from existing voting based consensus protocols, since it uses a sequence of common random numbers. This randomness makes FPC robust in Byzantine environment. We refer to ALL THE RESEARCH PAPERS WE WROTE.

The initial opinions on the validity of transactions are based on "time".  At various parts local clocks, REFER TO LEVEL OF KNOWLEDGE, will be used and compared to the timestamps of messages. There are general standing assumption on network latency and clock synchronisations.  In a nutshell, we consider that the differences in clocks are at least one order of magnitude lower than the network latency. 



The specification will be subdivided into the following subsections:

1. **The core FPC protocol:** our basic consensus protocol on binary opinions. It may be used on different layers and kinds of messages. 
2. **FPC on Tangle:** opinions on transaction of the tangle become dependent. This parts specifies monotonicity and consistency rules.
3. **Message compression:** reducing message complexity through message compression and reducing overhead of demanded nodes by gossiping of opinions.
4. **Gossiping:**
5. **Protocol monitoring:** information every node store for monitoring the main net.
6. **Testing:** This section discusses how the protocol is tested. It subdivides into two parts: testing the logic and test behavior in Byzantine infrastructure.
 
 



# 5.1.1 The core FPC

The protocol tries to find consensus on the validity of an object `objectID`. Every node has an initial opinion `Opinion`(boolean) on this transaction. These opinions are updated in rounds until the protocol terminates using a local stopping rule. 

>[Seb]DO WE HAVE SEVERAL OBJECT TYPES? TX and messages?


## 5.1.1.1 Protocol parameters

* `FinalizationThreshold` integer - Number of consecutive rounds before FPC auto-terminates;
* `FinalizationThreshold2` integer - Number of consecutive rounds with non-random threshold;
* `FirstRoundThreshold`  double - Threshold of the proportion of opinions in the first round;
* `SubsequentRoundsLowerBoundThreshold` double -  Lower random threshold bound in subsequent rounds;
*  `SubsequentRoundsUpperBoundThreshold` double -  Upper random threshold bound in subsequent rounds;
* `maxRound` integer - Maximum number of rounds before querying stops;
* `querySize` integer - Quorum size, number of nodes that are queried;
* `roundLength` double - Duration (in seconds) of a round;
* `timeOut` - maximal waiting time to receive answers dor FPC queries`;


The default values for value objects of the parameters are: 
> [Seb] (They depend on object type that we vote on, so perhaps put this later)

| Parameter  |      Value     | 
|----------|:-------------:|
| `FinalizationThreshold` | 5  |
| `FinalizationThreshold2` |  5     |
| `FirstRoundThreshold` | 0.67|
| `SubsequentRoundsLowerBoundThreshold` | 0.50 |
| `SubsequentRoundsUpperBoundThreshold`| 0.67|
| `maxRound`|100 |
|` querySize` | 21|
| `roundLength`| 10 * time.Seconds |
|`timeOut` | 6500 * time.Millisecond |




## 5.1.1.2 Local variables
The opinion  `Opinion` of a node on an object is the following etype. 
> [Seb](HOW DO WE CALL THESE THINGS?)
```
Opinion: {
    DISLIKE: 0,
    LIKE: 1,
    NULL: NULL  #The node does not know about the object,
    NA : NA # a node does not receive an answer of the opinion of another node
}
```



Every node has the following variables
* `Opinion`  - opinion;
* `nodeList` - list of all nodes;
* `manaList` - list of mana values of nodes;
* `mana` double - mana of node;
* `cnt` integer - counter of the the number of consecutive rounds with unchanged opinion;
* `queryStatus` boolean - status if actively querying;
* `answerStatus` boolean - `TRUE` if answering queries, otherwise `FALSE`;
* `round` integer - counter for the number of rounds in FPC;
* `rn` double - random number provided by from dRNG module;
* `rnCycle` double - random number instance (see X.X.X.X);
* `queryList`- list of nodes to query;
* `queryMax`- maximal number of queries per round;
* `opinionQuery` - list of opinion of nodes in `queryList`, non-replies are encoded with `NA`;
* `reachedMaxRound` boolean - indicating whether protocol reached `maxRound` before auto-termination, default value `FALSE`;


## 5.1.1.3 Function list
* `getIninitialOpinion` input: `objectID` output: `Opinion`;
* `getRN` input: `rnCycle` output: `rn`;
* `getNodes` input:   output: `nodeList`;
* `getConsensusMana` input: `nodeList` output: `manaList`;
* `getSample` input: `querySize` `nodeList` `manaList` : output `queryList`;
* `getOpinion` input: `objectID` `queryList` output: `opinionQuery`;
* `checkQuerySuccessful` input: `queryList` `opinionQuery` output: `querySuccessful`: c*hecks whether `opinionQuery` from `getOpinion` contains enough answers*;
*  `opinionUpdate` input: queryStatus output: `opinion` 

> [name=Seb] How do we write functions? Compare to https://hackmd.io/1oJWLLMPRmaA-GkgWJPi0Q.
## 5.1.1.4 Pseudocode 
 
Note: In the pseudocode at various places global variables are again used as input for the functions. 

### `getInitialOpinion`

>[Seb] Link to Level of Knowledge

### `getRN(layer, a, b, time)`
```
gets a uniform random number between (a,b),
>[Seb] to be discussed/related with DRNG, Be more precise on the source of randomness


OUTPUT: randomThreshold, source of randomness
```

### `getNodes` 

>[Seb] This function should be defined somewhere in autopeering module. But it seems that we need a proper list, since some high mana nodes may not be participating in autopeering

### `getConsensusMana`

>[Seb] This function may be specified in Mana part. We might have to decide here with respect to which time we calculate the mana. As previously discusses, we should not use the mana based on epochs, but current mana list. To avoid big mana changes during an ongoing FPC.


### `getSample(querySize, nodeList, manaList)`
```
queryList = empty
while (queryList does not contain querySize different element){
    newSample:=Sample(nodeList, weight=mana, replacement=TRUE)
    queryList = concat(queryList, newSample)
}
return queryList
```

### `getOpinion(queryList, timeOut)`

```
send queries to all nodes of queryList
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
return opinionQuery
```

### `checkQuerySuccessful(queryList, opinionQuery)`
```
# `manaMin` double - minimal mana of answers that have to arrive before new random number is issued  -> change to function
manaMin:=0.5 #at least 50% of the queried mana has to reply; this value may be changed
queriedMana := sum(manaList[queryList])
answerMana :=  sum(manaList[queryList[replied==TRUE]])/queriedMana
querySuccessful := ifElse( answerMana>= manaMin, TRUE, False)
return querySuccessful
```

### `sendOpinion(timeOut)`

```
answer queries that arrive before lastRoundTime+timeOut
```


### `opinionUpdate(layer, opinion, querySize, nodeList, manaList, FirstRoundThreshold, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)`
```
Sample :=getSample(querySize, nodeList, manaList)
opinionQuery := getOpinion(queryList, timeOut)
if (!checkQuerySuccessful(queryList, opinionQuery)){ #check if sufficiently many nodes replied in time
    newOpinion := opinion # if not keep old opinion 
}
else{ # otherwise update according to FPC rule
    etaStar := mean(opinionQuery, NA.remove=TRUE)
    totalMana := sum(listMana, NA.remove=TRUE) # remove nodes that did not answer
    eta := opinion*mana + etaStar*(totalMana-mana)/totalMana
    if (round == 1){ #first FPC round uses different threshold
        if (eta < FirstRoundThreshold){
            newOpinion <-0
        }
        else newOpinion <-1
    }
    else #the subsequent rounds (before the FinalizationThreshold2 confirming) use random threshold
        rn := getRN(layer, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, time)  # here we have to synchronize/wait for random number
        if (eta < rn){
            newOpinion <-0
        }
        else newOpinion <-1       
}

return newOpinion 
```


### `mainFPC(objectId, queryStatus)`
```
if (queryStatus turns TRUE ){ 
    opinion := getInitialOpinion(objectID)
    listMana := getMana()
    listNode := getNodes()
    cnt := 1
}
wait for new FPC round # next random number from dRNG
#start the first FPC round
round := 1 
opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, FirstRoundThreshold, ubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)
if (opinion==opinionNew) cnt++
else cnt:=0
opinion := opinionNew
round++

#continue FPC, subsequent rounds 
while queryStatus {
    if (cnt <= FinalizationThreshold-FinalizationThreshold2) # we use random threshold{
        opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, FirstRoundThreshold, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)
        if (opinion==opinionNew) cnt++
        else cnt:=0
        opinion := opinionNew
    }
    else {  # we use deterministic threshold for FinalizationThreshold2 "confirming" rounds
    opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, 0.5, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, 1, time)
        if (opinion==opinionNew) cnt++
        else cnt:=0
        opinion := opinionNew      
    }
    round++
    if (cnt==FinalizationThreshold) queryStatus:=FALSE
    if (round>=MaxRound) {
        queryStatus:=FALSE
        reachedMaxRound:=TRUE
    }
}
return(opinion)
```

## 5.1.1.5 Message/ layout

>[seb] Better querry and replay? 
>[seb] To come, can we use goshimmer things? From code

### Querying message

### Answering message

# 5.1.2 FPC on tangle

>[Seb] Current on Pollen, completely independent voting on possibly dependent objects?! So whole section out for specs?

>[Seb] For level of knowledge, what time is used, arrivalTime? solidificationTime? In pollen it is solidificationTime what is in the specs?

In the reality based Tangle,  FPC may have to be applied to various messages simultaneously. Moreover, the Tangle (the local view of every node) has to be monotone and consistent. We have to address the three following points:
* **Parallelity:** Many ongoing votings at the same time 
* **Consistency:** Layer should not contain contradicting messages
* **Monotonicity:** Liked  messages should not refer to disliked messages

## 5.1.2.1 Parallelity
At every round FPC decides on possibly several opinions. However, the every node will only query other nodes once (!). This is done for scalability. 

The local variable `opinions` records the vector of all opinions under vote. 

### `getInitialOpinions`

This function depends on the ontology and uses `getInitialOpinions` in a straightforward way.


### `getOpinions(queryList, timeOut)`
```
send queries to all nodes of queryList
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
return opinionsQuery
```
FPC is now applied for each opinion separately. This may not be optimal, but this is addressed in Section 3. It may that the outcome is not consistent or monotone. 


### single vs. multiple dRNG in each round

Discussion: using a different threshold for every opinion (e.g. hash(objectID) X hash(rn)) may lead to the following attack vector. If the number of votings is large then with high probability some of the will always have a random threshold close to 0.5, in other words for a random subset of tx there is no random threshold and hence the protocol is unsafe. 

Advantage of using the same random threshold is also that the two following functions have less to do, i.e., monotonicity and consistency is increased.

It may be good to use different random thresholds for the voting on different layers! (-> `getRN()`)

## 5.1.2.2 Consistency and Monotonicity

### `applyMonotonicityRule()`
```
functions that make temporary ledger state monoton, past cone of liked tx are like, future cones of disliked tx dislike, generalize these rules to level of knowledge -> Billy
```

### `applyConsistencyRule()`
```
functions that make temporary ledger state consistent
if two contradiction transaction are liked, choose the one with the higher mana (?)/ the previous favorite/ hash?
```
## 5.1.2.3 Data layer
FPC is used in the data layer to decide on the validity of the timestamp of a message. We can use here a symmetric range of the random threshold, `a=beta, b=1-beta`



## 5.1.2.4 Value layer
FPC decides in particular between two conflicting transaction, thresholds below 0.5 may lead to liking both transaction after voting. TO DISCUSS: asymmetric random threshold `a=0.5, b=1-beta`. Since there are no simulations yet, it lay be good to run some to check performances. 


# 5.1.3 Message compression of FPC
>[Seb] to be removed?

## 5.1.3.1 Compression in query messages
**Query:** reduce message identifier, e.g., Prefix trie or Cuckoo filter
**Answer:** Bitmask, respond in same order with 1bit per message

# 5.1.4 Gossiping
High mana nodes will be queried too often. They have the possibility to gossip their opinion. However, it is yet not clear who will  be allowed to gossip. 

### Everybody can gossip
This solution follows the idea that IOTA is all but freedom. Every node can decide on his own whether to gossip or not. Nevertheless, IF has to propose a reference implementation.

Advantages:
* if not in place, high mana nodes may be spammed by querries. But is this a reasonable concern for IOTA 2.0?

Disadvantages: 
* local optimum may not be global optimum
* if all nodes gossip, network may reach congestion. But is this a reasonable concern for IOTA 2.0?

>[Seb] Message layout of statements
```
// Statement defines a Statement payload.
type Statement struct {
	ConflictsCount  uint32
	Conflicts       Conflicts
	TimestampsCount uint32
	Timestamps      Timestamps

	bytes      []byte
	bytesMutex sync.RWMutex
}
```

### Threshold for gossiping

There is a global threshold, like the 100 top mana holders can gossip, the others are querying. However, mana perception is local and hence the threshold can't be sharp. 


### Proposal
TO DISCUSS
* every node is free to gossip
* nodes who gossip, close the port corresponding to queries, this allows other nodes to see whether this node gossips, 
* in IF reference implementation: if own mana perception is above a certain threshold, that would lead to overquery, then gossip

### Changes in the FPC protocol

Warning: the code may depend on the above decision who is going to gossip their opinion. 
### `getOpinions(queryList, timeOut)`
```
send queries to all nodes of queryList that do not gossip
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
read opinions from tangle of all to all nodes of queryList that do gossip

return opinionsQuery
```
Edge cases: what happens if gossiping node is queried? (Angelo: not reply at all, you even don t listen (close ports), Seb: be kind if possible).

If node has to gossip but is not?