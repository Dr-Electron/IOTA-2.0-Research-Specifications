

These specifications are not stable, and are a work in progress.  Please refer to the preface for a description of their exact status. sadkljs


  
-   [Glossary of terms](https://docs.google.com/document/d/1Ak8NT9e9NFQIrXahYmlgj_FLH7mMT5NR4rlTwczfQSE/edit#heading=h.h27luwpmebto)
    
-   [Diagram summarizing the protocol](https://drive.google.com/file/d/1DS5lUas9URTYwspkBl5nlp80R2opE5fC/view?usp=sharing)
    


# Introduction

  

These are the research specifications for the Iota 2.0 protocol. To orientate the reader, we provide a brief summary of the protocol.

  

The network will be maintained via the Networking layer, which consists of two basic modules: the peer discovery module which provides a list of nodes actively using the network, and the neighbor selection (aka autopeering) which actually picks peers. The Networking layer also manages message gossiping.

  

  

The communication layer concerns the information communicated through the network layer. All information exchanged in IOTA 2.0 is contained in objects called messages. To prevent the network from being overloaded, the rate control and congestion control modules control how many messages are created and which and when messages are gossiped. Messages will be stored in the message tangle, whose DAG structure secures all the data, making it immutable. The processing specification describes how messages must be processed in order to meet the demands of the other components.

  

  

On top of the communication layer is the application layer. Anybody can develop applications which run on this layer, and nodes can choose which applications to run. Of course, these applications can also be dependent on each other. There are several core applications which must be run by all nodes.

  

The most important application is the Value Transfer Application which maintains the ledger state and a quantity called mana which is held by each node. Specifically, this application maintains a separate tangle called the value tangle, a DAG whose vertices are called value objects. Each value object contains a transaction, although the same transaction may appear in several different value objects. The references in each value object represent approval, and indicate which transactions should and should not be included into the ledger state.

  

  

Several core applications provide consensus and regulate timestamps in the message tangle and conflicts in the value tangle (a component of the value transfer application). FPC or Fast Probabilistic Consensus is a binary voting protocol which produces consensus on a bit. Section 5.2 outlines how this binary voting protocol is used to vote on actual objects, particularly transactions and messages. In particular, FPC determines which transactions are to be written to the ledger, and which ones should be left to be orphaned. The FPC application relies on another application called the DRNG, the Distributed Random Number Generator. Lastly, the resynchronization application detects any FPC failures.

  

We now provide a more detailed explanation of some of the key components, and we summarize the protocol in the following simple diagram.

![](https://lh6.googleusercontent.com/59VBlXAANn8ccxjsUAsTsErt1HQmlbok20bGyUP1qycVnIg0Q37ba-n6GNWwKUxSTa_qNI-dO4EfpCfZ0bh2QclgxXFyPhwsajdUTWLufsKa7sFVbAXbTo8_7pS5yJLNWhgmIRis)

  

## Mana

  

Several modules require sybil protection, including:

- Congestion control

- Autopeering

- FPC

- DRNG

  

The sybil protection mechanism used in IOTA 2.0 is called mana. Mana is a number associated with each node ID, and can be thought of as extension of the ledger state. Every transaction will contain a `pledged Node ID` field. Roughly speaking, when a transaction is added to the ledger, this node ID will receive mana dependent on the amount of funds moved in the transaction. Thus, transactions not only update the ledger state, but also the mana state.

  

The only way for a node to receive mana is to convince a token holder to pledge them mana when moving funds in a transaction. This can be done in a variety of ways, for example, an individual node operator who owns tokens can create a transaction pledging mana to his own node ID. The exact relationship between token holders and node operators is not discussed in this document. However, since tokens are a scarce resource, mana is also a scarce resource, making it an effective sybil protection mechanism. See Section 4.3 for more details.

  

## FPC

  

FPC stands for Fast Probabilistic Consensus. This is a binary voting protocol that allows a large group of nodes to come to consensus on the value of a Boolean value. The protocol begins with each node having an initial opinion. In each round, nodes randomly choose other nodes to query about their opinions. If the number of responses with the opposite opinion is greater than a certain threshold, the querying node changes its opinion. If a node holds the same opinion for a certain number of rounds, it finalizes on that opinion.

  

In order to prevent liveness attacks, the threshold for changing opinion is determined by a random number issued by a committee of high mana nodes via the DRNG application. Without the random threshold, an attacker can lie about their responses to prevent the protocol from terminating.

  

When selecting which other nodes to query, a node must weight the list of all nodes by mana. Thus, high mana nodes are queried more often then low mana nodes. This makes it difficult for an attacker to manipulate the vote.

  

Unless the attacker controls more than 30% mana in the system, with high probability, we know that FPC has the following properties:

- Termination: every node will finalize on some opinion.

- Agreement: all honest nodes will finalize on the same opinion.

- Integrity: if a super majority of nodes, e.g. more than 70% weighted by mana, have the same initial opinion, then FPC will terminate with that value.

  

See Section 5.1 for more details.

  

## Tip Selection

  

When a new value object is added to the value tangle, the node must choose two other value objects for this object to reference. An honest node always chooses two tips, i.e. objects unreferenced by any other value object. Thus this process is called tip selection. Since references denote approval, tip selection ultimately decides which transactions will be included into the ledger and will change the mana state.

  

It is important that the ledger, and thus the tip selection algorithm, avoid conflicts: transactions which spend the same funds. If a node detects conflicting transactions, it uses FPC to vote on each of the conflicting transactions. Roughly speaking, the initial opinion is set based on which conflict arrived first (actually we use the following rule: has a conflict arrived before 5 seconds after the arrival time). FPC allows nodes to come to consensus on which transactions of a conflict set should be accepted into the ledger.

  

IOTA 2.0 uses what we call restricted uniform random tip selection, or RURTS for short. This means that each node will choose a tip uniformly randomly from a restricted list of eligible tips. A tip is eligible if it is recent and no transaction in a value object in its past cone has been rejected by FPC voting. In this way, FPC effectively regulates the tip selection algorithm.

  

See Sections 3.2 and 4.1 for further details.

  

## Congestion Control

  

Each node in the network has limited bandwidth, CPU, and memory. In order to avoid any node from being overloaded, access to the message tangle is regulated by the congestion control module. Each time a node creates a message, it attempts to use the networkâ€™s resources to have its message be added to everyone's tangle. The congestion control module fairly allocates these resources in the following way.

  

After filtering for duplicates and invalidity, a node places all the messages received in gossip into an inbox. At a fixed global rate (meaning all nodes use the same rate), the node uses a scheduler to choose a message from the inbox and performs the following actions:

- Writes it to the local tangle
- Process the data in its message

- Gossip the message to its neighbors

Because the scheduler works at a fixed rate, the network cannot be overwhelmed.

  

The scheduler essentially acts as a gatekeeper, allocating network resources in a fair manner. The scheduler is designed to have the following properties:

1. Consistency: all honest nodes will schedule the same messages

2. Fair access: the nodes' messages will be scheduled at a fair rate according to their mana

3. Utilization: if the inbox is not empty, then some message will be scheduled

4. Bounded latency: network delay of all messages will be bounded

5. Security: these properties hold even in the presence of an attacker

  

The congestion control algorithm also uses a mechanism called the rate setter to set its own individual rate. The rate setter uses a variant of the AIMD algorithm used in TPC. Essentially, the node measures how many of its own messages are in its inbox. When this number is too large, it means that the node is creating messages faster than they are being scheduled, and so the node decreases its issue rate by a multiplicative factor. The node then slowly increases its rate until the inbox begins to fill back up. The average issuance rate of the node will converge to the fair rate guaranteed by mana.

  

Nodes which do not use the rate setter will be punished by the rate control module which uses adaptive proof of work to limit the rate an attacker can create messages. To issue a message, honest nodes must do a small amount of proof of work. However, if an attacker begins to issue too many messages and floods the network with messages, the difficulty of the proof of work for that node will increase exponentially. Eventually, the attacker will physically be incapable of issuing new messages.
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTAxNzY4MTI2NywtMTE2MjExOTg5LDE2NT
QxOTk1OTcsMjMzNDA5NDEzLDkyOTE2MjA3NCwyMDIxMzYxMjk4
LDYzOTc5ODEzNywtMTEwMzQ3MDcwMCwtMjEyNDAxOTg1LDE0Nz
gyNjMxODEsLTEzNjEzMzU5MTAsNjE5MjMzNTUxLC0xMTcyMTUz
NzYxLDIwOTMwOTg2NjQsNDY5MDI0ODQyLC03MDkxNzY3NDIsNT
I2MDA3NzAyLC0yMjYxMjY4NjksLTQxMTA1NDYzNiwtMTIzODg0
NTc5Ml19
-->