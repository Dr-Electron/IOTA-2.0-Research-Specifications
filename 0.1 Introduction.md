

These specifications are not stable


  
-   [Glossary of terms](https://docs.google.com/document/d/1Ak8NT9e9NFQIrXahYmlgj_FLH7mMT5NR4rlTwczfQSE/edit#heading=h.h27luwpmebto)
    
-   [Diagram summarizing the protocol](https://drive.google.com/file/d/1DS5lUas9URTYwspkBl5nlp80R2opE5fC/view?usp=sharing)
    

# Introduction

These are the research specifications for the Iota 2.0 protocol. To orientate the reader, we provide a brief summary of the protocol. 

The network will be maintained via the Networking layer which consists of two basic modules: the peer discovery module which provides a list of nodes actively using the network, and the neighbor selection (aka autopeering) which actually picks links. The Networking layer also manages the gossiping.

  

The communication layer concerns the information communicated through the network layer. All information exchanged in the Iota 2.0 are contained in objects called messages. To prevent the network from being overloaded, the rate control and congestion control modules control how many messages are created and which messages gossiped. Messages will be stored in the message tangle, whose DAG structure secures all the data. The processing specification describes how messages must be processed in order to meet the demands of the other components.

  

On top of the communication layer is the application layer. Anybody can develop applications which run on this layer, and nodes can choose which applications to run.  Of course, these applications can also be dependent on eachother. There are several core applications which must be run by all nodes. 

The most important application is the Value Transfer Application which maintains the ledger state and a quantity called mana which is held by each node.  Specifically, this application maintains a separate tangle called the value tangle, a DAG whose vertices are called value objects.  Each value object contains a transaction, although the same transaction may appear in several different value objects.  The references in each value object represent approval, and indicate which transactions should and should not be included into the ledger state.  

  

Several core applications provide consensus and regulate timestamps in the message tangle and conflicts in the value tangle (a component of the value transfer application). FPC or Fast Probabilistic Consensus is a binary voting protocol which produces consensus on a bit. Section 5.2 outlines how this binary voting protocol is used to vote on actual objects, particularly transactions and messages.  In particular, FPC determines which transactions are to be written to the ledger, and which ones should be left to be orphaned. The FPC application relies on another application called the DRNG,  the Distributed Random Number Generator. Lastly, the resynchronization application detects any FPC failures.

We now provide a more detailed explanation of some of the key components, and we summarize the protocol in the following simple diagram.
![Iota 2.0 key components](https://drive.google.com/file/d/1KGe4btaRobPs_eG358OhQZ3VClfMG4GG/view?usp=sharing)

## Mana 

Several modules require sybil protection, including:
 - Congestion control
 - Autopeering
 - FPC
 - DRNG

The sybil protection mechanism used in IOTA 2.0 is called mana. Mana is a number associated with each node ID, and can be thought of as extension of the ledger state.  Every transaction will contain a `pleddged Node ID` field.  Roughly speaking, when a transaction is booked, this node ID will receive mana dependent on the amount of funds moved in the transaction.  Thus, when a transaction is booked, the transaction doe not only mutate the ledger state, it also mutates the mana state.  

The only way for a node to receive mana is to convince a token holder to pledge them mana when moving a transaction.  This can be done in a variety of ways, for example, a an individual operating a node can own token, and then create a transaction pledging mana to his own node ID.  The exact relationship between token holders and node operators is not discussed in this document.  However, since token are a scarce resource, mana is also a scarce resource, making it an effective sybil protection mechanism.  See Section 4.3 for more details.  

## FPC 

FPC stands for fast probabilistic consensus.  This is a binary voting protocol that allows a large grout of nodes to come to consensus on the value of a Boolean value.  The protocol begins with each node having an initial opinion.  In each round, nodes randomly choose other nodes to query about their opinion. If the number of responses with the opposite opinion is greater than a certain threshold, the node changes their opinion.  If a node has the same opinion for certain number of rounds, it finalizes on that opinion. 

In order to prevent liveness, attacks, the threshold is determined by a random number created by the DRNG application, where a committee of high mana nodes issues random numbers for each round.  Without the random threshold, an attacker can lie about their responces in such a way to prevent the protocol from terminating.  

When selecting which other nodes to query,  a node must weight the list of all nodes by mana.  Thus, high mana nodes are queried more often then low mana nodes.  This makes it difficult for an attacker to manipulate the vote.

Unless the attacker more than 30% mana in the system, with high probility, we know that FPC has the following properties:
 - Termination: every node will finalize on some opinion.
 - Agreement: all honest nodes will finalize on the same opinion.
 - Integrity: if a super majority of nodes, e.g. more than 70% weighted by mana, have the same initial opinion, then FPC will terminate with that value.  

See Section 5.1 for more details.  

## Tip Selection

When a new value object is added to the value tangle, the node must choose two other value objects for this object to reference.     An honest node always chooses two tips, i.e. objects unreferenced by any other value object. Thus this process is called tip selection. Since references denote approval, tip selection ultimately decides which transactions will be included into the ledger and will mutate the mana state.  

It is important that the ledger, and thus the tip selection algorithm, avoids conflicts: transactions which spend the same funds. If a node detects conflicting transactions, it has FPC vote on each of the conflicting transactions.  Roughly speaking, the initial opinion is set based on which conflict arrived first (actually we use the following rule: has a conflict arrived before 5 seconds after the arrival time).  FPC allows nodes to come to consensus on which transactions of a conflict set should be accepted into the ledger. 

The Iota 2.0 protocol will use what we call restricted uniform random tip selection, or RURTS for short.  This means, that each node will choose a tip uniformly randomly from a restricted list of eligible tips.  A tip is eligible if it is recent and no  transaction in a value object in its past cone has been rejected by FPC voting.  In this way, FPC effectively regulates the tip selection algorithm.

See Sections 3.2 and 4.1 for further details.  

## Congestion Control

Each node in the network has limited bandwidth, CPU, and memory.  In order for no node to be overloaded, access to the message tangle is regulated by the congestion control module.     Each time a node creates a message, it attempts to use the networks resources to have its message be added to everyone's tangle.  The congestion control module fairly allocates these resources in the following way.

After filtering for duplicates and invalidity, a node places all the messages received in gossip into an inbox.  At a fixed  global rate (meaning all nodes use the same rate), the node uses a scheduler to choose a message from the inbox and performs the following actions:
 - Writes it to the local tangle
 - Process its the data in the message
 - Gossip the message to the neighbors. 
Because the scheduler works at a fixed rate, the network cannot be overwhelmed.

The scheduler essentially acts as a gate keeper, allocating the network resources in a fair manner.  The scheduler is designed to have the following properties.  
 1. Consistency: all honest nodes will schedule the same messages.
 2. Fair access: the nodes' messages will be scheduled at a fair rate according to their mana.  
 3. Utilization: If the inbox is not empty, then some message will be scheduled.
 4. Bounded latency: network delay of all messages will be bounded.  
 5. Security: these properties hold even under an attacker. 



 






 
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTk3MjE5NjM2Niw2Mzk3OTgxMzcsLTExMD
M0NzA3MDAsLTIxMjQwMTk4NSwxNDc4MjYzMTgxLC0xMzYxMzM1
OTEwLDYxOTIzMzU1MSwtMTE3MjE1Mzc2MSwyMDkzMDk4NjY0LD
Q2OTAyNDg0MiwtNzA5MTc2NzQyLDUyNjAwNzcwMiwtMjI2MTI2
ODY5LC00MTEwNTQ2MzYsLTEyMzg4NDU3OTIsNDQwMDI4MzY3LD
k2NTc3ODYwOV19
-->