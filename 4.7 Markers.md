# 4.7.1 Markers

This section defines the *Marker* tool.

## Motivation

For certain applications we need to know, whether a certain message is in the past or future cone of another message. Furthermore, in order to compute the approval weight of a given message we need to traverse the Tangle from the message to the tips and sum up the active consensus mana of all the messages in its future cone. These operations can be numerically expensive.

The Marker tool allows to efficiently determine whether certain Markers are in the past or future cone of a given message, by reducing the proportion of the Tangle that needs to be traversed. Thus reducing significantly the effort to identify wether certain messages are in the past or future cone of another message. It also enables to efficiently estimate the approval weight of a message.

## Definitions

Let's define the terms related to Markers:
* **UTXO branch:** A subset of the Tangle, in which all messages approve a certain subset of UTXO transactions, which from the point of view of the node are not on the main branch. The main branch is the set of all txs which approve only messages that are considered to be good.
* **Marker:** A transaction that locally is assigned additional properties and that tracks a particular UTXO branch.
* **Marker Rank (`MR`):** The rank of a Marker in the Marker DAG.
* **Sequence:** A Sequence is a Sequence of Markers, where each Marker corresponds to same UTXO branch.
* **Sequence Identifier (`Sid`):** A Sequence Identifier is the unique identifier of a Sequence. 
* **Sequence rank (`SR`):** The rank of a Sequence in the Sequence DAG.
* **Future Marker (FM):** A future Marker of a message is the first Marker that is created in its future cone from different Sequences; this field in the message metadata is updated when the new Marker is generated in the future, following the rules defined in (#future-Markers).
* **Past Marker (PM):** A past Marker of a message is a Marker in its past cone. For a given Sequence it is set to the newest past Marker of its parents, that is the one that has the largest `MR`. The past Marker of a Marker is set to itself.


## The Markers

Markers are messages selected from the strong tips set at random, and selected from the weak tips set if there's no strong tip. They are assigned unique identifiers, which we call **Marker Detail**, and which take  the form

<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
    </tr>
    <tr>
        <td><code>Sid</code></td>
        <td>int</td>
    </tr>
    <tr>
        <td><code>MR</code></td>
        <td>int</td>
    </tr>
</table>

A new Marker is created when: 
* a new Sequence is created.
* more than a certain number of messages have been received since the last Marker.
* a certain time window has passed.

The `Sid` value is set according to the following rules:
* Inherit the `Sid` from parents if the new Marker references the latest Marker of a Sequence and meets the requirement to set up a new Marker without initiating a new Marker Sequence.
* Create a new `Sid` if it is the first Marker of a new Sequence.

The `MR` is set to `MR=1+max(referenced MR)`, which complies to the rule:
+ Marker ranks are monotonically increasing such that $\forall x \in fc(y)$ => $\texttt{MR}_x > \texttt{MR}_y$, where $fc(y)$ is the future cone of $y$ and $x$ is any message in that future cone.


## The Sequence
Sequences are used to track the UTXO DAG branches, each branch corresponds to a Sequence with a unique `Sid`, and the Sequences form a DAG. Each Sequence is associated with some meta data:

### Sequence data

Each Sequence is associated with some data. In particular this is

<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td><code>Sid</code> </td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td><code>SR</code></td>
        <td>int</td>
        <td></td>
    </tr>
    <tr>
        <td><code>MR_max</code></td>
        <td>int</td>
        <td>The highest <code>MR</code> of the own Marker Sequence.</td>
    </tr>
    <tr>
        <td><code>MR_min</code></td>
        <td>int</td>
        <td>The lowest <code>MR</code> of the own Marker Sequence.</td>
    </tr>
    <tr>
        <td><code>ParentReferences</code></td>
        <td>map[<code>Sid</code>] Reference</td>
        <td>Relationship map to parent Sequence Markers*</td>
    </tr>
</table>


*The field `ParentReferences` models the relationship between Sequences by providing a way to encode which Marker in the Sequence references which other Markers from other Sequences. For a given Sequence the list of indexes of type `Sid` in the map does not alter, since they define the Sequence, however the references may.

For whatever reason a sequence is created, we assign a new `SR=1+max(referenced SR)`. To prevent assigning a new `Sid` when combining the same Sequences again, we build parents-child relationships in a map if a new sequence is created. 


### Creation of Sequences
A new Sequence is created when:
1. there's a conflict in a UTXO branch.
2. the UTXO branches are aggregated.
3. UTXO branches are merged.

Each new Sequence starts with a new Marker. 



## Metadata for transactions

Each message maintains metadata that provides information about the markers that lie in the past or future cone of the message, as well as whether the message itself is a marker and what rank the message has:

<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td><code>MR</code></td>
        <td>int</td>
        <td>The Marker rank of the message.</td>
    </tr>
    <tr>
        <td><code>IsMarker</code></td>
        <td>bool</td>
        <td>A flag to indicate whether a message is a marker.</td>
    </tr>
    <tr>
        <td><code>PastMarker</code></td>
        <td>[<code>Sid</code>]<code>MR</code></td>
        <td>The list of the PMs from different sequences in the past of the message.</td>
    </tr>
    <tr>
        <td><code>FutureMarkers</code></td>
        <td>map[<code>Sid</code>]<code>MR</code></td>
        <td>The list of the FMs from different sequences in the future of the message.</td>     
    </tr>
</table>


# 

The `PastMarker` field contains 
* the Marker Detail of itself, if the message is a marker.
* the Marker Detail of its closest PMs, i.e. from each referenced sequence only the markers with the highest MR. Furthermore, Markers which are referenced by other Markers in this list are also removed, such that the list only contains the 'tips' of the Marker DAG.

The `FutureMarkers` list is empty at start and gets updated when a new marker directly or indirectly references it. 
The propagation of a FM to its past cone (i.e. the update of the `FutureMarkers` list in the encountered messages) does not continue beyond a message if:
1. `FutureMarkers` of a message includes a previous marker of the same sequence;
2. the message is the marker in a different sequence. Then we update `FutureMarkers` of that marker only.

Here is an example of how the Markers and Sequences would look in the Tangle from the perspective of the Message DAG, the Marker DAG and the Sequence DAG
(the purple colored messages are markers):

![](https://i.imgur.com/GENej3O.png)

## Approval weight

To approximate the approval weight of a message, we simply retrieve the approval weight of `FutureMarkers`. Since the message is in the past cone of its FMs, the approval weight and the finality will be at least the same as its FMs. This will of course be a lower bound (which is the “safe” bound), but if the markers are set frequently enough, it should be a good approximation.

## Past cone check

By comparing the `PastMarker` of a message with the `FutureMarkers` of another message, we can tell if one is in the others past cone. However, it is also possible the Marker DAG does not cover certain areas of the message DAG yet, and thus a check on this question can get the three values:

* `True` 
* `False` 
* `Maybe`

If the check returns a `Maybe`, then the Message DAG must be searched via a walk.