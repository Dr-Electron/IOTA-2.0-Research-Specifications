# 2.1 Message Layout

## Data types
| Name   | Description   |
| ------ | ------------- |
| uint8  | An unsigned 8 bit integer encoded in Little Endian. |
| uint16  | An unsigned 16 bit integer encoded in Little Endian. |
| uint32  | An unsigned 32 bit integer encoded in Little Endian. |
| uint64  | An unsigned 64 bit integer encoded in Little Endian. |
| ByteArray[N] | A static size array of size N.   |
| ByteArray | A dynamically sized array. A uint32 denotes its length.   |
| string | A dynamically sized array of an UTF-8 encoded string. A uint16 denotes its length.   |
| time    | Unix time in nanoseconds stored as `int64`, i.e., the number of nanoseconds elapsed since January 1, 1970 UTC. |

<summary>Subschema Notation</summary>
<table>
    <tr>
        <th>Name</th>
        <th>Description</th>
    </tr>
    <tr>
        <td><code>oneOf</code></td>
        <td>One of the listed subschemas.</td>
    </tr>
    <tr>
        <td><code>optOneOf</code></td>
        <td>Optionally one of the listed subschemas.</td>
    </tr>
    <tr>
        <td><code>anyOf</code></td>
        <td>Any (one or more) of the listed subschemas.</td>
    </tr>
    <tr>
        <td><code>between(x,y)</code></td>
        <td>Between (but including) x and y of the listed subschemas.</td>
    </tr>
</table>

## Parameters
- `MAX_MESSAGE_SIZE=64 KB` The maximum allowed message size.
- `MAX_PAYLOAD_SIZE=65157 B` The maximum allowed payload size.
- `MIN_STRONG_PARENTS=1` The minimum amount of strong parents a message needs to reference.



### Message structure
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Version</td>
        <td>uint8</td>
        <td>The message version. The schema specified in this RFC is for version <strong>1</strong> only. </td>
    </tr>
    <tr>
        <td>Parents count</td>
        <td>uint8</td>
        <td>The amount of parents proceeding.</td>
    </tr>
    <tr>
        <td>Parents type</td>
        <td>uint8</td>
        <td>Bitwise encoding of parent type matching the order of proceeding parents starting at <code>least significant bit</code>. <code>1</code> indicates a strong parent, while <code>0</code> signals a weak parent. At least <code>MIN_STRONG_PARENTS</code> parent type needs to be strong.</td>
    </tr>
    <tr>
        <td colspan="1">
            Parents <code>between(2,8)</code>
        </td>
        <td colspan="2">
            <details open="true">
                <summary>Parents, ordered by hash ASC</summary>
                <table>
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>Parent</td>
                        <td>ByteArray[32]</td>
                        <td>The Message ID of the <i>Message</i> it references.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
    <tr>
        <td>Issuer public key (Ed25519)</td>
        <td>ByteArray[32]</td>
        <td>The public key of the node issuing the message.</td>
    </tr>
    <tr>
        <td>Issuing time</td>
        <td>time</td>
        <td>The time the message was issued.</td>
    </tr>
    <tr>
        <td>Sequence number</td>
        <td>uint64</td>
        <td>The always increasing number of issued messages of the issuing node.</td>
    </tr>
    <tr>
        <td>Payload length</td>
        <td>uint32</td>
        <td>The length of the Payload. Since its type may be unknown to the node, it must be declared in advance. 0 length means no payload will be attached.</td>
    </tr>
    <tr>
        <td colspan="1">
            Payload
        </td>
        <td colspan="2">
            <details open="true">
                <summary>Generic Payload</summary>
                <blockquote>
                An outline of a general payload
                </blockquote>
                <table>
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>Payload Type</td>
                        <td>uint32</td>
                        <td>
                            The type of the payload. It will instruct the node how to parse the fields that follow. Types in the range of 0-127 are "core types", that all nodes are expected to know.
                        </td>
                    </tr>
                    <tr>
                        <td>Data Fields</td>
                        <td>ANY</td>
                        <td>A sequence of fields, where the structure depends on <code>payload type</code>.</td>
                    </tr>
                </table>
            </details>
            </td>
    </tr>
    <tr>
        <td>Nonce</td>
        <td>uint64</td>
        <td>The nonce which lets this message fulfill the adaptive Proof-of-Work requirement.</td>
    </tr>
    <tr>
        <td>Signature (Ed25519)</td>
        <td>ByteArray[64]</td>
        <td>Signature of the issuing node's private key signing the entire message bytes.</td>
    </tr>
</table>


### Syntactical Validation
Messages that do no pass the Syntactical Validation are discarded. Only syntactically valid messages continue in the data flow, i.e., pass to the Semantic Validation.

A message is syntactically valid if:
1. The message length does not exceed `MAX_MESSAGE_SIZE` bytes.
2. When we are done parsing the message, there are not any trailing bytes left that were not parsed.
4. At least 1 and at most 8 distinct parents are given, ordered ASC and at least `MIN_STRONG_PARENTS` are strong parents. 


### Metadata
Next to a message itself, a node needs to store additional data that describe its local perception of this message and are not part of the Tangle.

<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>receivedTime</td>
        <td>time</td>
        <td>The local time the message was received by the node.</td>
    </tr>
    <tr>
        <td>solid</td>
        <td>bool</td>
        <td>Denotes whether a message is solid, i.e., its past cone is known.</td>
    </tr>
    <tr>
        <td>solidificationTime</td>
        <td>time</td>
        <td>The local time the message got solid.</td>
    </tr>
    <tr>
        <td>opinion</td>
        <td>Opinion</td>
        <td>Contains a nodes' opinion on the timestamp of a message. A triple <code>(opinion, level, timeFormed)</code>, where opinion is a bool, level is in the set {1,2,3}, and timeFormed is a time. The opinionField is also manipulated by FPC. TODO: this should be defined probably in the FPC specs?</td>
    </tr>
    <tr>
        <td>eligible</td>
        <td>bool</td>
        <td>Denotes whether a message is eligible.</td>
    </tr>
</table>